{*******************************************************}
{*******************************************************}
{                                                       }
{       xTool - Component Collection                    }
{                                                       }
{       Copyright (c) 1995 Stefan Böther                }
{                            stefc@fabula.com           }
{*******************************************************}

{  Please look also for our xTools-Nails function toolkit.
  You'll find more information at
     http://ourworld.compuserve.com/homepages/stefc/xprocs.htm

  Any comments and suggestions are welcome; please send to:
     stefc@fabula.com.

   21.02.96  added TMonth & TDay type                                Stefc
   22.02.96  added strFileLoad & strFileSave                         Stefc
   09.03.96  correct sysTempPath                                     Stefc
   09.03.96  added regXXXXX functions for access the registry        Stefc
   24.03.96  added IsWinNT constant                                  Stefc
   24.03.96  added SysMetric object                                  Stefc
   26.03.96  added dateQuicken for controling date input with keys   Stefc
   27.03.96  added TDesktopCanvas here                               Stefc
   28.03.96  added LoadDIBitmap                                      Stefc
   01.04.96  added Question function here                            Stefc
   09.04.96  added sysSaverRunning added                             Stefc
   12.04.96  added timeZoneOffset                                    Stefc
   12.04.96  added timeToInt                                         Stefc
   17.04.96  added strCmdLine                                        Stefc
   17.04.96  added rectBounds                                        Stefc
   17.04.96  added TPersistentRect class                             Stefc
   19.04.96  added strDebug method                                   Stefc
   21.04.96  changed TMonth added noneMonth                          km
   21.04.96  added licence callback                                  Stefc
   21.04.96  added strNiceDateDefault                                km
   21.04.96  added simple strEncrpyt & strDecrypt                    Stefc
   24.04.96  backport to 16 bit                                      Stefc
   24.04.96  added Information method                                Stefc
   24.04.96  use win messageBox with Win95 in Question & Information Stefc
   09.05.96  new function ExtractName                                Stefc
   10.05.96  Added TPersistentRegistry                               Stefc
   12.05.96  fileExec                                                Stefc
   14.05.96  New function Confirmation                               Stefc
   16.05.96  New function strChange                                  Stefc
   29.05.96  New functions comXXXXX                                  Stefc
   09.06.96  New function strSearchReplace                           km
   09.06.96  ported assembler strHash to plain pascal                Stefc
   15.06.96  new variables xLanguage & xLangOfs                      Stefc
   28.06.96  new method sysBeep                                      Stefc
   28.06.96  new method intPercent                                   Stefc
   10.07.96  make compatible with 16 Bit Delphi 1.0                  Stefc
   14.07.96  fileLongName & fileShortName defined                    Stefc
   15.07.96  Correct sysTempPath method                              Stefc
   21.07.96  New functions strContains & strContainsU                Stefc
   28.07.96  comIsCServe also check for xxx@compuServe.com           Stefc
   31.07.96  added strCapitalize after idea from Fred N. Read        Stefc
   04.08.96  strByteSize() now can also display Bytes                Stefc
   05.08.96  added regWriteShellExt()                                Stefc
   06.08.96  added sysColorDepth()                                   Stefc
   07.08.96  added strSoundex()                                      Stefc
   09.08.96  fixe some bugs in fileShellXXXX                         Stefc
   26.08.96  Added registry functions from David W. Yutzy            Stefc
   29.08.96  fileShellXXX now also aviable under 16 Bit              Stefc
   05.09.96  Added regDelValue                                       Stefc
   13.09.96  Added fltNegativ and fltPositiv                         Stefc
   29.09.96  Added strTokenToStrings & strTokenFromStrings           Stefc
   09.10.96  Added variant function                                  Stefc
   29.10.96  intPrime now can be used for negative numbers           Stefc
   29.10.96  fltEqualZero now returns true with FLTZERO              Stefc
   29.10.96  fltCalc now use Float for greater precision             Stefc
   29.10.96  correct strTokenCount                                   Stefc
   19.11.96  better Windows NT detecting                             Stefc
   28.11.96  correct above text (thanks to Clay Kollenborn-Shannon)  Stefc
   12.01.96  added fileCopy function                                 Stefc
   13.01.96  correct strProfile now it works also for 16-Bit         Stefc
   13.01.96  get English Quicken keys from George Boomer             Stefc
   14.01.96  make key in dateQuicken var to reset if on date change  Stefc
   17.01.96  New functions strPos and strChangeU                     Stefc
   19.01.96  new function fileTypeName after idea of P.Aschenbacher  Stefc
   19.01.96  new function fileRedirectExec                           Stefc
}
unit xProcs;

(*{kk$ddd D-} *)

interface

{.$DEFINE German}
{.$DEFINE English}

uses
{$IFDEF Win32}Windows, Registry, {$ELSE}WinTypes, WinProcs, {$ENDIF}
  ShellAPI, Messages, Classes, Graphics, extctrls, Mask, NB30, DB,
  Dialogs, Controls,
  stdctrls, MaskUtils, CheckLst, DBGrids, Variants,

  Data.DBXCommon,
  WinSvc,
  Tlhelp32, PsAPI,  DBClient, SqlExpr, DateUtils, Forms, Menus, TypInfo,
  Printers, WinSpool, Winsock, IdBaseComponent, IdComponent, IdIPWatch, Buttons,
  FireDAC.Stan.Intf, FireDAC.Stan.Option, FireDAC.Stan.Param,
  FireDAC.Stan.Error, FireDAC.DatS, FireDAC.Phys.Intf, FireDAC.DApt.Intf,
  FireDAC.Stan.Async, FireDAC.DApt, FireDAC.Comp.DataSet, FireDAC.Comp.Client, System.Zip;

type
  Float = Extended; { our type for float arithmetic }

{$IFDEF Win32} { our type for integer functions, Int_ is ever 32 bit }
  Int_ = Integer;
{$ELSE}
  Int_ = Longint;
{$ENDIF}

  TConsisteInscricaoEstadual = function(const Insc, UF: AnsiString): Integer;
  stdcall;

  TAdapter = packed record
    Adapt: TAdapterStatus;
    NameBuff: TNameBuffer;
  end;

const
  XCOMPANY = '';

const
  { several important ASCII codes }
  NULL = #0;
  BACKSPACE = #8;
  TAB = #9;
  LF = #10;
  CR = #13;
  EOF_ = #26; { 30.07.96 sb }
  ESC = #27;
  BLANK = #32;
  SPACE = BLANK;

  { digits as chars }
  ZERO = '0';
  ONE = '1';
  TWO = '2';
  THREE = '3';
  FOUR = '4';
  FIVE = '5';
  SIX = '6';
  SEVEN = '7';
  EIGHT = '8';
  NINE = '9';

  { special codes }
  SLASH = '\'; { used in filenames }
  HEX_PREFIX = '$'; { prefix for hexnumbers }

{$IFDEF Win32}
  BARRA = '\';
{$ELSE}
  BARRA = '/';
{$ENDIF}

  CRLF: PChar = CR + LF;

  { common computer sizes }
  KBYTE = Sizeof(Byte) shl 10;
  MBYTE = KBYTE shl 10;
  GBYTE = MBYTE shl 10;

  { Low floating point value }
  FLTZERO: Float = 0.00000001;

  DIGITS: set of Char = [ZERO..NINE];

  { important registry keys / items }
  REG_CURRENT_VERSION = 'Software\Microsoft\Windows\CurrentVersion';
  REG_CURRENT_USER = 'RegisteredOwner';
  REG_CURRENT_COMPANY = 'RegisteredOrganization';

  PRIME_16 = 65521;
  PRIME_32 = 2147483647;

  MINSHORTINT = -128; { 1.8.96 sb }
  MAXSHORTINT = 127;
  MINBYTE = 0;
  MAXBYTE = 255;
  MINWORD = 0;
  MAXWORD = 65535;

type
  TMonth = (NoneMonth, January, February, March, April, May, June, July,
    August, September, October, November, December);

  TDayOfWeek = (Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday);

  { Online eMail Service Provider }
  TMailProvider = (mpCServe, mpInternet, mpNone);

  TLicCallback = function(var Code: Integer): Integer;

  TBit = 0..31;

  { Search and Replace options }
  TSROption = (srWord, srCase, srAll);
  TSROptions = set of TsrOption;

  { Data types }
  TDataType = (dtInteger, dtBoolean, dtString, dtDate, dtTime,
    dtFloat, dtCurrency);

  TResultArrayStr = array of string;

var
  IsWin95, IsWinNT,
  ModMOVCH, ModCOMCH, ModVDACH, ModFINCH, ModFISCH, ModONLCH, ModCNCH, ModGICH, ModSECCH, ModSTARTCH, ModCTBCH,
  ModSPEDFCH, ModSPEDCCH, ModPOSTOCH, ModMOBCH, ModACORDCH, ModECOMMCH, ModNFECH, ModMIXFCH, ModCotaWebCH, ModRH,
  ModDisplay, ModDashboard, ModConCartao, ModNeoGrid, ModSiteMercado, ModVeloxCode, ModBling, ModScanntech, ModBenassi,
  ModSupraSys, ModIncoleta, ModZoomBox, ModCresceVendas, ModMercafacil, ModTopSistemas, ModNFSECH, vNaoValVerBD, vImpAntec,
  ModNexello, ModKikker, ModSimplo7, ModBeHappy, ModSiCompra, ModOctopo, ModVercer, ModInstabuy, ModMMC: Boolean;
  IsFabula: TLicCallBack;

  xLanguage: Integer;
  xLangOfs: Integer;


  { Manipula SQLQuery em tempo Execução }
  //function TD: {$IFDEF VER150}TTransactionDesc{$ELSE}TDBXTransaction{$ENDIF};

{ bit manipulating }
function iif(Expressao: Variant; ParteTRUE, ParteFALSE: Variant): Variant;
procedure RecriaSQLQry(var Qry: TSQLQuery); overload;
procedure LimpaSQLQry(var Qry: TSQLQuery); overload;
procedure LimpaSQLQry(var Qry: TFDQuery); overload;
procedure CriaSQLQry(var Qry: TSQLQuery);  overload
procedure CriaSQLQry(var Qry: TFDQuery);   overload;
function bitSet(const Value: Int_; const TheBit: TBit): Boolean;
function bitOn(const Value: Int_; const TheBit: TBit): Int_;
function bitOff(const Value: Int_; const TheBit: TBit): Int_;
function bitToggle(const Value: Int_; const TheBit: TBit): Int_;
function ASC(inString: string): Byte;
function ComandoImpr(cadeia: string): string;
function ObterVariavelDeSistema(const Nome: string): string;

function paraServico(p_maquina, p_servico : string ) : boolean;

{ String functions }
function strHash(const S: string; LastBucket: Integer): Integer;
function strCut(const S: string; Len: Integer): string;
function strCutLast(const S: string): string;
function strTrim(const S: string): string;
function strTrimA(const S: string): string;
function strTrimChA(const S: string; C: Char): string;
function strTrimChL(const S: string; C: Char): string;
function strTrimChR(const S: string; C: Char): string;
function strLeft(const S: string; Len: Integer): string;
function strLower(const S: string): string;
function strMake(C: Char; Len: Integer): string;
function strPadChL(const S: string; C: Char; Len: Integer): string;
function strPadChR(const S: string; C: Char; Len: Integer): string;
function strPadChC(const S: string; C: Char; Len: Integer): string;
function strPadL(const S: string; Len: Integer): string;
function StrToChr(Str: string; Pos: Integer): Char;
function FormatStrPadNulL(const Mask: string; Val: Currency; Len: Integer):
  string;
function strPadR(const S: string; Len: Integer): string;
function strPadC(const S: string; Len: Integer): string;
function strPadZeroL(const S: string; Len: Integer): string;
function strPadZeroR(const S: string; Len: Integer): string;
function StrPad(Text: String; Size: Integer; Filler: String; Side: Char): String; overload;
function StrPad(Text: Int64; Size: Integer; Filler: String; Side: Char): String; overload;
function StrPad(Text: Real; Size: Integer; Filler: String; Side: Char): String; overload;
function strPos(const aSubstr, S: string; aOfs: Integer): Integer;
procedure strChange(var S: string; const Src, Dest: string);
procedure strChangeX(var S: string; const Src, Dest: string; X: Word);
procedure strDelete(var S: string; const Src: string);
function DelZeroLeft(const S: string): string;
function DelChars(const S: string; Chr: Char): string; overload;
function DelChars(const S: string) : string; overload;
function DelCharsABC(const S: string): string;
function DelCharsAspas(const S: string): string;
function DelCharsEspec(const S: string): string;
function DelCharsStop(const S: string; Chr, Stop: Char): string;
procedure DelWord(var Source : string; Word : string);
function ExtractText(const Str: string; const Delim1, Delim2: char): string;
function strChangeU(const S, Source, Dest: string): string;
function strRight(const S: string; Len: Integer): string;
function strAddSlash(const S: string): string;
function strDelSlash(const S: string): string;
function strSpace(Len: Integer): string;
function strToken(var S: string; Seperator: Char): string;
function strTokenCount(S: string; Seperator: Char): Integer;
function strTokenAt(const S: string; Seperator: Char; At: Integer): string;
procedure strTokenToStrings(S: string; Seperator: Char; List: TStrings);
function strTokenFromStrings(Seperator: Char; List: TStrings): string;
function strUpper(const S: string): string;
function strOemAnsi(const S: string): string;
function strAnsiOem(const S: string): string;
function strEqual(const S1, S2: string): Boolean;
function strComp(const S1, S2: string): Boolean;
function strCompU(const S1, S2: string): Boolean;
function strContains(const S1, S2: string): Boolean;
function strContainsU(const S1, S2: string): Boolean;
function strNiceNum(const S: string): string;
function strNiceDateDefault(const S, Default: string): string;
function strNiceDate(const S: string): string;
function strNiceTime(const S: string): string;
function strNicePhone(const S: string): string;
function strReplace(const S: string; C: Char; const Replace: string): string;
function strCmdLine: string;
function strEncrypt(const S: string; Key: Word): string;
function strDecrypt(const S: string; Key: Word): string;
function strLastCh(const S: string): Char;
procedure strStripLast(var S: string);
function strByteSize(Value: Longint): string;
function strSoundex(S: string): string;
procedure strSearchReplace(var S: string;
  const Source, Dest: string; Options: TSRoptions);
function strProfile(const aFile, aSection, aEntry, aDefault: string): string;
function strCapitalize(const S: string): string; { 31.07.96 sb }
function StrPegaParte(Texto: string; Separador: Char; Parte: SmallInt): string;
function Split(aValue: string; aDelimiter: Char): TStringList;
function Splitstr(valor, caracter: string; index: integer): string;
function NumRegistroStr(Query: TDataSet): string;
function CurrToStrNaoSepDecimal(Valor: Currency; TamEsquerda, TamDireita:
  SmallInt): string;
function SoNumero(Texto: string): string;
function IniciaisMaiusculas(Texto : String) : string;
function EliminaNumeros(Campo: string): String;
function RplcVirgPto(vValor : String) : String;
function LRPad(Str : String; Size : integer; Pad : char; LorR : char):string;
function ExisteCaractere(Str, Caract : String) : Boolean;
function CenterStr(vStr: String; vTam: Integer): String;
function StrLBDelete(Text: String): String;
function StringInSet(const S: String; const StringSet: array of String): Boolean;
procedure SaveStrFile(aContent, aFileName : string);
function GetTxtAlfa(aTam : integer = 4): string;


{$IFDEF Win32}
procedure strDebug(const S: string);
function strFileLoad(const aFile: string): string;
procedure strFileSave(const aFile, aString: string);
{$ENDIF}

{ Integer functions }
function intCenter(a, b: Int_): Int_;
function intMax(a, b: Int_): Int_;
function intMin(a, b: Int_): Int_;
function intPow(Base, Expo: Integer): Int_;
function intPow10(Exponent: Integer): Int_;
function intSign(a: Int_): Integer;
function intZero(a: Int_; Len: Integer): string;
function intPrime(Value: Integer): Boolean;
function intPercent(a, b: Int_): Int_;
function DiasCobertura(VendaMedia, EstoqueAtual: Double): Int_;
function NumRegistro(Query: TDataSet): Integer;
function SomaCampoValor(Query: TDataSet; Campo: string): Double;

{ Floatingpoint functions }
function FloatMod(aDividendo, aDivisor : double): double;
function fltAdd(P1, P2: Float; Decimals: Integer): Float;
function fltDiv(P1, P2: Float; Decimals: Integer): Float;
function fltEqual(P1, P2: Float; Decimals: Integer): Boolean;
function fltEqualZero(P: Float): Boolean;
function fltGreaterZero(P: Float): Boolean;
function fltLessZero(P: Float): Boolean;
function fltNeg(P: Float; Negate: Boolean): Float;
function fltMul(P1, P2: Float; Decimals: Integer): Float;
function fltRound(P: Float; Decimals: Integer): Float;
function fltSub(P1, P2: Float; Decimals: Integer): Float;
function fltUnEqualZero(P: Float): Boolean;
function fltCalc(const Expr: string): Float;
function fltPower(a, n: Float): Float;
function fltPositiv(Value: Float): Float;
function fltNegativ(Value: Float): Float;
function Tolerancia(Val_1, Val_2, Tolerancia: Currency): Boolean;
function ToleraValor(Val_1, Val_2, PerTolerancia: Currency): Boolean;
function Variacao(Val_1, Val_2: Float): Float;
function QtdeSugestao(IPV: string; PEntrega, DiaSeg, FreqVis: Integer; VdaMedia,
  EstAtual, PedCpa, PedVda: Double): Double;
procedure CalcFator(ValTotal, ValItem: Currency; var CustoUnit: Currency);
function CalcCustoSemICMS(CustoRep: Currency; ICMS: double): Currency;
function CalcCustoDifICMS(CustoRep: Currency; ICMSe, ICMSs: double): Currency;
function CalcCustoMedio(CustoRepAtual, CustoMedAnt, QtdeAnt, QtdeAtual:
  Double): Currency;
function CalcCustoMedioSaida(CustoRepAtual, CustoMedAnt, QtdeAnt, QtdeAtual:
  Double): Currency;
function CalcLucro(Custo, Venda, Oferta: Currency): Currency;
function CalcLucroContribuicao(CustoSImp, Venda, ImpostoDeb: Currency): Currency;
function CalcPOC(ValPesq: Currency; MgRef: Double): Currency;
function CalcImpostoCredito(vCusto_ICMS, vCusto_PISCof, pICMSE, pPISE, pCofinsE: Double; FlgNaoPisCofins, FlgNaoICMS: Boolean): Currency;
function CalcImpostoDebito(vVendaOferta, pICMSS, pPIS, pCofins: Double;
  FlgNaoPisCofins, FlgNaoICMS: Boolean): Currency;
function CalcCustoSCred(vCusto_ICMS, vCusto_PISCof, vCustoRep, pICMSE, pPISE, pCofinsE: Double; FlgNaoPisCofins, FlgNaoICMS: Boolean): Currency;
function CalcCustoTotSemIPI_SUBS(ValCustoEmb, QtdEnt, ValDesc, ValAcresc, ValDespAcess, ValFreteItem: Double; BNaoDescBCST: Boolean): Currency;
function CalcCustoTotSemSUBS(ValCustoEmb, QtdEnt, ValDesc, ValAcresc, ValDespAcess, ValIPIItem, ValFreteItem, ValFreteDest,
                             ValTotalNF: Double; BDevol, RecalcIPI, BNaoDescBCST, BGuia, BRegST: Boolean): Currency;
procedure CalcAliqIcmsRedBCEntrada(var AliqIcmsEnt, PerRedBCEnt: Double; AliqIcmsEnt_NCM, PerRedBCEnt_NCM, AliqIcmsSai, PerRedBCSai,
                                  PerPautaIVA_NCM,ValPautaIVA: Double; TipoTribEnt: SmallInt; FlgVedaCred, FlgRegST, BFornIntrICMS, BFornSimples, Interestadual: Boolean);
function CalcVendaVarejo(PerPautaIVA, PerPautaIVA_NCM, ValPautaIVA, CustoTotEmbSemSUB, QtdTot: Double; BFornPauta: Boolean): Currency;
function CalcValSubstituicao(VdaVarejo, AliqIcmsEnt, PerRedBCEnt, AliqIcmsEnt_NCM, PerRedBCEnt_NCM, AliqIcmsSai, PerRedBCSai,
                             PerPautaIVA_NCM,ValPautaIVA, ValCustoEmbSemIPIeSTeFrete: Double;
                             TipoTribEnt, TipoTribSai: SmallInt; FlgVedaCred, FlgRegST, BFornIntrICMS, BFornSimples, Interestadual: Boolean;
                             FlgNovoCalc : Boolean; TiRet : Integer;
                             var ValSTCRED: Currency): Currency;
function CalcValFCPST(VdaVarejo, AliqIcmsEnt, PerRedBCEnt, AliqIcmsEnt_NCM, PerRedBCEnt_NCM, AliqIcmsSai, PerRedBCSai,
                             PerPautaIVA_NCM,ValPautaIVA, ValCustoEmbSemIPIeSTeFrete: Double;
                             TipoTribEnt, TipoTribSai: SmallInt; FlgVedaCred, FlgRegST, BFornIntrICMS, BFornSimples, Interestadual: Boolean;
                             FlgNovoCalc : Boolean; TiRet : Integer; PerFCPSai, PerFCPENT : Double): Currency;
function CalcVariacaoPesq(ValPesq, ValVenda: Currency): Currency;
function TruncaFrac(Valor: Currency; Casa: SmallInt): Currency;
function TruncaFracDouble(const aValor: Double; const aCasas: SmallInt): Double;
function CalculaICMS(Valor, ICMS, Reducao: Double; TipoTrib: Word; Perc, Trunca:
  Boolean): Currency;
function BaseCalculoReducao(Valor, Reducao: Double): Currency;
function CalculaTabelaLiquido(Tabela:Currency; Val_Desc : Double; Per_Desc,
  Val_Acr, Per_Acr: Currency; Acr_Bruto: string): Double;
function CalculaTabelaFinal(Tabela, TabelaLiq, Val_IPI_Calc: Currency;
  IPI_Bruto: string): Currency;
function CalculaValorIPI(Tabela, Tabela_Liq, Val_IPI, Per_IPI: Currency;
  IPI_Bruto: string): Currency;
function CalculaValor(Valor, val1: Currency; per1: Double): Currency;
function CalculaValorPerc(CValor: Currency; DPerc: Double; BAcresc: Boolean):
  Currency;
function CalcParcLiquido(Parcela, Juros, Devolucao, Desconto, Credito, Retencao, TaxaAdmin, Outros: Currency): Currency;
function CalcPerDescSobreDesc(PDesc1, PDesc2, PDesc3, PDesc4: Double): Currency;
function CalcValTabLiq(VTabela, VDAcess, VDesc, VAcresc, VFrete: Currency): Currency;
function CalcValTabFinal(VTAbela, VTabLiq, VSubst, VIPI: Currency; IPIBr: Boolean): Currency;
function MemSomaValorCurr(Qry: TDataSet; Campo: string): Currency;
procedure RegraImpostoCredito(FlgIdCtbGeraPisCofins, FlgNaoICMS, FlgNaoPISCof, FlgIntICMS, FlgIntPISCof: String;
                              var FlgNaoCredICMS, FlgNaoCredPISCof: String);
procedure CalcItemVVarejo(MTabItens: TDataSet; ColEmb, ColQtd: string;
  BFreteBC: Boolean; VTabLiq, VTabFinal, VTotLiqItens,
  VDAcessRat, VAcrescRat, VDescRat, VFreteRat, VEncFinRat: Currency);
procedure RateiaValItemSubtrai(var ValItem: Currency; BRateia, BRatTotItem:
  Boolean;
  ValRat, ValTotItem: Currency);
procedure RateiaValItemSoma(var ValItem: Currency; BRateia, BRatTotItem:
  Boolean;
  ValRat, ValTotItem: Currency);
function ValRatItemBruto(BRateia: Boolean; ValItem, ValRat, ValTotItem:
  Currency): Double;
function QtdRatItemBruto(BRateia: Boolean; QtdTotItem, QtdItem, ValItem, ValRat,
  ValTotItem: Currency): Currency;
function ValorPorExtenso(Literal: Double): string;
function NumeroPorExtenso(Literal: Integer): string;
function DataPromissoria(Data: TDate): string;
function DataPorExtenso(Data: TDate): string;
function MesPorExtenso(Data: TDate): string; overload;
function MesPorExtenso(aMes: integer): string; overload;
function UltimoDiaMes(Mdt: TDateTime) : TDateTime;
function PrimeiroDiaMes(Data: TDateTime): TDateTime;
function RemoverAcentos(sTexto: string): string;
function RemoverCaracteres(aTexto: string): string;
function CalculaPercentual(Valor, ValPerc: Double): Currency;
function AdicionaPercentual(Valor, ValPerc: Double): Currency;
function CalculaPercentVariacao(aValRef, aValAlt : Double) : Double;
function CalculaDifPercent(aValRef, aValAlt : Double) : Double;
procedure CalculaValoresPisCofins(FlgIgnoraIdCtb, FlgNaoPisCof, NTransfCredForn: String; FlgSTPisCof, FlgIPIPisCof: Boolean; TipoNaoPisCof: Integer;
                              ValTotal, ValIcmsST, ValIPI: Currency; PerPis, PerCofins, ValIcms : Double;
                              var ValBasePis, ValBaseCofins, ValPis, ValCofins, ValIsentoPisCof, ValAliqZero, ValMonofasico, ValSubstituicao,
                                  ValNaoTribut, ValImune, ValSuspensao: Currency );
function PeriodoDataDias(DiaIni,DiaFim:Integer; MesAno,Semanal:String): TStringList;
function RoundTo5(Valor: Double; Casas: Integer): Double;
function RetIsAlphaNumeric(S : String) : Boolean;
function MonthYearOf(aData:TDate):TDate;
{ Rectangle functions from Golden Software }
function rectHeight(const R: TRect): Integer;
function rectWidth(const R: TRect): Integer;
procedure rectGrow(var R: TRect; Delta: Integer);
procedure rectRelativeMove(var R: TRect; DX, DY: Integer);
procedure rectMoveTo(var R: TRect; X, Y: Integer);
function rectSet(Left, Top, Right, Bottom: Integer): TRect;
function rectInclude(const R1, R2: TRect): Boolean;
function rectPoint(const R: TRect; P: TPoint): Boolean;
function rectSetPoint(const TopLeft, BottomRight: TPoint): TRect;
function rectIntersection(const R1, R2: TRect): TRect;
function rectIsIntersection(const R1, R2: TRect): Boolean;
function rectIsValid(const R: TRect): Boolean;
function rectsAreValid(const Arr: array of TRect): Boolean;
function rectNull: TRect;
function rectIsNull(const R: TRect): Boolean;
function rectIsSquare(const R: TRect): Boolean;
function rectCentralPoint(const R: TRect): TPoint;
function rectBounds(aLeft, aTop, aWidth, aHeight: Integer): TRect;
{Inicio Dia Functions}
function iniciaServico(p_maquina, p_servico : string ) : boolean;
{$IFDEF Win32}
{ Variant functions }
function varIIF(aTest: Boolean; TrueValue, FalseValue: Variant): Variant;
procedure varDebug(const V: Variant);
function varToStr(const V: Variant): string;
function iif(Condicao: Boolean; Verdadeiro, Falso: Variant): Variant;
{$ENDIF}

{ date functions }
function dateYear(D: TDateTime): Integer;
function dateMonth(D: TDateTime): Integer;
function dateDay(D: TDateTime): Integer;
function dateBeginOfYear(D: TDateTime): TDateTime;
function dateEndOfYear(D: TDateTime): TDateTime;
function dateBeginOfMonth(D: TDateTime): TDateTime;
function dateEndOfMonth(D: TDateTime): TDateTime;
function dateWeekOfYear(D: TDateTime): Integer;
function dateMonthBetween(DDe, DAte: TDateTime): Integer;

function dateWeekOfMonth(D: TDateTime): Word;

function dateDayOfYear(D: TDateTime): Integer;
function dateDayOfWeek(D: TDateTime): TDayOfWeek;
function dateDayOfMonth(D: TDateTime): Integer;
function dateLeapYear(D: TDateTime): Boolean;
function dateBeginOfQuarter(D: TDateTime): TDateTime;
function dateEndOfQuarter(D: TDateTime): TDateTime;
function dateBeginOfWeek(D: TDateTime; Weekday: Integer): TDateTime;
function dateDaysInMonth(D: TDateTime): Word;
function dateQuicken(D: TDateTime; var Key: Char): TDateTime;
function DiaFixo(DtaEmissao : TDateTime; NumCond, DiaBase : integer): TDateTime;
function DiasEntreDatas(aDtaIni, aDtaFim : TDateTime) : Integer;

function DataSemanaVerbaComprador(DtaMesAno: TDateTime; Semana: Word; Termino:
  Boolean): TDateTime;
function SemanaVerbaComprador(DtaMesAno: TDateTime): Word;

function MesesEntre(const dta1,dta2:TDateTime):integer;

{ time functions }
function timeHour(T: TDateTime): Integer;
function timeMin(T: TDateTime): Integer;
function timeSec(T: TDateTime): Integer;
function timeToInt(T: TDateTime): Integer;

function RetornaDataValida(pData: string):TDate;
function CorrigeDataInvertida(aDta: string): TDate;

{$IFDEF Win32}
//function  timeZoneOffset: Integer;
{$ENDIF}

{ com Functions }
function comIsCis(const S: string): Boolean;
function comIsInt(const S: string): Boolean;
function comCisToInt(const S: string): string;
function comIntToCis(const S: string): string;
function comFaxToCis(const S: string): string;
function comNormFax(const Name, Fax: string): string;
function comNormPhone(const Phone: string): string;
function comNormInt(const Name, Int: string): string;
function comNormCis(const Name, Cis: string): string;

{ funções de validação de documentações}

procedure AtribuiValPropComp(Componente: TComponent; NomComponente, Propriedade: string; Valor: variant);
function ValidaCGC(xCNPJ: string): Boolean;
function ValidaCPF(num: string): Boolean;
function ValidaIEProdutor(const Identificacao, Estado: string): Boolean;
function FormataCGC(const Identificacao: string): string;
function FormataCPF(const Identificacao: string): string;
function DigitoCPF(const Identificacao: string): string;
function FormataRG(const Identificacao: string): string;
function FormataFone(const Identificacao: string): string;
function FormataCel(const Identificacao: string): string;
function FormataSimNao(const Identificacao: string): string;
function InverteSimNao(const Identificacao: string): string;
function FormataCodPLU(const Identificacao: string): string;
function FormataCodBarra(const Identificacao: string): string;
function FormataConta(Banco,DesBanco,Conta: string;CodLj: Integer): string;
function FormataCodFiscalExp(const Identificacao: string): string;
function FormataCodFiscalExpAntiga(const Identificacao: string): string;
function FormataPlanoConta(const Identificacao: string): string;
function FormataCEP(const CEP: string): string;
function FormataCEP2(const CEP: string): string;
function FormataCodSGS(const Secao, Grupo, SubGrupo, Tipo: Integer): string;
function FormataDesSGS(const Secao, Grupo, SubGrupo: string; Tipo: Integer):
  string;
function FormataTipoLoja(Tipo: Word): string;
function FormataEmbalagem(Estoque, QtdEmb: Float; TipoEmbC, TipoEmbV: string;
  Pesavel: Boolean): string;
function FormataTipoMargem(Tipo: Word): string;
function FormataParceiroClassif(Tipo: Word): string;
function FormataParceiro(Tipo: Word): string;
function GetTipoParceiro(aTipo : Integer): string;
function GetTipoConta(aTipo : Integer): string;
function GetImgIndexBco(aCodBco : integer) : Integer;
function FormataFuncaoUsuario(Funcao: Word): string;
function FormataTipoTribut(Tipo: Word): string;
function FormataTipoTributReduzido(Tipo: Word): string;
function FormataTipoNF(Tipo: Word): string;
function FormataTipoOperacao(Tipo: Word): string;
function FormataRecebimento(Tipo: Word): string;
function FormataEntrega(Tipo: Word): string;
function FormataCategoria(Tipo: Word): string;
function FormataSubCategoria(Tipo: Word): string;
function FormataTipoCategoria(Tipo: Word): string;
function FormataTipoFrete(Tipo: Word): string;
function FormataTipoProduto(Tipo: Word): string;
function CurrToStrQualOpcao(Valor1, Valor2: Currency; Qual: Boolean;
  TamEsquerda, TamDireita: SmallInt): string;
function FormataHistorico(DesHistorico, NumDocto, DtaLancto, DesConta, TipoLanc, Parcela, QtdParcela, DtaVencto : string) : string;
function FormataTipoOpEvFin(aTipoOp : Integer) : string;
function SimNao(Verdadeiro: Boolean): char;
function SimNaoBoo(Verdadeiro: Char): Boolean;
function SimNaoBooStr(Verdadeiro: string): Boolean;
//function ConsisteIE(const Insc, UF:String): Boolean;  // Busca de DLL da Fazenda...
function ConsisteIE(IE, UF: string): Boolean;
// Busca da Nova DLL da Fazenda .. 27/02/2003

function FormataCBarraDig(vBarra:string): string;
function DV_Modulo10_Boleto(Str: String): integer;
function CalcDigM10(Campo: String): String;

{ funções de validação de documentações}
function FormatFloatSQL(Value: Extended): string;
function FloatToSQL(Value: Extended): string;
function FloatToSQL3(Value: Extended): string;
function IntegerToSQL(Value: LongInt): string;
function StringToSQLEqual(Value: string): string;
function SimNaoToSQL(Value: Boolean): string;
function ConsisteLoja(Lista: TCheckListBox): Boolean;
function ValidaLojaSelecionada(Lista: TCheckListBox; Loja: Word): Boolean;
function ListaLojaSelecionada(Lista: TCheckListBox): string;
function ListaLojaSelecionadaDelimitador(aLista: TCheckListBox; aDelimitador:String): string;
procedure HabDesabListaLojas(Lista: TCheckListBox; Acao, MLoja: Boolean);
procedure MarcaListaLojaPadrao(Lista: TCheckListBox; Loja: Word);
function NumLojasSelecionadas(Lista: TCheckListBox): Word;
function CombLojasSelecionadas(Lista: TCheckListBox): Word;
function InjetaLojaConcatQryFixa(aAND_WHERE, aParametroMacro, aCampo : String; aQry : TSQLQuery; aSQL : String; aListaLoja : TCheckListBox) : Boolean;
procedure ReplicaMarcaLista(Origem: TCheckListBox; var Destino: TCheckListBox;
  Adiciona: Boolean);

function AddSQLLojasStrings(Lista: TCheckListBox; Tabela: string; Str:
  TStrings): Boolean;
function GetINCodLojasSelecionadas(Lista : TCheckListBox) : string;

function AddSQLLojasX(Lista: TCheckListBox; Tabela: string; Qry: TSQLQuery):Boolean; overload;
function AddSQLLojasX(Lista: TCheckListBox; Tabela: string; Qry: TFDQuery):Boolean; overload;

function AddSQLLojasXName(Lista: TCheckListBox; Tabela: string; Qry: TSQLQuery; NomeCampo : String):
  Boolean;
function GetSQLAddLojaLista(Lista: TCheckListBox; Tabela: string) : string;
function AddSQLColunaX(Lista: TCheckListBox; Tabela, Coluna: string; Qry:
  TSQLQuery): Boolean;
function RemovePontosValor(vValor : String) : String;

procedure AddListaComboBox(CliDS: TClientDataSet; Lista: TCustomComboBox;
  Campos: string);
procedure AddListaComboBoxClassif(CliDS: TClientDataSet; Lista: TCustomComboBox;
  TipoClassif: Integer; Campos: string);
procedure AddListaComboBoxGrupo(CliDS: TClientDataSet; Lista: TCustomComboBox;
  CodSecao: Integer; Campos: string);
procedure AddListaComboBoxSGrupo(CliDS: TClientDataSet; Lista: TCustomComboBox;
  CodSecao, CodGrupo: Integer; Campos: string);

function ValCampoListaComboBox(Texto: string; Delimitador: Char; Posicao: Word):
  string;

function MontaPriory(Value, Campo: string): string;
function StrZeroLeft(Cadeia: string; Tam: word): string;
function StrToVal(Cadeia: string): LongInt;
function EPar(Numero: longInt): Boolean;
function GeraDigitoEAN(Cod: string; Num: word): string;
function ValidaEAN(Cod: string; Num: word; var CodEAN: string): Boolean;
function VerificaEAN(Digito13: Boolean; EAN: string; Foco: TEdit): Boolean;
function VerificaEANBoo(Digito13, BMensag: Boolean; EAN: string): Boolean;
function GeraEANImpressao(Cod: string): string;
function MesProximo(data: TDateTime): TDateTime;
function MesAnterior(data: TDateTime): TDateTime;
function CalcDataFatura(DtaVencto: TDateTime; NumCond, CodCond: Integer; var
  SDtaEmiEnt: string): TDateTime;
function CalcDataPrevPgto(DtaVencto, DtaProrrog, DtaPrograma: TDateTime):
  TDateTime;
function ExisteMTabCodInt(tabela: TClientDataSet; campo: string; cod: integer):
  boolean;overload;
function ExisteCliTabCodInt(tabela: TClientDataSet; campo: string; cod:
  integer): boolean;
procedure MudaTudoEstadoGrid(Grid: TDBGrid; Edicao: Boolean);
procedure MudaEstadoGrid(Grid: TDBGrid; Edicao: Boolean);
procedure MudaEstadoGridTag(Grid: TDBGrid; Edicao: Boolean; WTag: Word);
procedure DisableTaskMgr(bTF: Boolean);
function ConvertStringToPChar(StringValue: string): PChar;
function ConverteStringImpDireta(aText : string) : string;
function StrToPChar(const Str: string): PChar; // Esta mais completa.
procedure SavRestDisplayLabel(var Cliente: TClientDataSet; Acao: Boolean);
procedure AlteraDisplayLabel(var Cliente: TClientDataSet; sField, sLabel:
  string; iWidth: Integer);
procedure AlteraDisplayLabelNovo(var Cliente: TClientDataSet; sField,
  NomeColDisp, NomeColRel: string; iWidth: Integer);
procedure AlteraDisplayLabelNovoFD(var Cliente: TFDQuery; sField,
  NomeColDisp, NomeColRel: string; iWidth: Integer);
procedure CriaTabModDocFiscal(var Tab: TClientDataset; AOwner: TComponent);
function AjudaNumSerie: TForm;
procedure LimpaFilterClient(CliD: TClientDataSet);

(*FUNCOES NOVAS DE BOLETO - LÉO*)
function Modulo10(Valor: string): string;
function Modulo11(Value: string): char;
function chInt ( ch: Char ): ShortInt;
function intCh ( int: ShortInt ): Char;
function ValidaCMC7Leitor(CMC7: string): boolean;
function ConvertLinhaDigCodBarra(aLinhaDig : String) : string;

(*FUNCOES ANTIGAS DE BOLETO - NÃO RECOMENDADAS*)
function ValidaCMC7(CMC7: string): boolean;
function ConvertCodBarraLinhaDig(aCodBarr : String) : string;
function ValidaCMC7_2(CMC7: string): Boolean;
function ValidaCBarraBol(aCodBarra : string): Boolean;
function RetornaCMC7(pBanco, pAgencia, pConta, pNrCheque, pCamaraCompesacao,pTipificacao: string): string;


function RetParteCMC7(CMC7: string; Tipo: Smallint): string;
function GetAgCCSemDig(aAgCC : string) : string;
function ValidaFormatoCC(aCC : string) : Boolean;
function ValidaFormatoAgencia(aAg : string) : Boolean;
function GetDigAgCC(aAgCC : string) : string;
function CalcMod11(Value: string): string;
procedure SavRestDisplayLabelFD(var Cliente: TFDQuery; Acao: Boolean);
procedure AplicaFiltroCli(var Cliente : TClientDataSet; Filtro : string); overload;
// Calculo do Modulo 11 Bradesco com peso 2 a 7
procedure JumpTo(const aAdress: String);
function GetQtdEmail(vEmail : string) : Integer;
function GetDadosEmails(vEmail : string) : TResultArrayStr;
function GetBordValid(aBord : string) : Boolean;
function GetValorValid(aValBol, aValReceb, aValTarifa : Currency; aCodOcorrencia, aCodBco : integer) : Boolean;
function GetTamNossoNumBB(aConv, aCart: string) : Integer;
procedure GravaArqTxt(aDir, aNomeArq, aConteudo : string);
function FormataTipoOferta(aTipoOf: Integer): String;
function RetornaTipoPessoaFisica(const aNumCGC: string): Boolean;
{ file functions }
procedure fileShredder(const Filename: string);
function fileSize(const Filename: string): Longint;
function fileWildcard(const Filename: string): Boolean;
function fileShellOpen(const aFile: string): Boolean;
function fileShellPrint(const aFile: string): Boolean;
function fileCopy(const SourceFile, TargetFile: string): Boolean;
function DeleteFiles(FilePath, FileMask: string): Boolean;
function RenomeiaArquivo(aFileName, aNewFileName : string) : Boolean;

{$IFDEF Win32}
function fileTemp(const aExt: string): string;
function fileExec(const aCmdLine: string; aHide, aWait: Boolean): Boolean;
function fileRedirectExec(const aCmdLine: string; Strings: TStrings): Boolean;
function fileLongName(const aFile: string): string;
function fileShortName(const aFile: string): string;
function fileTypeName(const aFile: string): string;
{$ENDIF}
function ExtractName(const Filename: string): string;
Function fncGetStatusWinService(const sWinService : string; const sComputerName : string = '') : integer;

{ system functions }
function sysTempPath: string;
function FileVerInfo(const Arquivo: string): string;
function GetAdapterStatus: string;
function GetComputerName: string;
function SecondsIdle: DWord; {Saber qto tempo o mouse não foi movido e nem clicado e o teclado não foi usado}
function GetLocalIP : string;
function GetIP : string;

//procedure sysDelay(aMs: Longint);
procedure sysBeep;
function sysColorDepth: Integer; { 06.08.96 sb }
function OS_MaiorQue256Cores: Boolean;
function TempodeDesigner: Boolean;
function MessageDlgDef(const Msg: string; AType: TMsgDlgType; AButtons:
  TMsgDlgButtons;
  DefButton: TModalResult; HelpCtx: LongInt): Word;

{$IFDEF Win32}
procedure sysSaverRunning(Active: Boolean);
function KillTask(ExeFileName: string): Integer;
function MataProcesso(aProcessName : String) : Boolean;
function GetPastaUsuario : string;
function InputComData(var Data: string): Boolean;
function InputComFone(var Fone: string): Boolean;
function InputComCel(var Cel: string): Boolean;
function CheckNT: Boolean;
{$ENDIF}

{ registry functions }

{$IFDEF Win32}
function regReadString(aKey: hKey; const Path: string): string;
procedure regWriteString(aKey: hKey; const Path, Value: string);
procedure regDelValue(aKey: hKey; const Path: string);
function regInfoString(const Value: string): string;
function regCurrentUser: string;
function regCurrentCompany: string;
procedure regWriteShellExt(const aExt, aCmd, aMenu, aExec: string);

{ The following five functions came from David W. Yutzy / Celeste Software Services
  Thanks for submitting us the methods !!
}
procedure regKeyList(aKey: HKEY; const Path: string; var aValue: TStringList);
function regValueExist(aKey: HKEY; const Path: string): Boolean;
function regWriteValue(aKey: HKEY; const Path: string; Value: Variant; Typ:
  TDataType): Boolean;
function regReadValue(aKey: HKEY; const Path: string; Typ: TDataType): Variant;
procedure regValueList(aKey: HKEY; const Path: string; var aValue: TStringList);

//procedure ExecuteShellCommand(cmdline: string; hidden: Boolean);
procedure ExecuteShellCommand2(cmdline: string);
procedure ExecuteShellCommand3(cmdline: string);
Procedure ExecuteProgram(Nome,Parametros:String);
procedure ExecutaeEsperaTerminar(Comando: string);

procedure Delay(dwMilliseconds: Longint);

procedure AlinhaMenuItemDireita(MMenu: TMainMenu; MenuItem: TMenuItem);

function PegaCfgPortaSerial(Porta_Serial: string): string;
function RemoveTitleBar(hWindow: THANDLE; Hide: boolean = True): DWORD;

function SetGlobalEnvironment(const Name, Value: string;
  const User: Boolean = True): Boolean;

function GetEnvVarValue(const VarName: string): string;
function RetornaDiaSemana(Data: TDateTime): String;
function RetornaDiaSemanaExt(Data: TDateTime): String;
function ToUpper(Text: String): String;
function RetornaDV_NFE_Modulo11(Numero: String): String;
function procuraProcesso(val : String) : Boolean;
function GetColorRandom: TColor;
function GetColorIndex(aIdx : Integer): TColor;
function ClearAllDirectory(FullPath: string): Boolean;

procedure CriaCampoFloat(aFieldName, aDisplay : string; aDataSet: TDataSet);
procedure CriaCampoInt(aFieldName : string; aDataSet : TDataSet);
procedure CriaCampoDate(aFieldName : string; aDataSet : TDataSet);
procedure CriaCampoStr(aFieldName : string; aSize : Integer; aDataSet : TDataSet);

procedure DestroyCampo(aDataSet: TDataSet; aFieldName : string);
procedure CriaCampoString(aFieldName, aDisplay : string; aSize: Integer; aDataSet: TDataSet);


procedure TrimAppMemorySize;
function RemoveEnter(aStr : String) : String;
function TrocaVirgPPonto(Valor : String): String;
procedure InicializaObjeto(var AObj);
function ConsisteAliquota(aAliq: Double): Boolean;
function StrReplaceCaracterEspecial(aStr: string): string;
function RetEstagioLote(aTipo: Integer): string;
procedure CompactarArquivo(APathOrig, APathDest: String);
procedure DescompactarArquivo(AZipName: string; ADest: string);
function DifSaldoCtbComparativo(AValorAnt, AValorAtual : Float; ANatCta : String) : Float;
function TrocaCaracterEspecial(const aTexto: string;
  const aLimCaracterExt: boolean): string;
function RetornaSugestaoMultiplaEmbCpra(const aQtdSugestao,
  aEmbCpra: Double): Double;
function RetornaSugestaoCaixa(const aQtdSugestaoUN, aEmbCpra: Double): Double;
function RetornaTipoVendaImpressaoEtiqueta(const aOpcao: string): Integer;
function RetornaTipoOpcaoCSSomenteImpressaoEtiqueta(const aOpcao: string): Integer;
function RetornaTipoOpcaoEtiquetasImpressas(const aOpcao: string): Integer;
function RetornaEmbCpraXPrecoPDV(const aEmbCpra, aEmbVda, aQtdAtacado, aValVenda,
  aValVendaAtacado: Currency): string;
function TrocarCaracterEspecialReduzida(const aTexto: string;
  const aLimCaracterExt: boolean): string;
function RetornaEntidadeInstabuy(const aFormaPagamento: string): string;
function CalcCustoCImposto(const aFlgNaoPISCofins: string; const aValCustoRep, aValVenda,
  aValOferta, aPerICMSSaida, aPerICMSEntrada, aPerPis, aPerCofins: Currency): Currency;
function RetornaTipoNaoIncidente(const aTipo: integer): string;
function ValidarQtdMaximaColetadaInventario(const aQtdMaxima,
  aQtdColetada: Double): Boolean;


{$ENDIF}


{procedimentos auxiliares no controle das transações}

procedure DefineTransacao(var {$IFNDEF VER150} TransDesc:TDBXTransaction
                         {$ELSE} TransDesc: TTransactionDesc {$ENDIF}; ID: Word);

procedure IniciarTransacao(const AConexao:TSQLConnection;var
         {$IFNDEF VER150}ATransa:TDBXTransaction
         {$ELSE}ADescri: TTransactionDesc {$ENDIF}); overload;

procedure CommitTransacao(const AConexao:TSQLConnection;var
         {$IFNDEF VER150}ATransa:TDBXTransaction
         {$ELSE}ADescri: TTransactionDesc{$ENDIF}); overload;

procedure RollBackTransacao(const AConexao:TSQLConnection;var
         {$IFNDEF VER150}ATransa:TDBXTransaction
         {$ELSE}ADescri: TTransactionDesc{$ENDIF}); overload;

procedure RollBackTransacaoIncompleta(const AConexao:TSQLConnection;var
         {$IFNDEF VER150}ATransa:TDBXTransaction
         {$ELSE}ADescri: TTransactionDesc{$ENDIF});

procedure IniciarTransacao(const AConexao:TFDConnection); overload;

procedure CommitTransacao(const AConexao:TFDConnection); overload;

procedure RollBackTransacao(const AConexao:TFDConnection); overload;

procedure AlimentaFDClient(var aClient:TClientDataSet; var aFDQry:TFDQuery);


{ several functions }
//function  Question(const Msg: String):Boolean;
//procedure Information(const Msg: String);
//function  Confirmation(const Msg: String): Word;

type
  { TRect that can be used persistent as property for components }
  TUnitConvertEvent = function(Sender: TObject;
    Value: Integer; Get: Boolean): Integer of object;
  TPersistentRect = class(TPersistent)
  private
    FRect: TRect;
    FOnConvert: TUnitConvertEvent;
    procedure SetLeft(Value: Integer);
    procedure SetTop(Value: Integer);
    procedure SetHeight(Value: Integer);
    procedure SetWidth(Value: Integer);
    function GetLeft: Integer;
    function GetTop: Integer;
    function GetHeight: Integer;
    function GetWidth: Integer;
  public
    constructor Create;
    procedure Assign(Source: TPersistent); override;
    property Rect: TRect read FRect;
    property OnConvert: TUnitConvertEvent read FOnConvert write FOnConvert;
  published
    property Left: Integer read GetLeft write SetLeft;
    property Top: Integer read GetTop write SetTop;
    property Height: Integer read GetHeight write SetHeight;
    property Width: Integer read GetWidth write SetWidth;
  end;

{$IFDEF Win32}
  { Persistent access of components from the registry }
  TPersistentRegistry = class(TRegistry)
  public
    function ReadComponent(const Name: string; Owner, Parent: TComponent):
      TComponent;
    procedure WriteComponent(const Name: string; Component: TComponent);
  end;
{$ENDIF}

  { easy access of the system metrics }
  TSystemMetric = class
  private
    FColorDepth,
      FMenuHeight,
      FCaptionHeight: Integer;
    FBorder,
      FFrame,
      FDlgFrame,
      FBitmap,
      FHScroll,
      FVScroll,
      FThumb,
      FFullScreen,
      FMin,
      FMinTrack,
      FCursor,
      FIcon,
      FDoubleClick,
      FIconSpacing: TPoint;
  protected
    constructor Create;
    procedure Update;
  public
    property MenuHeight: Integer read FMenuHeight;
    property CaptionHeight: Integer read FCaptionHeight;
    property Border: TPoint read FBorder;
    property Frame: TPoint read FFrame;
    property DlgFrame: TPoint read FDlgFrame;
    property Bitmap: TPoint read FBitmap;
    property HScroll: TPoint read FHScroll;
    property VScroll: TPoint read FVScroll;
    property Thumb: TPoint read FThumb;
    property FullScreen: TPoint read FFullScreen;
    property Min: TPoint read FMin;
    property MinTrack: TPoint read FMinTrack;
    property Cursor: TPoint read FCursor;
    property Icon: TPoint read FIcon;
    property DoubleClick: TPoint read FDoubleClick;
    property IconSpacing: TPoint read FIconSpacing;
    property ColorDepth: Integer read FColorDepth;
  end;

var
  SysMetric: TSystemMetric;
  (*  X, Y: integer; CountRun: word;  *)

  SalvaDisplayLabel, SalvaDisplayWidth : TStrings;

type
  TDesktopCanvas = class(TCanvas)
  private
    DC: hDC;
  public
    constructor Create;
    destructor Destroy; override;
  end;

implementation

uses
  SysUtils, {Forms,} Consts, Math,
    StrUtils;

 var
   gNovoIDTransa: word = 0;

procedure DefineTransacao(var{$IFNDEF VER150} TransDesc:TDBXTransaction
                          {$ELSE} TransDesc: TTransactionDesc{$ENDIF}; ID: Word );
begin
  {$IFDEF VER150}
    TransDesc.TransactionID := ID;
    TransDesc.IsolationLevel := xilREADCOMMITTED;
  {$ENDIF}
end;

procedure IniciarTransacao(const AConexao:TFDConnection);
begin
  AConexao.StartTransaction;
end;

procedure CommitTransacao(const AConexao:TFDConnection);
begin
  AConexao.Commit;
end;

procedure RollBackTransacao(const AConexao:TFDConnection);
begin
  AConexao.Rollback;
end;

procedure IniciarTransacao(const AConexao:TSQLConnection;var
         {$IFNDEF VER150}ATransa:TDBXTransaction
         {$ELSE}ADescri: TTransactionDesc {$ENDIF});
begin
  {$IFNDEF VER150}
	ATransa := AConexao.BeginTransaction(TDBXIsolations.ReadCommitted);
  {$ELSE}
  DefineTransacao(ADescri, GeraProximoIDTransa);
  AConexao.StartTransaction(ADescri);
 {$ENDIF}
end;

procedure CommitTransacao(const AConexao:TSQLConnection;var
         {$IFNDEF VER150}ATransa:TDBXTransaction
         {$ELSE}ADescri: TTransactionDesc{$ENDIF});
begin
  {$IFNDEF VER150}
	AConexao.CommitFreeAndNil(ATransa);
	{$ELSE}
  AConexao.Commit(ADescri);
  {$ENDIF}
end;

procedure RollBackTransacao(const AConexao:TSQLConnection;var 
         {$IFNDEF VER150}ATransa:TDBXTransaction
         {$ELSE}ADescri: TTransactionDesc{$ENDIF});
begin
  if AConexao.Intransaction then
	  {$IFNDEF VER150}
	  //assegura a consistência dos dados, mas se ATransa for nil levanta uma exceção
	   AConexao.RollbackFreeAndNil(ATransa);
	  {$ELSE}
     AConexao.Rollback(ADescri);
	  {$ENDIF}
end;


procedure RollBackTransacaoIncompleta(const AConexao:TSQLConnection;var 
         {$IFNDEF VER150}ATransa:TDBXTransaction
         {$ELSE}ADescri: TTransactionDesc{$ENDIF});
begin
  {$IFNDEF VER150} 
	//assegura a consistência dos dados, se ATransa for nil não levanta exceção.
  AConexao.RollbackIncompleteFreeAndNil(ATransa);
 {$ENDIF}
end;


procedure AlteraDisplayLabel(var Cliente: TClientDataSet; sField, sLabel:
  string; iWidth: Integer);
begin
  if Cliente.FindField(SField) = nil then
    exit;
  Cliente.FieldByName(SField).ConstraintErrorMessage := sLabel;
  Cliente.FieldByName(SField).DisplayLabel := sLabel;
  Cliente.FieldByName(SField).DisplayWidth := iWidth;
end;

procedure AlteraDisplayLabelNovo(var Cliente: TClientDataSet; sField,
  NomeColDisp, NomeColRel: string; iWidth: Integer);
begin
  {if Pos('_',NomeColDisp) > 0 then
    Exit;}
  if Cliente.FindField(SField) = nil then
    exit;
  Cliente.FieldByName(SField).ConstraintErrorMessage := NomeColDisp;
  Cliente.FieldByName(SField).DisplayLabel := NomeColRel;
  Cliente.FieldByName(SField).DisplayWidth := iWidth;
end;

procedure AlteraDisplayLabelNovoFD(var Cliente: TFDQuery; sField,
  NomeColDisp, NomeColRel: string; iWidth: Integer);
begin
  if Cliente.FindField(SField) = nil then
    Exit;

  Cliente.FieldByName(SField).ConstraintErrorMessage := NomeColDisp;
  Cliente.FieldByName(SField).DisplayLabel := NomeColRel;
  Cliente.FieldByName(SField).DisplayWidth := iWidth;
end;

procedure AplicaFiltroCli(var Cliente : TClientDataSet; Filtro : string);
begin
  with Cliente do
  begin
    Filtered := False;
    Filter   := Filtro;
    Filtered := True;
  end;
end;

procedure JumpTo(const aAdress: String);
var
  buffer: String;
begin
  buffer := 'http://' + aAdress;
  ShellExecute(Application.Handle, nil, PChar(buffer), nil, nil, SW_SHOWNORMAL);
end;

procedure SavRestDisplayLabel(var Cliente: TClientDataSet; Acao: Boolean);
var
  i: Integer;
begin
  if Acao then
  begin
    SalvaDisplayLabel := TStringList.Create;
    SalvaDisplayWidth := TStringList.Create;
    for i := 0 to Cliente.FieldCount - 1 do
    begin
      SalvaDisplayLabel.add(Cliente.Fields[i].DisplayLabel);
      SalvaDisplayWidth.add(IntToStr(Cliente.Fields[i].DisplayWidth));
    end;
  end
  else
  begin
    for i := 0 to Cliente.FieldCount - 1 do
    begin
      Cliente.Fields[i].DisplayLabel := SalvaDisplayLabel.Strings[i];
      Cliente.Fields[i].DisplayWidth := StrToInt(SalvaDisplayWidth.Strings[i]);
    end;
    SalvaDisplayLabel.Free;
    SalvaDisplayWidth.Free;
  end;
end;

procedure LimpaFilterClient(CliD: TClientDataSet);
begin
  CliD.IndexName := '';
  CliD.IndexFieldNames := '';
  CliD.IndexDefs.Update;
end;

procedure SavRestDisplayLabelFD(var Cliente: TFDQuery; Acao: Boolean);
var
  i: Integer;
begin
  if Acao then
  begin
    SalvaDisplayLabel := TStringList.Create;
    SalvaDisplayWidth := TStringList.Create;
    for i := 0 to Cliente.FieldCount - 1 do
    begin
      SalvaDisplayLabel.add(Cliente.Fields[i].DisplayLabel);
      SalvaDisplayWidth.add(IntToStr(Cliente.Fields[i].DisplayWidth));
    end;
  end
  else
  begin
    for i := 0 to Cliente.FieldCount - 1 do
    begin
      Cliente.Fields[i].DisplayLabel := SalvaDisplayLabel.Strings[i];
      Cliente.Fields[i].DisplayWidth := StrToInt(SalvaDisplayWidth.Strings[i]);
    end;
    SalvaDisplayLabel.Free;
    SalvaDisplayWidth.Free;
  end;
end;

function SoNumero(Texto: string): string;
var
  Ind, inum: Integer;
  TmpRet, TesteTxt: string;
  numero: array[0..9] of string;
begin
  for inum := 0 to 9 do
    numero[inum] := IntToStr(inum);

  TmpRet := '';
  for Ind := 1 to Length(Texto) do
  begin
    TesteTxt := Copy(Texto, Ind, 1);
    for inum := 0 to 9 do
    begin
      if TESTETXT = numero[inum] then
        //if  IsDigit(Copy(Texto,Ind,1)) then
      begin
        TmpRet := TmpRet + Copy(Texto, Ind, 1);
      end;
    end;
  end;
  Result := TmpRet;
end;

function IniciaisMaiusculas(Texto : String) : string;
var
 i:integer;
 LowerText: string;
 NoUpText: string;
begin
  LowerText := AnsiLowerCase( Texto );

  for i := 1 to Length( LowerText ) do
  begin
   if i = 1 then
    LowerText[ i ] := UpCase( LowerText[i] );

    if (LowerText[ i ]=' ') then
    begin
     NoUpText := Copy( LowerText,Succ(i),3 );

    if Length( Trim(NoUpText) ) > 2 then
      LowerText[ Succ(i) ] := UpCase( LowerText[Succ(i)] );

    end;
  end;
  result:= LowerText;
end;

function StrNumberOnly(Texto : string): Boolean;
var
  i : Integer;
begin
  Result := True;
  for i := 1 to Length(Texto) do
  begin
    if not(Texto[i] in ['0'..'9']) then
    begin
      Result := False;
      Exit;
    end;
  end;
end;

procedure LimpaParamSQLQry(var Qry: TFDQuery);
begin
  Qry.Close;
  Qry.SQL.Clear;
  Qry.Params.Clear;
end;

procedure LimpaSQLQry(var Qry: TSQLQuery);overload;
begin
  FreeAndNil(Qry);
end;

procedure LimpaSQLQry(var Qry: TFDQuery);overload;
begin
  FreeAndNil(Qry);
end;

procedure CriaSQLQry(var Qry: TSQLQuery); overload;
begin
  LimpaSQLQry(Qry);
  Qry := TSQLQuery.Create(nil);
end;

procedure CriaSQLQry(var Qry: TFDQuery); overload;
begin
  LimpaSQLQry(Qry);
  Qry := TFDQuery.Create(nil);
end;

procedure RecriaSQLQry(var Qry: TSQLQuery);
begin
  CriaSQLQry(Qry);
end;

procedure LimpaParamCliQry(var Qry: TSQLQuery; var Cli: TClientDataSet);
begin
  Cli.Close;
  Qry.SQL.Clear;
  Cli.Params.Clear;
end;

// Esta função serve para adaptar a estrutura interna das chamadas de Procedures
// de bancos Interbase, SQLServer e Oracle.




function EliminaNumeros(Campo: string): String;
begin
  Campo := DelChars(Campo, '0');
  Campo := DelChars(Campo, '1');
  Campo := DelChars(Campo, '2');
  Campo := DelChars(Campo, '3');
  Campo := DelChars(Campo, '4');
  Campo := DelChars(Campo, '5');
  Campo := DelChars(Campo, '6');
  Campo := DelChars(Campo, '7');
  Campo := DelChars(Campo, '8');
  Campo := DelChars(Campo, '9');
end;

function EliminaLetras(Campo: string): String;
begin
  Campo := DelChars(Campo, 'A');
  Campo := DelChars(Campo, 'B');
  Campo := DelChars(Campo, 'C');
  Campo := DelChars(Campo, 'D');
  Campo := DelChars(Campo, 'E');
  Campo := DelChars(Campo, 'F');
  Campo := DelChars(Campo, 'G');
  Campo := DelChars(Campo, 'H');
  Campo := DelChars(Campo, 'I');
  Campo := DelChars(Campo, 'J');
  Campo := DelChars(Campo, 'K');
  Campo := DelChars(Campo, 'L');
  Campo := DelChars(Campo, 'M');
  Campo := DelChars(Campo, 'N');
  Campo := DelChars(Campo, 'O');
  Campo := DelChars(Campo, 'P');
  Campo := DelChars(Campo, 'Q');
  Campo := DelChars(Campo, 'R');
  Campo := DelChars(Campo, 'S');
  Campo := DelChars(Campo, 'T');
  Campo := DelChars(Campo, 'U');
  Campo := DelChars(Campo, 'V');
  Campo := DelChars(Campo, 'X');
  Campo := DelChars(Campo, 'Y');
  Campo := DelChars(Campo, 'W');
  Campo := DelChars(Campo, 'Z');
  Campo := DelChars(Campo, 'a');
  Campo := DelChars(Campo, 'b');
  Campo := DelChars(Campo, 'c');
  Campo := DelChars(Campo, 'd');
  Campo := DelChars(Campo, 'e');
  Campo := DelChars(Campo, 'f');
  Campo := DelChars(Campo, 'g');
  Campo := DelChars(Campo, 'h');
  Campo := DelChars(Campo, 'i');
  Campo := DelChars(Campo, 'j');
  Campo := DelChars(Campo, 'k');
  Campo := DelChars(Campo, 'l');
  Campo := DelChars(Campo, 'm');
  Campo := DelChars(Campo, 'n');
  Campo := DelChars(Campo, 'o');
  Campo := DelChars(Campo, 'p');
  Campo := DelChars(Campo, 'q');
  Campo := DelChars(Campo, 'r');
  Campo := DelChars(Campo, 's');
  Campo := DelChars(Campo, 't');
  Campo := DelChars(Campo, 'u');
  Campo := DelChars(Campo, 'v');
  Campo := DelChars(Campo, 'x');
  Campo := DelChars(Campo, 'y');
  Campo := DelChars(Campo, 'w');
  Campo := DelChars(Campo, 'z');
  Result := Campo;
end;

function RplcVirgPto(vValor: String): String;
var i : integer;
begin
  if vValor <> EmptyStr then begin
    for I := 0 to length(vValor) do begin
      if vValor[i] = ',' then
        vValor[i] := '.';
    end;
  end;
  Result := vValor;
end;

function LRPad(Str: String; Size: integer; Pad,
  LorR: char): string;
var
  i, cont : integer;
  s : string;
begin
  cont := Length(Str);
  s := '';
  if upCase(LorR) = 'L' then
  begin
    ; for i:=1 to Size - cont do
    s := s + Pad;
    s := s + Str;
  end else begin
    for i:=1 to Size - cont do
    s := s + Pad;
    s := Str + s;
  end;
  LRPad := copy(s,1,size);
end;

function ExisteCaractere(Str, Caract : String) : Boolean;
var i : integer;
begin
  Result := False;
  for i := 1 to Length(Str) do
    if (Str[i] = Caract) then
      Result := True;
      
end;

procedure AtribuiValPropComp(Componente: TComponent; NomComponente, Propriedade: string; Valor: variant);
var
  PropInfo: PPropInfo;
begin
  PropInfo := GetPropInfo(Componente.ClassInfo, NomComponente);
  if PropInfo <> nil then
    if Componente.Name = NomComponente then
      SetPropValue(Componente, Propriedade, Valor);
end;

{Consiste CGC}

function ValidaCGC(xCNPJ: string): Boolean;
var
  d1, d4, xx, nCount, fator,
    resto, digito1, digito2: Integer;
  Check: string;
begin
  d1 := 0;
  d4 := 0;
  xx := 1;
  for nCount := 1 to Length(xCNPJ) - 2 do
  begin
    if Pos(Copy(xCNPJ, nCount, 1), '/-.') = 0 then
    begin
      if xx < 5 then
      begin
        fator := 6 - xx;
      end
      else
      begin
        fator := 14 - xx;
      end;
      d1 := d1 + StrToInt(Copy(xCNPJ, nCount, 1)) * fator;
      if xx < 6 then
      begin
        fator := 7 - xx;
      end
      else
      begin
        fator := 15 - xx;
      end;
      d4 := d4 + StrToInt(Copy(xCNPJ, nCount, 1)) * fator;
      xx := xx + 1;
    end;
  end;
  resto := (d1 mod 11);
  if resto < 2 then
  begin
    digito1 := 0;
  end
  else
  begin
    digito1 := 11 - resto;
  end;
  d4 := d4 + 2 * digito1;
  resto := (d4 mod 11);
  if resto < 2 then
  begin
    digito2 := 0;
  end
  else
  begin
    digito2 := 11 - resto;
  end;
  Check := IntToStr(Digito1) + IntToStr(Digito2);
  if Check <> copy(xCNPJ, succ(length(xCNPJ) - 2), 2) then
  begin
    Result := False;
  end
  else
  begin
    Result := True;
  end;
end;

function ValidaIEProdutor(const Identificacao, Estado: string): Boolean;
var
  Wpeso, digito: string;
  i, val1, val2, soma, resto: Integer;
begin
  Result := False;
  Wpeso := '0103040506070810';
  soma := 0;
  if Length(Identificacao) <> 13 then
    Exit;
  if Estado <> 'SP' then
    Exit;
  if (Copy(Identificacao, 1, 1) <> 'P') then
    Exit;
  for i := 1 to 8 do
  begin
    val1 := StrToInt(Copy(Identificacao, (i + 1), 1));
    val2 := StrToInt(Copy(Wpeso, ((i * 2) - 1), 2));
    soma := soma + (val1 * val2);
  end;
  resto := (soma mod 11);
  digito := strPadZeroL(IntToStr(resto), 2);
  digito := Copy(digito, 2, 1);
  if (digito = Copy(Identificacao, 10, 1)) then
    Result := True;
end;


{Consiste CPF}

function ValidaCPF(num: string): Boolean;
var
  n1, n2, n3, n4, n5, n6, n7, n8, n9: integer;
  d1, d2: integer;
  digitado, calculado: string;
begin
  try
    if Length(num) > 11 then
    begin
      Result := False;
      Exit;
    end;

    n1 := StrToInt(num[1]);
    n2 := StrToInt(num[2]);
    n3 := StrToInt(num[3]);
    n4 := StrToInt(num[4]);
    n5 := StrToInt(num[5]);
    n6 := StrToInt(num[6]);
    n7 := StrToInt(num[7]);
    n8 := StrToInt(num[8]);
    n9 := StrToInt(num[9]);
    d1 := n9 * 2 + n8 * 3 + n7 * 4 + n6 * 5 + n5 * 6 + n4 * 7 + n3 * 8 + n2 * 9
      + n1 * 10;
    d1 := 11 - (d1 mod 11);
    if d1 >= 10 then
      d1 := 0;
    d2 := d1 * 2 + n9 * 3 + n8 * 4 + n7 * 5 + n6 * 6 + n5 * 7 + n4 * 8 + n3 * 9
      + n2 * 10 + n1 * 11;
    d2 := 11 - (d2 mod 11);
    if d2 >= 10 then
      d2 := 0;
    calculado := inttostr(d1) + inttostr(d2);
    digitado := num[10] + num[11];
    if calculado = digitado then
      Result := True
    else
      Result := False;
  except
    Result := False;
  end;
end;

function FormataCGC(const Identificacao: string): string;
begin
  if Trim(Identificacao) <> '' then
  begin
    if Length(Identificacao) <= 11 then
      Result := FormatMaskText('999.999.999-99;0;*',
        strPadL(Trim(Identificacao), 11))
    else
      Result := FormatMaskText('99.999.999/9999-99;0;*',
        strPadL(Trim(Identificacao), 13))
  end
  else
    Result := '';
end;

function FormataCPF(const Identificacao: string): string;
begin
  if (Trim(Identificacao) <> '') and (Length(Identificacao) > 7) then
    Result := FormatMaskText('999.999.999-99;0;*', strPadL(Trim(Identificacao),
      11))
  else
    Result := '';
end;

function DigitoCPF(const Identificacao: string): string;
var
  i, code: Integer;
  d2: array[1..12] of Integer;
  DF4, DF5, DF6, RESTO1, Pridig, Segdig: Integer;
  Pridig2, Segdig2: string;
  Texto: string;
begin
  Texto := '';
  Texto := Copy(Identificacao, 1, 3);
  Texto := Texto + Copy(Identificacao, 4, 3);
  Texto := Texto + Copy(Identificacao, 7, 3);
  Texto := Texto + Copy(Identificacao, 10, 2);
  for i := 1 to 9 do
    Val(texto[i], D2[i], Code);
  DF4 := 0;
  for i := 1 to 9 do
    DF4 := DF4 + (D2[i] * (11 - I));
  { DF4 := 10 * D2[1] + 9 * D2[2] + 8 * D2[3] + 7 * D2[4] + 6 * D2[5] + 5 * D2[6] + 4 * D2[7] +3 * D2[8] + 2 * D2[9];}
  DF5 := DF4 div 11;
  DF6 := DF5 * 11;
  Resto1 := DF4 - DF6;
  if (Resto1 = 0) or (Resto1 = 1) then
    Pridig := 0
  else
    Pridig := 11 - Resto1;
  for i := 1 to 9 do
    Val(Texto[i], D2[i], Code);
  DF4 := 11 * D2[1] +
    10 * D2[2] +
    9 * D2[3] +
    8 * D2[4] +
    7 * D2[5] +
    6 * D2[6] +
    5 * D2[7] +
    4 * D2[8] +
    3 * D2[9] +
    2 * Pridig;
  DF5 := DF4 div 11;
  DF6 := DF5 * 11;
  Resto1 := DF4 - DF6;
  if (Resto1 = 0) or (Resto1 = 1) then
    Segdig := 0
  else
    Segdig := 11 - Resto1;
  Str(Pridig, Pridig2);
  Str(Segdig, Segdig2);
  Result := Pridig2 + SegDig2;
end;

function FormataRG(const Identificacao: string): string;
begin
  if Trim(Identificacao) <> '' then
    Result := FormatMaskText('99.999.999-99;0;*', strPadL(Trim(Identificacao),
      10))
  else
    Result := '';
end;

function FormataFone(const Identificacao: string): string;
begin
  if Trim(Identificacao) <> '' then
    Result := FormatMaskText('(9XX99)9999-9999;0;*',
      strPadL(Trim(Identificacao), 11))
  else
    Result := '';
end;

function FormataCel(const Identificacao: string): string;
begin
  if Trim(Identificacao) <> '' then
    Result := FormatMaskText('(9XX99)99999-9999;0;*',
      strPadL(Trim(Identificacao), 12))
  else
    Result := ''
end;

function FormataSimNao(const Identificacao: string): string;
begin
  if (Identificacao = '') or (Identificacao = null) then
  begin
    Result := '';
    Exit;
  end;
  if (Identificacao = 'S') or (Identificacao = 'True') then
    Result := 'Sim'
  else
    Result := 'Não';
end;

function InverteSimNao(const Identificacao: string): string;
begin
  if Identificacao = 'S' then
    Result := 'N'
  else
    Result := 'S';
end;

function FormataCodPLU(const Identificacao: string): string;
begin
  if Trim(Identificacao) <> '' then
    Result := FormatMaskText('9999999-9;0;*', Trim(Identificacao))
  else
    Result := '';
end;

function FormataCodBarra(const Identificacao: string): string;
begin
  if (Trim(Identificacao) <> '') and (Length(Trim(Identificacao)) < 14) then
    Result := FormatMaskText('999999999999-9;0;*', Trim(Identificacao))
  else if (Length(Trim(Identificacao)) = 14)  then
    Result := Identificacao
  else
    Result := '';
end;



function FormataConta(Banco,DesBanco,Conta: string;CodLj: Integer): string;
begin
  Result := StrPadZeroL(Banco, 3) + '  '+ DesBanco + '  ' + Conta + ' Loja: '
            + IntToStr(CodLj) ;
end;



function FormataCodFiscalExp(const Identificacao: string): string;
begin
  if Trim(Identificacao) <> '' then
  begin
    Result := FormatMaskText('99999;0;*', Trim(Identificacao));
  end
  else
    Result := '';
  Result := strPadR(Copy(Result, 1, 5), 5);
end;

function FormataCodFiscalExpAntiga(const Identificacao: string): string;
begin
  if Trim(Identificacao) <> '' then
  begin
    if Length(Trim(Identificacao)) > 3 then
      Result := FormatMaskText('999.9;0;*', Trim(Identificacao))
    else
      Result := FormatMaskText('99999;0;*', Trim(Identificacao));
  end
  else
    Result := '';
  Result := strPadR(Copy(Result, 1, 5), 5);
end;

function FormataPlanoConta(const Identificacao: string): string;
begin
  if Trim(Identificacao) <> '' then
    Result := FormatMaskText('999.999;0;*', Trim(Identificacao))
  else
    Result := '';
end;

function FormataCEP(const CEP: string): string;
var
  I: integer;
begin
  Result := '';
  for I := 1 to Length(CEP) do
    if CEP[I] in ['0'..'9'] then
      Result := Result + CEP[I];
  if Length(Result) = 8 then
    Result :=
      Copy(Result, 1, 2) + '.' +
      Copy(Result, 3, 3) + '-' +
      Copy(Result, 6, 3);
end;

function FormataCEP2(const CEP: string): string;
var
  I: integer;
begin
  Result := '';
  for I := 1 to Length(CEP) do
    if CEP[I] in ['0'..'9'] then
      Result := Result + CEP[I];
  if Length(Result) = 8 then
    Result :=
      Copy(Result, 1, 5) + '-' +
      Copy(Result, 6, 3);
end;

function FormataCodSGS(const Secao, Grupo, SubGrupo, Tipo: Integer): string;
begin
  case Tipo of
    0: Result := '[' + strPadZeroL(IntToStr(Secao), 2) + ']';
    1: Result := '[' + strPadZeroL(IntToStr(Secao), 2) +
      '/' + strPadZeroL(IntToStr(Grupo), 3) + ']';
    2: Result := '[' + strPadZeroL(IntToStr(Secao), 2) +
      '/' + strPadZeroL(IntToStr(Grupo), 3) +
        '/' + strPadZeroL(IntToStr(SubGrupo), 3) +
        ']';
  end;
end;

function FormataDesSGS(const Secao, Grupo, SubGrupo: string; Tipo: Integer):
  string;
begin
  case Tipo of
    0: Result := Secao;
    1: Result := Secao + '/' + Grupo;
    2: Result := Secao + '/' + Grupo + '/' + SubGrupo;
  end;
end;

function FormataTipoLoja(Tipo: Word): string;
begin
  case Tipo of
    0: Result := 'CD';
    1: Result := 'Loja';
    2: Result := 'Depósito';
    3: Result := 'e-commerce';
    4: Result := 'Transp.';
  end;
end;

function FormataEmbalagem(Estoque, QtdEmb: Float; TipoEmbC, TipoEmbV: string;
  Pesavel: Boolean): string;
var
  Rest, DefineEmb: Double;
  FormataDecimo: string;
  EstoqCx, EstoqUn: Integer;
begin
  Result := '';
  if QtdEmb <= 0.00 then
    Exit;
  if not Pesavel then
  begin
    EstoqCx := Trunc(Estoque / QtdEmb);
    Rest := Frac(Estoque / QtdEmb);
    FormataDecimo := FormatFloat('##0.00', Rest);
    DefineEmb := StrToFloat(FormataDecimo) * QtdEmb;
    EstoqUn := Round(DefineEmb);
    if EstoqCx <> 0 then
      Result := IntToStr(EstoqCx) + ' ' + TipoEmbC;
    if (EstoqCx <> 0) and (EstoqUn <> 0) then
      Result := Result + ' ';
    if EstoqUn <> 0 then
      Result := Result + IntTostr(EstoqUn) + ' ' + TipoEmbV;
  end
  else
  begin
    EstoqCx := Trunc(Estoque / QtdEmb);
    EstoqUn := Trunc(Frac(Estoque / QtdEmb) * 1000);
    if EstoqCx <> 0 then
      Result := IntToStr(EstoqCx) + ' ' + TipoEmbC;
    if (EstoqCx <> 0) and (EstoqUn <> 0) then
      Result := Result + ' ';
    if EstoqUn <> 0 then
      if (TipoEmbV = 'KG') then
        Result := Result + IntTostr(EstoqUn) + ' GR'
      else
        Result := Result + IntTostr(EstoqUn) + ' ' + TipoEmbV;
  end;
end;

function FormataTipoMargem(Tipo: Word): string;
begin
  case Tipo of
    0: Result := 'Mark-up';
    1: Result := 'Margem Lucro';
    2: Result := 'Mark-Down'; // Antigo B. PMZ!!!
    3: Result := 'Mg.Contribuição';
    4: Result := 'Markup c/Dif.ICMS';
  else
    Result := 'Personalizada';
  end;
end;

function FormataTipoProduto(Tipo: Word): string;
begin
  case Tipo of
    0: Result := 'Margem';
    1: Result := 'Pesquisa';
    2: Result := 'Tabela';
    3: Result := 'Controle';
  end;
end;

function FormataParceiroClassif(Tipo: Word): string;
begin
  case Tipo of
    0: Result := 'Clientes (PJ)';
    1: Result := 'Clientes (PF)';
    2: Result := 'Fornecedores';
    3: Result := 'Seguradora';
    4: Result := 'Vendedores';
    5: Result := 'Transportadoras';
  else
    Result := 'Todas';
  end;
end;

function FormataParceiro(Tipo: Word): string;
begin
  case Tipo of
    0: Result := 'Clientes';
    1: Result := 'Fornecedores';
    2: Result := 'Transportadoras';
    3: Result := 'Lojas';
    4: Result := 'Cartão';
    5: Result := 'Banco';
  else
    Result := 'Todas';
  end;
end;

function GetTipoParceiro(aTipo : Integer): string;
begin
  case aTipo of
    0: Result := 'Cliente';
    1: Result := 'Fornecedor';
    2: Result := 'Transportadora';
    3: Result := 'Loja';
    4: Result := 'Cartão';
    5: Result := 'Banco';
  else
    Result := 'Todos';
  end;
end;


function GetTipoConta(aTipo : Integer): string;
begin
  case aTipo of
    0: Result := 'Pagar';
    1: Result := 'Receber';
  end;
end;

function GetImgIndexBco(aCodBco : integer) : Integer;
begin
  Case aCodBco of
    1   : Result := 0; {BB}
    33  : Result := 1; {Santande}
    104 : Result := 2; {CAIXA}
    237 : Result := 3; {Bradesco}
    341 : Result := 4; {Itaú}
    399 : Result := 5; {HSBC}
    756 : Result := 6; {Sicoob}
    422 : Result := 7; {Safra}
    356 : Result := 8; {Real}
    246 : Result := 10; {ABC}
  else
          Result := 9;
  end;
end;

function FormataFuncaoUsuario(Funcao: Word): string;
begin
  case Funcao of
    0: Result := 'Digitador';
    1: Result := 'Comprador';
    2: Result := 'Vendedor';
    3: Result := 'Supervisor';
    4: Result := 'Gerente';
    5: Result := 'Diretor';
  end;
end;

function FormataTipoTribut(Tipo: Word): string;
begin
  case Tipo of
    0: Result := 'Tributado';
    1: Result := 'Isento';
    2: Result := 'Redução';
    3: Result := 'Substituição';
    4: Result := 'Suspensão';
    5: Result := 'Diferido';
    6: Result := 'Outros ICMS';
    7: Result := 'CAT-38';
    8: Result := 'Não Tributado';
  end;
end;

function FormataTipoTributReduzido(Tipo: Word): string;
begin
  case Tipo of
    0: Result := 'T';
    1: Result := 'I';
    2: Result := 'R';
    3: Result := 'F';
    4: Result := 'S';
    5: Result := 'D';
    6: Result := 'O';
    7: Result := 'C';
    8: Result := 'V';
  end;
end;

function FormataTipoNF(Tipo: Word): string;
begin                                
  case Tipo of
    0: Result := 'Compra';
    1: Result := 'Venda';
    2: Result := 'Bonificação';
    3: Result := 'Devolução';
    4: Result := 'Transferência';
    5: Result := 'Transporte';
    6: Result := 'Outras';
    7: Result := 'Uso e Consumo Próprio';
    8: Result := 'Brindes';
    9: Result := 'Perda';
    10: Result := 'Transf. ICMS';
    11: Result := 'Recusa';
    12: Result := 'Remessa';
    13: Result := 'Complemento';
    14: Result := 'Ajuste';
  end;
end;

function FormataTipoOperacao(Tipo: Word): string;
begin
  case Tipo of
    0: Result := 'Crédito';
    1: Result := 'Débito';
  end;
end;

function FormataCategoria(Tipo: Word): string;
begin
  case Tipo of
    0: Result := 'Receitas';
    1: Result := 'Despesas';
    2: Result := 'Ambos';
  end;
end;

function FormataSubCategoria(Tipo: Word): string;
begin
  case Tipo of
    0: Result := 'Receita';
    1: Result := 'Despesa';
  end;
end;

function FormataTipoCategoria(Tipo: Word): string;
begin
  case Tipo of
    0: Result := '+';
    1: Result := '-';
    2: Result := '±';
  end;
end;

function FormataTipoFrete(Tipo: Word): string;
begin
  case Tipo of
    0: Result := 'CIF';
    1: Result := 'FOB';
  end;
end;

function FormataRecebimento(Tipo: Word): string;
begin
  case Tipo of
    0: Result := 'Pendente';
    1: Result := 'Parcial';
    2: Result := 'Total';
    3: Result := 'Cancelado';
    4: Result := 'Recusado(Forn)';
    5: Result := 'Abortado(C.N)';
  else
    Result := '';
  end;
end;

function FormataEntrega(Tipo: Word): string;
begin
  case Tipo of
    0: Result := 'Direta';
    1: Result := '**CD**';
    2: Result := 'Retirar';
  else
    Result := '';
  end;
end;

//retorna cod.barra boleto digitável
function FormataCBarraDig(vBarra:string): string;
var Dac1,Dac2,Dac3,Dac4: integer;
begin
  try
     if Copy(vBarra,1,1) = '8' then //Constante 8 para identificar arrecadação FEBRABAN
     begin
       Dac1:= DV_Modulo10_Boleto(copy(vBarra, 1, 11));
       Dac2:= DV_Modulo10_Boleto(copy(vBarra, 12, 11));
       Dac3:= DV_Modulo10_Boleto(copy(vBarra, 23, 11));
       Dac4:= DV_Modulo10_Boleto(copy(vBarra, 34, 11));
       Result :=
          copy(vBarra, 1, 11) +
          IntToStr(Dac1)+
          copy(vBarra, 12, 11)+
          IntToStr(Dac2)+
          copy(vBarra, 23, 11)+
          IntToStr(Dac3)+
          copy(vBarra, 34, 11)+
          IntToStr(Dac4);
     end
     else
     begin
       Dac1:= DV_Modulo10_Boleto(copy(vBarra, 1, 4) + copy(vBarra, 20, 5));
       Dac2:=DV_Modulo10_Boleto(copy(vBarra, 25, 10));
       Dac3:=DV_Modulo10_Boleto(copy(vBarra, 35, 10));
       Result :=
          copy(vBarra, 1, 4) +
          copy(vBarra, 20, 5) +
          IntToStr(Dac1)+
          copy(vBarra, 25, 10)+
          IntToStr(Dac2)+
          copy(vBarra, 35, 10)+
          IntToStr(Dac3)+
          copy(vBarra, 5, 15);
     end;
  except
    Result := vBarra;
  end;

end;

function DV_Modulo10_Boleto(Str: String): integer;
var
  ASomar, Soma, X , Pn : Integer;
  Produto : String;
begin
  X := 2;
  Soma := 0;
  For Pn := Length(Str) downto 1 do
  begin
    Produto := IntToStr(StrToInt(Str[Pn]) * X);
    IF StrToInt(Produto) > 9 Then
      ASomar:=  StrToInt(Produto[1]) + StrToInt(Produto[2])
    else
      ASomar:= StrToInt(Produto);

    Soma := Soma + ASomar;
    IF X = 2 Then X := 1 else X := 2;
  end;

  Result := 10 - (Soma mod 10);
  IF Result > 9 then Result := 0;
end;

function CalcDigM10(Campo: String): String;
var
   nl,
   nMult,
   nSoma,
   nMin,
   nMax,
   nResto,
   nDig,
   nParc : integer ;
begin
   nMin := 1;
   nMax := 2;
   nMult := nMax;
   nSoma := 0;
   nl := length(Campo);
   while nl > 0 do
   begin
    nParc := StrToInt( copy(Campo,nl,1) ) * nMult;
    if nParc > 9 then nParc := nParc - 9 ;
    nSoma := nSoma + nParc ;
    nMult := nMult -1;
    nl := nl -1 ;
    if nMult < nMin then nMult := nMax;
   end;
   nResto := nSoma mod 10 ;
   nDig := 10 - nResto;
   if nDig > 9 then nDig := 0;
   Result := IntToStr(nDig) ;
end;

{function DVMODULO10(STR: String): INTEGER;
var
  V_SOMA,V_REGISTRO,V_MULTIPLICADOR,V_RESTO,
  I,J,H,L,N:integer;
  Aux: String;
begin
  V_SOMA:=0;
  V_REGISTRO:=0;
  V_MULTIPLICADOR:=2;
  I:=Length(STR);
  H:=I;
  J:=1;
  while (J<=I) do
  begin
    V_REGISTRO:= StrToInt(STR[H])* V_MULTIPLICADOR;
    if V_REGISTRO > 9 then
    begin
      Aux:= IntToStr(V_REGISTRO);
      L:= Length(Aux);
      for N:=1 to L do
      begin
        V_SOMA:= V_SOMA + StrToInt(aux[N]);
      end;
    end
    else
      V_SOMA:=V_SOMA+V_REGISTRO;
    if (V_MULTIPLICADOR = 2) then
      V_MULTIPLICADOR:=1
    else
      V_MULTIPLICADOR:=V_MULTIPLICADOR+1;
    J:=J+1; H:=H-1;
  end;
  //(d2 mod 11)
  V_RESTO:= (V_SOMA mod 10);
  Result:= 10 - V_RESTO;
end;}

function CurrToStrNaoSepDecimal(Valor: Currency; TamEsquerda, TamDireita:
  SmallInt): string;
begin
  Result := DelChars(FormatFloat(StrMake('0', TamEsquerda) + '.' + StrMake('0',
    TamDireita), Valor), FormatSettings.DecimalSeparator);
end;

function CurrToStrQualOpcao(Valor1, Valor2: Currency; Qual: Boolean;
  TamEsquerda, TamDireita: SmallInt): string;
begin
  if Qual then // se for Substituição
    Result := CurrToStrNaoSepDecimal(Valor1, TamEsquerda, TamDireita)
  else
    Result := CurrToStrNaoSepDecimal(Valor2, TamEsquerda, TamDireita);
end;

function SimNao(Verdadeiro: Boolean): char;
begin
  if Verdadeiro then
    Result := 'S'
  else
    Result := 'N';
end;

function SimNaoBoo(Verdadeiro: Char): Boolean;
begin
  if (Verdadeiro = 'T') or (Verdadeiro = 'S') then
    Result := True
  else
    Result := False;
end;

function SimNaoBooStr(Verdadeiro: string): Boolean;
begin
  if (Verdadeiro = 'T') or (Verdadeiro = 'S') then
    Result := True
  else
    Result := False;
end;

function ConsisteIE(IE, UF: string): Boolean;
var
  IRet: Integer;
  LibHandle: THandle;
  ConsisteInscricaoEstadual: TConsisteInscricaoEstadual;
  Arquivo: PChar;
begin
  Result := False;
  LibHandle := 0;
  try
    Arquivo := 'DllInscE32.Dll';
    LibHandle := LoadLibrary(Arquivo);
    if LibHandle <= HINSTANCE_ERROR then
      raise Exception.Create('Dll não carregada');

    @ConsisteInscricaoEstadual := GetProcAddress(LibHandle,
      'ConsisteInscricaoEstadual');
    if @ConsisteInscricaoEstadual = nil then
      raise Exception.Create('Entrypoint Download não encontrado na Dll');

    IRet := ConsisteInscricaoEstadual(IE, UF);
    if Iret = 0 then
      Result := True
        //MessageDlg ('Inscrição válida para '+edtUf.Text,mtInformation,[mbOk],0)
    else if Iret = 1 then
    begin
      Result := False;
      MessageDlg('Inscrição inválida para ' + UF, mtError, [mbOk], 0);
    end
    else
    begin
      MessageDlg('Parâmetros inválidos', mtError, [mbOk], 0);
      Result := False;
    end;
  finally
    FreeLibrary(LibHandle);
  end;
end;

function FormatFloatSQL(Value: Extended): string;
begin
  FormatSettings.DecimalSeparator := '.';
  Result := FormatFloat('0.00', Value);
  FormatSettings.DecimalSeparator := ',';
end;

function FloatToSQL(Value: Extended): string;
begin
  FormatSettings.DecimalSeparator := '.';
  Result := ' = ' + FormatFloat('0.00', fltRound(Value, 2));
  FormatSettings.DecimalSeparator := ',';
end;

function FloatToSQL3(Value: Extended): string;
begin
  FormatSettings.DecimalSeparator := '.';
  Result := ' = ' + FormatFloat('0.00#', fltRound(Value, 3));
  FormatSettings.DecimalSeparator := ',';
end;

function FloatToSQL4(Value: Extended): string;
begin
  FormatSettings.DecimalSeparator := '.';
  Result := ' = ' + FormatFloat('0.000#', fltRound(Value, 4));
  FormatSettings.DecimalSeparator := ',';
end;

function IntegerToSQL(Value: LongInt): string;
begin
  Result := ' = ' + IntToStr(Value);
end;

function StringToSQLEqual(Value: string): string;
begin
  Result := ' = ''' + Value + '''';
end;

function SimNaoToSQL(Value: boolean): string;
begin
  Result := ' = ''' + SimNao(Value) + '''';
end;

function ConsisteLoja(Lista: TCheckListBox): Boolean;
begin
  Result := False;
  if NumLojasSelecionadas(Lista) < 1 then
  begin
    MessageDlg('Nenhuma Loja Selecionada.', MtWarning, [mbOk], 0);
    Exit;
  end;
  if NumLojasSelecionadas(Lista) > 1 then
  begin
    MessageDlg('Mais de uma Loja Selecionada.', MtWarning, [mbOk], 0);
    Exit;
  end;
  Result := True;
end;

function ValidaLojaSelecionada(Lista: TCheckListBox; Loja: Word): Boolean;
var
  i: Word;
begin
  Result := False;
  for i := 1 to (Lista.Count - 1) do
    if Lista.Checked[i] then
      if Loja = StrToInt(Lista.Items.Strings[i]) then
        Result := True;
end;

procedure HabDesabListaLojas(Lista: TCheckListBox; Acao, MLoja: Boolean);
var
  i: Word;
begin
  if not MLoja then
    Exit;
  for i := 0 to (Lista.Count - 1) do
    Lista.ItemEnabled[i] := Acao;
  Lista.Repaint;
end;

procedure MarcaListaLojaPadrao(Lista: TCheckListBox; Loja: Word);
var
  i: Word;
begin
  Lista.Checked[0] := False;
  for i := 1 to (Lista.Count - 1) do
    Lista.Checked[i] := (Loja = StrToInt(Lista.Items.Strings[i]));
end;

function NumLojasSelecionadas(Lista: TCheckListBox): Word;
var
  i: Word;
begin
  Result := 0;
  for i := 1 to (Lista.Count - 1) do
    if Lista.Checked[i] then
      Inc(Result);
end;


function iniciaServico(p_maquina, p_servico : string ) : boolean;
var
  //
  // manager handle
  schm,
  //
  // service handle
  schs   : SC_Handle;
  //
  // service status
  ss     : TServiceStatus;
  //
  // temp char pointer
  psTemp : PChar;
  //
  // check point
  dwChkP : DWord;
begin
  ss.dwCurrentState := 0;

  // connect to the service
  // control manager
  schm := OpenSCManager(
    PChar(p_maquina),
    Nil,
    SC_MANAGER_CONNECT);

  // if successful...
  if(schm > 0)then
  begin
    // open a handle to
    // the specified service
    schs := OpenService(
      schm,
      PChar(p_servico),
      // we want to
      // start the service and
      SERVICE_START or
      // query service status
      SERVICE_QUERY_STATUS);

    // if successful...
    if(schs > 0)then
    begin
      psTemp := Nil;
      if(StartService(
           schs,
           0,
           psTemp))then
      begin
        // check status
        if(QueryServiceStatus(
             schs,
             ss))then
        begin
          while(SERVICE_RUNNING
            <> ss.dwCurrentState)do
          begin
            //
            // dwCheckPoint contains a
            // value that the service
            // increments periodically
            // to report its progress
            // during a lengthy
            // operation.
            //
            // save current value
            //
            dwChkP := ss.dwCheckPoint;

            //
            // wait a bit before
            // checking status again
            //
            // dwWaitHint is the
            // estimated amount of time
            // the calling program
            // should wait before calling
            // QueryServiceStatus() again
            //
            // idle events should be
            // handled here...
            //
            Sleep(ss.dwWaitHint);

            if(not QueryServiceStatus(
                 schs,
                 ss))then
            begin
              // couldn't check status
              // break from the loop
              break;
            end;

            if(ss.dwCheckPoint <
              dwChkP)then
            begin
              // QueryServiceStatus
              // didn't increment
              // dwCheckPoint as it
              // should have.
              // avoid an infinite
              // loop by breaking
              break;
            end;
          end;
        end;
      end;

      // close service handle
      CloseServiceHandle(schs);
    end;

    // close service control
    // manager handle
    CloseServiceHandle(schm);
  end;

  // return TRUE if
  // the service status is running
  Result :=
    SERVICE_RUNNING =
      ss.dwCurrentState;
end;

function CombLojasSelecionadas(Lista: TCheckListBox): Word;
var
  i: Word;
begin
  Result := 0;
  for i := 1 to (Lista.Count - 1) do
    if Lista.Checked[i] then
      if Epar(StrToIntDef(Lista.Items.Strings[i], 0)) then
        Result := Result + StrToIntDef(Lista.Items.Strings[i], 0) * 2
      else
        Result := Result + StrToIntDef(Lista.Items.Strings[i], 0) * 3;
end;

procedure ReplicaMarcaLista(Origem: TCheckListBox; var Destino: TCheckListBox;
  Adiciona: Boolean);
var
  i: Word;
begin
  if Adiciona and (not Destino.Items.Equals(Origem.Items)) then
    Destino.Items.AddStrings(Origem.Items);
  for i := 0 to (Origem.Count - 1) do
    Destino.Checked[i] := Origem.Checked[i];
end;


function InjetaLojaConcatQryFixa(aAND_WHERE, aParametroMacro, aCampo : String; aQry : TSQLQuery; aSQL : String; aListaLoja : TCheckListBox) : Boolean;
var
  i, vContSel : Integer;
  vSQL, vCondicao : String;
begin
  vContSel := 0;

  aAND_WHERE := aAND_WHERE + ' ';

  for i := 1 to (aListaLoja.Count - 1) do
  begin
    if aListaLoja.Checked[i] then
    begin
     Inc(vContSel);

     if vContSel > 1 then
       vCondicao := vCondicao + ', ' + aListaLoja.Items.Strings[i]
     else
       vCondicao := aListaLoja.Items.Strings[i];
    end;
  end;

  vCondicao := aAND_WHERE + aCampo + ' IN (' + vCondicao + ')';

  vSQL := aSQL;
  vSQL := AnsiReplaceText(vSQL, aParametroMacro, vCondicao);
  aQry.SQL.Text := vSQL;

  Result := vContSel > 0;

  if not Result then
    MessageDlg('Nenhuma Loja Selecionada.', mtError, [mbOk], 0);

  //showmessage(QryTeste.sql.text);
end;


//procedure ValidaNumLojasPermitidas(Sender: TObject; CLbxLoja: TCheckListBox; TClasse: TClass);

function AddSQLLojasStrings(Lista: TCheckListBox; Tabela: string; Str:
  TStrings): Boolean;
var
  i, TotLista, TotSele: Word;
  LojaPrimSele, LojaUltSele: string;
begin
  Result := False;

  TotLista := Lista.Count;

  TotSele := NumLojasSelecionadas(Lista);

  if TotSele < 1 then
    Exit;

  Result := True;

  if TotSele = 1 then
  begin
    for i := 1 to (TotLista - 1) do
      if Lista.Checked[i] then
      begin
        Str.Add(Tabela + '.COD_LOJA = ' + Lista.Items.Strings[i]);
        Break;
      end;
  end
  else
  begin
    LojaPrimSele := '';
    for i := 1 to (TotLista - 1) do
      if Lista.Checked[i] then
      begin
        if LojaPrimSele = '' then
          LojaPrimSele := Lista.Items.Strings[i];
        LojaUltSele := Lista.Items.Strings[i];
      end;
    Str.Add(Tabela + '.COD_LOJA BETWEEN ' + LojaPrimSele + ' AND ' +
      LojaUltSele);

    for i := 1 to (TotLista - 1) do
      if not Lista.Checked[i] and
        (StrToInt(Lista.Items.Strings[i]) > StrToInt(LojaPrimSele)) and
        (StrToInt(Lista.Items.Strings[i]) < StrToInt(LojaUltSele)) then
        Str.Add('AND ' + Tabela + '.COD_LOJA <> ' + Lista.Items.Strings[i]);

  end;

  (*  Result := False;
    x := 1;
    Str.Add(Tabela + '.COD_LOJA IN (');
    for i := 1  to (Lista.Count -1) do
      if Lista.Checked[i] then
      begin
        Result := True;
        if (x = 1) then
          Qry.SQL.Add(Lista.Items.Strings[i])
        else
          Qry.SQL.Add(',' + Lista.Items.Strings[i]);
        Inc(x);
      end;
    Qry.SQL.Add(')');
    *)

end;

function GetINCodLojasSelecionadas(Lista : TCheckListBox) : string;
var vS : TStringList;
    i, x : integer;
begin
  Try
    vS := TStringList.Create;
    x := 1;
    for i := 1  to (Lista.Count -1) do
      if Lista.Checked[i] then
      begin
        if (x = 1) then
          vS.Add(Lista.Items.Strings[i])
        else
          vS.Add(',' + Lista.Items.Strings[i]);
        Inc(x);
      end;
  Finally
    Result := vS.Text;
    FreeAndNil(vS);
  End;
end;

function ListaLojaSelecionada(Lista: TCheckListBox): string;
var
  i, x: Word;
begin
  Result := '';
  x := 1;
  for i := 1 to (Lista.Count - 1) do
    if Lista.Checked[i] then
    begin
      if (x = 1) then
        Result := Result + Lista.Items.Strings[i]
      else
        Result := Result + ', ' + Lista.Items.Strings[i];
      Inc(x);
    end;
end;

function ListaLojaSelecionadaDelimitador(aLista: TCheckListBox; aDelimitador:String): string;
var
  i, x: Word;
begin
  Result := '';
  x := 1;
  for i := 1 to (aLista.Count - 1) do
    if aLista.Checked[i] then
    begin
      if (x = 1) then
        Result := Result + aLista.Items.Strings[i]
      else
        Result := Result + aDelimitador + aLista.Items.Strings[i];
      Inc(x);
    end;
end;

procedure AddListaComboBox(CliDS: TClientDataSet; Lista: TCustomComboBox;
  Campos: string);
var
  i: Word;
  StCampos: TStrings;
  Texto: string;
begin
  StCampos := TStringList.Create;
  StCampos.Clear;
  StCampos := Split(Campos, ';');
  CliDS.Close;
  try
    CliDS.Open;
    with Lista.Items do
    begin
      Clear;
      CliDS.First;
      while not CliDS.Eof do
      begin
        Texto := '';
        for i := 0 to StCampos.Count - 1 do
          Texto := Texto + CliDS.FieldByName(StCampos.Strings[i]).AsString +
            ' - ';
        Texto := Trim(Copy(Texto, 1, Length(Texto) - 3));
        Add(Texto);
        CliDS.Next;
      end;
    end;
  finally
    CliDS.Close;
    StCampos.Free;
  end;
end;

procedure AddListaComboBoxClassif(CliDS: TClientDataSet; Lista: TCustomComboBox;
  TipoClassif: Integer; Campos: string);
var
  i: Word;
  StCampos: TStrings;
  Texto: string;
begin
  StCampos := TStringList.Create;
  StCampos.Clear;
  StCampos := Split(Campos, ';');
  CliDS.Close;
  try
    CliDS.Params.ParamByName('TIPO_CLASSIF').AsInteger := TipoClassif;
    CliDS.Open;
    with Lista.Items do
    begin
      Clear;
      CliDS.First;
      while not CliDS.Eof do
      begin
        Texto := '';
        for i := 0 to StCampos.Count - 1 do
          Texto := Texto + CliDS.FieldByName(StCampos.Strings[i]).AsString +
            ' - ';
        Texto := Trim(Copy(Texto, 1, Length(Texto) - 3));
        Add(Texto);
        CliDS.Next;
      end;
    end;
  finally
    CliDS.Close;
    StCampos.Free;
  end;
end;

procedure AddListaComboBoxGrupo(CliDS: TClientDataSet; Lista: TCustomComboBox;
  CodSecao: Integer; Campos: string);
var
  i: Word;
  StCampos: TStrings;
  Texto: string;
begin
  StCampos := TStringList.Create;
  StCampos.Clear;
  StCampos := Split(Campos, ';');
  CliDS.Close;
  try
    CliDS.Params.ParamByName('COD_SECAO').AsInteger := CodSecao;
    CliDS.Open;
    with Lista.Items do
    begin
      Clear;
      CliDS.First;
      while not CliDS.Eof do
      begin
        Texto := '';
        for i := 0 to StCampos.Count - 1 do
          Texto := Texto + CliDS.FieldByName(StCampos.Strings[i]).AsString +
            ' - ';
        Texto := Trim(Copy(Texto, 1, Length(Texto) - 3));
        Add(Texto);
        CliDS.Next;
      end;
    end;
  finally
    CliDS.Close;
    StCampos.Free;
  end;
end;

procedure AddListaComboBoxSGrupo(CliDS: TClientDataSet; Lista: TCustomComboBox;
  CodSecao, CodGrupo: Integer; Campos: string);
var
  i: Word;
  StCampos: TStrings;
  Texto: string;
begin
  StCampos := TStringList.Create;
  StCampos.Clear;
  StCampos := Split(Campos, ';');
  CliDS.Close;
  try
    CliDS.Params.ParamByName('COD_SECAO').AsInteger := CodSecao;
    CliDS.Params.ParamByName('COD_GRUPO').AsInteger := CodGrupo;
    CliDS.Open;
    with Lista.Items do
    begin
      Clear;
      CliDS.First;
      while not CliDS.Eof do
      begin
        Texto := '';
        for i := 0 to StCampos.Count - 1 do
          Texto := Texto + CliDS.FieldByName(StCampos.Strings[i]).AsString +
            ' - ';
        Texto := Trim(Copy(Texto, 1, Length(Texto) - 3));
        Add(Texto);
        CliDS.Next;
      end;
    end;
  finally
    CliDS.Close;
    StCampos.Free;
  end;
end;

function ValCampoListaComboBox(Texto: string; Delimitador: Char; Posicao: Word):
  string;
var
  StCampos: TStrings;
begin
  if Texto = '' then
  begin
    Result := '';
    Exit;
  end;
  StCampos := TStringList.Create;
  StCampos.Clear;
  StCampos := Split(Texto, Delimitador);
  Result := Trim(StCampos.Strings[Posicao]);
end;
{
function MontaSQL(Tipo: char; var ValWhere: string; Campo: string; Valor:
  variant; Condicao: string): string;
begin
  // Tipo ( C = Caracter, N = Númerico, D = Data, I = Inteiro, B = Boolean, E = Extended (03 casas) )
  // Condicao
  //   L : Like
  //   = : Igual
  //   > : Maior
  //   < : Menor
  //   <= : Menor e igual
  //   >= : Maior e igual
  //
  if strPos(';', Valor, 1) > 0 then
  begin
    MessageDlg('Não permitido caracter "ponto e vírgula" na pesquisa.',
      mtWarning, [mbOk], 0);
    Abort;
  end;
  if strPos('''', Valor, 1) > 0 then
  begin
    MessageDlg('Não permitido caracter "aspas simples" na pesquisa.', mtWarning,
      [mbOk], 0);
    Abort;
  end;

  (*
  if strPos('%', Valor, 2) > 1 then
  begin
    MessageDlg('Não permitido identificador ''%'' entre caracteres.', mtWarning,
      [mbOk], 0);
    Abort;
  end;
*)

  // QUANDO USUÁRIO FOR MULTI-LOJA E FOR PESQUISAR PARA MAIS DE 01 LOJA
  if MultLoja then
    if Assigned(Application.MainForm.Owner.FindComponent('FramSelLoja'))
      then
      if
        Assigned(Application.MainForm.ActiveMDIChild.FindComponent('FramSelLoja').FindComponent('CLbxLoja')) then
        if
          NumLojasSelecionadas(TCheckListBox(Application.MainForm.ActiveMDIChild.FindComponent('FramSelLoja').FindComponent('CLbxLoja'))) > 1 then
        begin
(*          if (strLeft(Valor, 1) = '%') then
          begin
            MessageDlg('Não permitido Identificador ''%'' no início, para pesquisas multi-lojas', mtWarning, [mbOk], 0);
            Abort;
          end;
*)          
          if Condicao = 'L' then
            if Length(DelChars(Valor, '%')) < 3 then
            begin
              MessageDlg('É necessário no mínimo 3 caracteres para pesquisas multi-lojas', mtWarning, [mbOk], 0);
              Abort;
            end;
        end;
  //
  if ValWhere = '' then
    Result := ' WHERE '
  else
    Result := ' AND ';
  case Tipo of
    'D': Result := Result + Campo + DateToSQL(Condicao, Valor);
    'C': if Condicao = 'L' then
        Result := Result + Campo + StringToSQLLike(Valor)
      else
        Result := Result + Campo + StringToSQLEqual(Valor);
    'I': Result := Result + Campo + IntegerToSQL(Valor);
    'N': Result := Result + Campo + FloatToSQL(Valor);
    'E': Result := Result + Campo + FloatToSQL3(Valor);
    'B': Result := Result + Campo + SimNaoToSQL(Valor);
    'U': Result := Result + Campo + ' IS NULL ';
  end;
  //
  ValWhere := Result;
end;}

function GetSQLAddLojaLista(Lista: TCheckListBox; Tabela: string) : string;
var
  i, TotLista, TotSele: Word;
  LojaPrimSele, LojasSele: string;
begin

  TotLista := Lista.Count;

  TotSele := NumLojasSelecionadas(Lista);

  if TotSele < 1 then
  begin
    Result := EmptyStr;
    Exit;
  end;

  if TotSele = 1 then
  begin
    for i := 1 to (TotLista - 1) do
      if Lista.Checked[i] then
      begin
        Result := Tabela + '.COD_LOJA = ' + Lista.Items.Strings[i];
        Break;
      end;
  end
  else
  begin
    LojaPrimSele := '';
    LojasSele := '';
    for i := 1 to (TotLista - 1) do
      if Lista.Checked[i] then
      begin
        if (i > 1) and (i <= (TotLista - 1)) then
          if LojasSele <> '' then
            LojasSele := LojasSele + ',';
        LojasSele := LojasSele + Lista.Items.Strings[i];
      end;
    Result := Tabela + '.COD_LOJA IN (' + LojasSele + ')';
  end;
end;

function AddSQLLojasX(Lista: TCheckListBox; Tabela: string; Qry: TSQLQuery):
  Boolean;
var
  i, TotLista, TotSele: Word;
  LojaPrimSele, LojasSele: string;
begin
  Result := False;

  TotLista := Lista.Count;

  TotSele := NumLojasSelecionadas(Lista);

  if TotSele < 1 then
    Exit;

  Result := True;

  if TotSele = 1 then
  begin
    for i := 1 to (TotLista - 1) do
      if Lista.Checked[i] then
      begin
        Qry.SQL.Add(Tabela + '.COD_LOJA = ' + Lista.Items.Strings[i]);
        Break;
      end;
  end
  else
  begin
    LojaPrimSele := '';
    LojasSele := '';
    for i := 1 to (TotLista - 1) do
      if Lista.Checked[i] then
      begin
        if (i > 1) and (i <= (TotLista - 1)) then
          if LojasSele <> '' then
            LojasSele := LojasSele + ',';
        LojasSele := LojasSele + Lista.Items.Strings[i];
      end;
    Qry.SQL.Add(Tabela + '.COD_LOJA IN (' + LojasSele + ')');



(*
    for i := 1 to (TotLista - 1) do
      if Lista.Checked[i] then
      begin
        if LojaPrimSele = '' then
          LojaPrimSele := Lista.Items.Strings[i];
        LojaUltSele := Lista.Items.Strings[i];
      end;
    Qry.SQL.Add(Tabela + '.COD_LOJA BETWEEN ' + LojaPrimSele + ' AND ' +
      LojaUltSele);

    for i := 1 to (TotLista - 1) do
      if not Lista.Checked[i] and
        (StrToInt(Lista.Items.Strings[i]) > StrToInt(LojaPrimSele)) and
        (StrToInt(Lista.Items.Strings[i]) < StrToInt(LojaUltSele)) then
        Qry.SQL.Add('AND ' + Tabela + '.COD_LOJA <> ' + Lista.Items.Strings[i]);
*)
  end;

  (*  Result := False;
    x := 1;
    Qry.SQL.Add(Tabela + '.COD_LOJA IN (');
    for i := 1  to (Lista.Count -1) do
      if Lista.Checked[i] then
      begin
        Result := True;
        if (x = 1) then
          Qry.SQL.Add(Lista.Items.Strings[i])
        else
          Qry.SQL.Add(',' + Lista.Items.Strings[i]);
        Inc(x);
      end;
    Qry.SQL.Add(')');
    *)

end;

function AddSQLLojasX(Lista: TCheckListBox; Tabela: string; Qry: TFDQuery):Boolean;
var
  i, TotLista, TotSele: Word;
  LojaPrimSele, LojasSele: string;
begin
  Result := False;

  TotLista := Lista.Count;

  TotSele := NumLojasSelecionadas(Lista);

  if TotSele < 1 then
    Exit;

  Result := True;

  if TotSele = 1 then
  begin
    for i := 1 to (TotLista - 1) do
      if Lista.Checked[i] then
      begin
        Qry.SQL.Add(Tabela + '.COD_LOJA = ' + Lista.Items.Strings[i]);
        Break;
      end;
  end
  else
  begin
    LojaPrimSele := '';
    LojasSele := '';
    for i := 1 to (TotLista - 1) do
      if Lista.Checked[i] then
      begin
        if (i > 1) and (i <= (TotLista - 1)) then
          if LojasSele <> '' then
            LojasSele := LojasSele + ',';
        LojasSele := LojasSele + Lista.Items.Strings[i];
      end;
    Qry.SQL.Add(Tabela + '.COD_LOJA IN (' + LojasSele + ')');
  end;
end;

function AddSQLLojasXName(Lista: TCheckListBox; Tabela: string; Qry: TSQLQuery; NomeCampo : String):
  Boolean;
var
  i, TotLista, TotSele: Word;
  LojaPrimSele, LojasSele: string;
begin
  Result := False;

  TotLista := Lista.Count;

  TotSele := NumLojasSelecionadas(Lista);

  if TotSele < 1 then
    Exit;

  Result := True;

  if TotSele = 1 then
  begin
    for i := 1 to (TotLista - 1) do
      if Lista.Checked[i] then
      begin
        Qry.SQL.Add(Tabela + '.' + NomeCampo + ' = ' + Lista.Items.Strings[i]);
        Break;
      end;
  end
  else
  begin
    LojaPrimSele := '';
    LojasSele := '';
    for i := 1 to (TotLista - 1) do
      if Lista.Checked[i] then
      begin
        if (i > 1) and (i <= (TotLista - 1)) then
          if LojasSele <> '' then
            LojasSele := LojasSele + ',';
        LojasSele := LojasSele + Lista.Items.Strings[i];
      end;
    Qry.SQL.Add(Tabela + '.' + NomeCampo + ' IN (' + LojasSele + ')');
  end;
end;

function AddSQLColunaX(Lista: TCheckListBox; Tabela, Coluna: string; Qry:
  TSQLQuery): Boolean;
var
  i, x: Word;
begin
  Qry.SQL.Add('(');
  x := 0;
  Result := False;
  for i := 1 to (Lista.Count - 1) do
    if Lista.Checked[i] then
    begin
      Result := True;
      Inc(x);
      if (x > 1) then
        Qry.SQL.Add('OR ');
      Qry.SQL.Add(Tabela + '.' + Coluna + ' = ' + Lista.Items.Strings[i] + ' ');
    end;
  Qry.SQL.Add(')');
end;

{function AddSQLColunaExecX(Coluna, Condicao: string; MTab: TJvMemoryData; Qry:
  TSQLQuery): Boolean;
var
  x: Word;
begin
  Qry.SQL.Add(Coluna + ' ' + Condicao + ' (');
  x := 1;
  Result := False;
  MTab.DisableControls;
  try
    MTab.First;
    while not MTab.Eof do
    begin
      Result := True;
      if (x = 1) then
        Qry.SQL.Add(MTab.FieldByName(Coluna).AsString)
      else
        Qry.SQL.Add(',' + MTab.FieldByName(Coluna).AsString);
      Inc(x);
      MTab.Next;
    end;
  finally
    MTab.EnableControls;
  end;
  Qry.SQL.Add(')');
end;}

{procedure CondicaoSQLX(Tipo: char; var ValWhere: string; Campo: string; Valor,
  ValExit: variant; Condicao: string; Qry: TSQLQuery);
begin
  // Tipo ( C = Caracter, N = Númerico, D = Data, I = Inteiro, B = Boolean, E = Extended )
  // Condicao
  //   L : Like
  //   = : Igual
  //   > : Maior
  //   < : Menor
  //   <= : Menor e igual
  //   >= : Maior e igual
  //   IN : Dentro
  //
  if Valor = ValExit then
    Exit;

  if strPos(';', Valor, 1) > 0 then
  begin
    MessageDlg('Não permitido caracter "ponto e vírgula" na pesquisa.',
      mtWarning, [mbOk], 0);
    Abort;
  end;
  if strPos('''', Valor, 1) > 0 then
  begin
    MessageDlg('Não permitido caracter "aspas simples" na pesquisa.', mtWarning,
      [mbOk], 0);
    Abort;
  end;
(*
  if strPos('%', Valor, 2) > 1 then
  begin
    MessageDlg('Não permitido identificador ''%'' entre caracteres.', mtWarning,
      [mbOk], 0);
    Abort;
  end;
*)  
  // QUANDO USUÁRIO FOR MULTI-LOJA E FOR PESQUISAR PARA MAIS DE 01 LOJA

  if MultLoja then
    if Application.MainForm.MDIChildCount > 0 then
    begin
      if Assigned(Application.MainForm.ActiveMDIChild.FindComponent('FramSelLoja')) then
        if Assigned(Application.MainForm.ActiveMDIChild.FindComponent('FramSelLoja').FindComponent('CLbxLoja')) then
          if NumLojasSelecionadas(TCheckListBox(Application.MainForm.ActiveMDIChild.FindComponent('FramSelLoja').FindComponent('CLbxLoja'))) > 1 then
          begin
(*
          if (strLeft(Valor, 1) = '%') then
          begin
            MessageDlg('Não permitido Identificador ''%'' no início, para pesquisas multi-lojas', mtWarning, [mbOk], 0);
            Abort;
          end;
*)
            if Condicao = 'L' then
              if Length(DelChars(Valor, '%')) < 3 then
              begin
                MessageDlg('É necessário no mínimo 3 caracteres para pesquisas multi-lojas', mtWarning, [mbOk], 0);
                Abort;
              end;
          end;
    end
    else
    begin
      if Assigned(Application.MainForm.FindComponent('FramSelLoja')) then
        if Assigned(Application.MainForm.FindComponent('FramSelLoja').FindComponent('CLbxLoja')) then
          if NumLojasSelecionadas(TCheckListBox(Application.MainForm.FindComponent('FramSelLoja').FindComponent('CLbxLoja'))) > 1 then
          begin
(*
          if (strLeft(Valor, 1) = '%') then
          begin
            MessageDlg('Não permitido Identificador ''%'' no início, para pesquisas multi-lojas', mtWarning, [mbOk], 0);
            Abort;
          end;
*)
            if Condicao = 'L' then
              if Length(DelChars(Valor, '%')) < 3 then
              begin
                MessageDlg('É necessário no mínimo 3 caracteres para pesquisas multi-lojas', mtWarning, [mbOk], 0);
                Abort;
              end;
          end;
    end;
  //
  if ValWhere = '' then
    ValWhere := ' WHERE '
  else
    ValWhere := ' AND ';
  case Tipo of
    'D': ValWhere := ValWhere + Campo + DateToSQL(Condicao, Valor);
    'C': if Condicao = 'L' then
        ValWhere := ValWhere + Campo + StringToSQLLike(Valor)
      else
        ValWhere := ValWhere + Campo + StringToSQLEqual(Valor);
    'I': if Condicao = 'IN' then
           ValWhere := ValWhere + Campo + ' IN (' + Valor + ')'
         else
           ValWhere := ValWhere + Campo + IntegerToSQL(Valor);
    'N': ValWhere := ValWhere + Campo + FloatToSQL(Valor);
    'E': ValWhere := ValWhere + Campo + FloatToSQL3(Valor);
    'R': ValWhere := ValWhere + Campo + FloatToSQL4(Valor);
    'B': if Condicao = 'IN' then
        ValWhere := ValWhere + Campo + ' IN (' + QuotedStr('S') + ',' +
          QuotedStr('N') + ')'
      else
        ValWhere := ValWhere + Campo + SimNaoToSQL(Valor);
    //'B': ValWhere := ValWhere + Campo + SimNaoToSQL(Valor);
    'U': ValWhere := ValWhere + Campo + ' IS NULL ';
  end;
  //
  Qry.SQL.Add(ValWhere);
end; }

function MontaPriory(Value, Campo: string): string;
begin
  if Value = '' then
    Result := Campo
  else
    Result := Value + ',' + Campo;
end;

// VALIDA EAN

function ValidaEAN(Cod: string; Num: word; var CodEAN: string): Boolean;
var
  CodTemp: string;
begin
  CodTemp := '';
  CodEAN := Cod;
  Result := False;
  //DUN 14
  if (Length(Trim(Cod)) = 14) then
  begin
    Result := True;
    Exit;
  end;
  if (Length(Cod) > Num) then
    Exit;
  if Length(Cod) = Num then
  begin
    CodTemp := GeraDigitoEAN(Copy(Cod, 1, Num - 1), Num);
    if copy(Cod, Num, 1) <> CodTemp then
      Exit;
    CodEAN := Cod;
  end;
  if Length(Cod) < Num then
  begin
    CodTemp := GeraDigitoEAN(copy(strPadZeroL(Cod, Num), 1, Num - 1), Num);
    if copy(strPadZeroL(Cod, Num), Num, 1) <> CodTemp then
      Exit;
    CodEAN := strPadZeroL(Cod, Num);
  end;
  Result := True;
end;

function VerificaEAN(Digito13: Boolean; EAN: string; Foco: TEdit): Boolean;
var
  CodEAN: string;
  Digito: SmallInt;
begin
  Result := True;
  Digito := 0;
  case Digito13 of
    True: Digito := 13;
    False: Digito := 8;
  end;
  if not ValidaEAN(strPadZeroL(EAN, Digito), 13, CodEAN) then
  begin
    MessageDlg('Dígito Verificador não confere.', mtWarning, [mbOk], 0);
    Foco.SetFocus;
    Result := False;
    Exit;
  end;
end;

function VerificaEANBoo(Digito13, BMensag: Boolean; EAN: string): Boolean;
var
  CodEAN: string;
  Digito: SmallInt;
begin
  Result := True;
  Digito := 0;
  case Digito13 of
    True: Digito := 13;
    False: Digito := 8;
  end;
  if BMensag then
    if not ValidaEAN(strPadZeroL(EAN, Digito), 13, CodEAN) then
    begin
      MessageDlg('Dígito Verificador não confere.', mtWarning, [mbOk], 0);
      Result := False;
      Exit;
    end;
end;

// GERA DIGITO DE CONTROLE CODIGO EAN

function GeraDigitoEAN(Cod: string; Num: word): string;
var
  Tot1, Tot2, Tot3: LongInt;
  I: Integer;
  CodRef: string;
  Digito: Integer;
begin
  Tot1 := 0;
  Tot2 := 0;
  CodRef := strPadZeroL(Cod, Num - 1);
  for I := 1 to (Num - 1) do
  begin
    if EPar(I) then
      Tot1 := Tot1 + StrToInt(CodRef[i])
    else
      Tot2 := Tot2 + StrToInt(CodRef[i]);
  end;
  Tot1 := Trunc(Tot1 * 3);
  Tot3 := Tot1 + Tot2;
  Digito := trunc(10 * (int(Tot3 / 10.0) + 1) - Tot3);
  if Digito = 10 then
    Digito := 0;
  Result := IntToStr(Digito);
end;

function EPar(Numero: longInt): Boolean;
begin
  Result := False;
  if Numero = 0 then
    Result := True
  else if Numero = 1 then
    Result := False
  else if Numero = 2 then
    Result := True
  else if Numero = 3 then
    Result := False
  else if Numero = 4 then
    Result := True
  else if Numero = 5 then
    Result := False
  else if Numero = 6 then
    Result := True
  else if Numero = 7 then
    Result := False
  else if Numero = 8 then
    Result := True
  else if Numero = 9 then
    Result := False
  else if Numero = 10 then
    Result := True
  else if Numero = 11 then
    Result := False
  else if Numero = 12 then
    Result := True
  else if Numero = 13 then
    Result := False
end;

function GeraEANImpressao(Cod: string): string;
type
  TDig = array[0..9, 0..6] of string;
var
  i, x, PrimDig: Word;
  Seq, LH: string;
const //      0    1    2    3    4    5    6
  //     Dt | LHA |LHB |RH  |FF | SF | Ch
  aDig: TDig = (('0', '0', '@', 'P', '!', '`', 'p'),
    ('1', '1', 'A', 'Q', '"', 'a', 'q'),
    ('2', '2', 'B', 'R', '#', 'b', 'r'),
    ('3', '3', 'C', 'S', '$', 'c', 's'),
    ('4', '4', 'D', 'T', '%', 'd', 't'),
    ('5', '5', 'E', 'U', '&', 'e', 'u'),
    ('6', '6', 'F', 'V', ' ', 'f', 'v'),
    ('7', '7', 'G', 'W', '(', 'g', 'w'),
    ('8', '8', 'H', 'X', ')', 'h', 'x'),
    ('9', '9', 'I', 'Y', '*', 'i', 'y'));

begin
  // Todos para EAN-13
  Cod := StrPadZeroL(Cod, 13);

  // First e Second Flag
  Result := aDig[StrToInt(Copy(Cod, 1, 1)), 4] + aDig[StrToInt(Copy(Cod, 2, 1)),
    5];

  // Left Hand A e B
  // Verifica sequência pelo primeiro digito
  PrimDig := StrToInt(Copy(Cod, 1, 1));
  case PrimDig of
    0: Seq := 'AAAAA';
    1: Seq := 'ABABB';
    2: Seq := 'ABBAB';
    3: Seq := 'ABBBA';
    4: Seq := 'BAABB';
    5: Seq := 'BBAAB';
    6: Seq := 'BBBAA';
    7: Seq := 'BABAB';
    8: Seq := 'BABBA';
    9: Seq := 'BBABA';
  end;
  x := 3; // Left Hand inicia do 3 e vai até o 7 !
  for i := 1 to Length(Seq) do
  begin
    LH := Copy(Seq, i, 1);
    if LH = 'A' then
      Result := Result + aDig[StrToInt(Copy(Cod, x, 1)), 1]
    else
      Result := Result + aDig[StrToInt(Copy(Cod, x, 1)), 2];
    Inc(x);
  end;

  // Center Guard
  Result := Result + '|';

  // Right Hand
  for i := 8 to 12 do
    Result := Result + aDig[StrToInt(Copy(Cod, i, 1)), 3];

  // Check
  Result := Result + aDig[StrToInt(Copy(Cod, 13, 1)), 6];
end;

function StrToVal(Cadeia: string): LongInt;
begin
  try
    Result := StrToInt(Cadeia);
  except
    Result := 0;
  end;
end;

function StrZeroLeft(Cadeia: string; Tam: word): string;
var
  I: integer;
begin
  Result := '';
  for I := 1 to (Tam - Length(Cadeia)) do
  begin
    Result := Result + '0';
  end;
  Result := Result + Cadeia;
end;

function MesProximo(data: TDateTime): TDateTime;
begin
  Result := dateEndOfMonth(Data) + 1;
end;

function MesAnterior(data: TDateTime): TDateTime;
begin
  Result := dateBeginOfMonth(Data) - 1;
end;

function CalcDataFatura(DtaVencto: TDateTime; NumCond, CodCond: Integer; var
  SDtaEmiEnt: string): TDateTime;
type
  TDayWeek = array[0..6, 0..1] of string;
const
  aDay: TDayWeek = (('Sunday', '0'),
    ('Monday', '6'),
    ('Tuesday', '5'),
    ('Wednesday', '4'),
    ('Thursday', '3'),
    ('Friday', '2'),
    ('Saturday', '1'));
var
  x: Word;
  DayTxt: string;
begin
  SDtaEmiEnt := 'Em';
  case CodCond of
    1: Result := DtaVencto; {A Vista }
    2: Result := DtaVencto - NumCond; {DD}
    3:
      begin
        Result := DtaVencto - NumCond; {DD Liq  }
        SDtaEmiEnt := 'En';
      end;
    4:
      begin
        case dateDayOfWeek(DtaVencto) of
          Sunday: DayTxt := 'Sunday';
          Monday: DayTxt := 'Monday';
          Tuesday: DayTxt := 'Tuesday';
          Wednesday: DayTxt := 'Wednesday';
          Thursday: DayTxt := 'Thursday';
          Friday: DayTxt := 'Friday';
          Saturday: DayTxt := 'Saturday';
        end;
        for x := 0 to Length(aDay) - 1 do
          if DayTxt = aDay[x, 0] then
            NumCond := NumCond + StrtoInt(aDay[x, 1]);
        Result := DtaVencto - NumCond; {DD f/Semana}
      end;
    5:
      begin
        Result := DtaVencto - NumCond; {DD f/Quinzena}
        if dateDay(Result) <= 15 then
          NumCond := (15 - dateDay(Result)) + NumCond
        else
          NumCond := (dateDaysInMonth(Result) - dateDay(Result)) + NumCond;
        Result := Result + NumCond; {DD f/Quinzena}
      end;
    6:
      begin
        Result := DtaVencto - NumCond; {DD f/Mês}
        NumCond := (dateDaysInMonth(Result) - dateDay(Result)) + NumCond;
        Result := Result + NumCond; {DD f/Mês}
      end;
    7:
      begin
        Result := DtaVencto - NumCond; {DD f/Dezena}
        if dateDay(Result) <= 10 then
          NumCond := (10 - dateDay(Result)) + NumCond
        else if (dateDay(Result) > 10) and (dateDay(Result) <= 20) then
          NumCond := (20 - dateDay(Result)) + NumCond
        else
          NumCond := (dateDaysInMonth(Result) - dateDay(Result)) + NumCond;
        Result := Result + NumCond; {DD f/Dezena}
      end;
    8:
      begin
        Result := DtaVencto - NumCond; {DD pré-fixada}
        if TryEncodeDate(dateYear(Result), dateMonth(Result), NumCond, Result)
          then
          Result := EncodeDate(dateYear(Result), dateMonth(Result), NumCond);
      end;
    //12: Result := DtaVencto - DiasUteis(DtaVencto,NumCond, DiaBase); {Dias Útil Fixo}
  else
    Result := DtaVencto - NumCond;
  end;
end;

function CalcDataPrevPgto(DtaVencto, DtaProrrog, DtaPrograma: TDateTime):
  TDateTime;
begin
  Result := DtaVencto;
  if DtaProrrog <> 0.00 then
    Result := DtaProrrog;
  if DtaPrograma <> 0.00 then
    Result := DtaPrograma;
end;


function ExisteMTabCodInt(tabela: TClientDataSet; campo: string; cod: integer):
  boolean;
begin
  if tabela.Locate(campo, cod, []) then
    Result := True
  else
    Result := False;
end;

function ExisteCliTabCodInt(tabela: TClientDataSet; campo: string; cod:
  integer): boolean;
begin
  if tabela.Locate(campo, cod, []) then
    Result := True
  else
    Result := False;
end;


procedure MudaEstadoGrid(Grid: TDBGrid; Edicao: Boolean);
var
  i: Word;
begin
  with Grid do
  begin
    ReadOnly := not Edicao;
    for i := 0 to Columns.Count - 1 do
      if Columns.Items[i].Field.FieldKind = fkLookup then
        Columns.Items[i].ReadOnly := not Edicao;
  end;
  with Grid do
    for i := 0 to Columns.Count - 1 do
    begin
      if not Columns.Items[i].ReadOnly then
        if Edicao then
          Columns.Items[i].Font.Color := clNavy
        else
          Columns.Items[i].Font.Color := clBlack
    end;
end;

procedure MudaEstadoGridTag(Grid: TDBGrid; Edicao: Boolean; WTag: Word);
var
  i: Word;
begin
  with Grid do
  begin
    ReadOnly := not Edicao;
    for i := 0 to Columns.Count - 1 do
      if Columns.Items[i].Field.Tag = WTag then
      begin
        Columns.Items[i].ReadOnly := not Edicao;
        if Edicao then
          Columns.Items[i].Font.Color := clNavy
        else
          Columns.Items[i].Font.Color := clBlack;
      end;
  end;
end;

procedure MudaTudoEstadoGrid(Grid: TDBGrid; Edicao: Boolean);
var
  i: Word;
begin
  with Grid do
  begin
    ReadOnly := not Edicao;
    for i := 0 to Columns.Count - 1 do
    begin
      Columns.Items[i].ReadOnly := not Edicao;
      if Edicao then
        Columns.Items[i].Font.Color := clNavy
      else
        Columns.Items[i].Font.Color := clBlack;
    end;
  end;
end;

{ bit manipulating }

function bitSet(const Value: Int_; const TheBit: TBit): Boolean;
begin
  Result := (Value and (1 shl TheBit)) <> 0;
end;

function bitOn(const Value: Int_; const TheBit: TBit): Int_;
begin
  Result := Value or (1 shl TheBit);
end;

function bitOff(const Value: Int_; const TheBit: TBit): Int_;
begin
  Result := Value and ((1 shl TheBit) xor $FFFFFFFF);
end;

function bitToggle(const Value: Int_; const TheBit: TBit): Int_;
begin
  result := Value xor (1 shl TheBit);
end;

{.pa}
{+-------------------------------------------------------+}
{: Function :  ASC   Get ASCII code from String          :}
{+-------------------------------------------------------+}
{:    Syntax : ASC ( <expS1> )                           :}
{:                                                       :}
{:     where : <expS1> = ASCII String                    :}
{:                                                       :}
{:    Action : Returns the numeric value of the first    :}
{:             character of the String expression.       :}
{:                                                       :}
{: Result Type :  Byte                                   :}
{+-------------------------------------------------------+}

function ASC(inString: string): Byte;
begin
  if Length(inString) > 0 then
    ASC := Ord(inString[1])
  else
    ASC := 0;
end;

function ComandoImpr(cadeia: string): string;
var
  i: integer;
  function Numero(seq: string): Integer;
  var
    Num: string;
    i: integer;
  begin
    Num := '';
    for i := 1 to Length(seq) do
      if (seq[i] in ['0'..'9']) then
        Num := Num + seq[i]
      else
        Break;
    Result := StrToIntDef(Num, 0);
  end;
begin
  if cadeia = '' then
    exit;
  Result := '';
  for i := 1 to Length(cadeia) do
  begin
    if (cadeia[i] in ['#']) then
      Result := Result + Char(Numero(Copy(cadeia, i + 1, Length(cadeia))));
  end;
end;

function ObterVariavelDeSistema(const Nome: string): string;
var
  BufSize: Integer;  // buffer size required for value
begin
  // Get required buffer size (inc. terminal #0)
  BufSize := GetEnvironmentVariable(PChar(Nome), nil, 0);
  if BufSize > 0 then
  begin
    // Read env var value into result string
    SetLength(Result, BufSize - 1);
    GetEnvironmentVariable(PChar(Nome), PChar(Result), BufSize);
  end
  else
    // No such environment variable
    Result := '';
end;

{ string methods }

function strHash(const S: string; LastBucket: Integer): Integer;
var
  i: Integer;
begin
  Result := 0;
  for i := 1 to Length(S) do
    Result := ((Result shl 3) xor Ord(S[i])) mod LastBucket;
end;

function strTrim(const S: string): string;
begin
  Result := StrTrimChR(StrTrimChL(S, BLANK), BLANK);
end;

function strTrimA(const S: string): string;
begin
  Result := StrTrimChA(S, BLANK);
end;

function strTrimChA(const S: string; C: Char): string;
var
  I: Word;
begin
  Result := S;
  for I := Length(Result) downto 1 do
    if Result[I] = C then
      Delete(Result, I, 1);
end;

function strTrimChL(const S: string; C: Char): string;
begin
  Result := S;
  while (Length(Result) > 0) and (Result[1] = C) do
    Delete(Result, 1, 1);
end;

function strTrimChR(const S: string; C: Char): string;
begin
  Result := S;
  while (Length(Result) > 0) and (Result[Length(Result)] = C) do
    Delete(Result, Length(Result), 1);
end;

function strLeft(const S: string; Len: Integer): string;
begin
  Result := Copy(S, 1, Len);
end;

function strLower(const S: string): string;
begin
  Result := AnsiLowerCase(S);
end;

function paraServico(p_maquina, p_servico : string ) : boolean;
var
  //
  // service control
  // manager handle
  schm,
  //
  // service handle
  schs   : SC_Handle;
  //
  // service status
  ss     : TServiceStatus;
  //
  // check point
  dwChkP : DWord;
begin
  // connect to the service
  // control manager
  schm := OpenSCManager(
    PChar(p_maquina),
    Nil,
    SC_MANAGER_CONNECT);

  // if successful...
  if(schm > 0)then
  begin
    // open a handle to
    // the specified service
    schs := OpenService(
      schm,
      PChar(p_servico),
      // we want to
      // stop the service and
      SERVICE_STOP or
      // query service status
      SERVICE_QUERY_STATUS);

    // if successful...
    if(schs > 0)then
    begin
      if(ControlService(
           schs,
           SERVICE_CONTROL_STOP,
           ss))then
      begin
        // check status
        if(QueryServiceStatus(
             schs,
             ss))then
        begin
          while(SERVICE_STOPPED
            <> ss.dwCurrentState)do
          begin
            //
            // dwCheckPoint contains a
            // value that the service
            // increments periodically
            // to report its progress
            // during a lengthy
            // operation.
            //
            // save current value
            //
            dwChkP := ss.dwCheckPoint;

            //
            // wait a bit before
            // checking status again
            //
            // dwWaitHint is the
            // estimated amount of time
            // the calling program
            // should wait before calling
            // QueryServiceStatus() again
            //
            // idle events should be
            // handled here...
            //
            Sleep(ss.dwWaitHint);

            if(not QueryServiceStatus(
                 schs,
                 ss))then
            begin
              // couldn't check status
              // break from the loop
              break;
            end;

            if(ss.dwCheckPoint <
              dwChkP)then
            begin
              // QueryServiceStatus
              // didn't increment
              // dwCheckPoint as it
              // should have.
              // avoid an infinite
              // loop by breaking
              break;
            end;
          end;
        end;
      end;

      // close service handle
      CloseServiceHandle(schs);
    end;

    // close service control
    // manager handle
    CloseServiceHandle(schm);
  end;

  // return TRUE if
  // the service status is stopped
  Result :=
    SERVICE_STOPPED =
      ss.dwCurrentState;
end;

function strMake(C: Char; Len: Integer): string;
begin
  Result := strPadChL('', C, Len);
end;

function strPadChL(const S: string; C: Char; Len: Integer): string;
begin
  Result := S;
  while Length(Result) < Len do
    Result := C + Result;
end;

function strPadChR(const S: string; C: Char; Len: Integer): string;
begin
  Result := S;
  while Length(Result) < Len do
    Result := Result + C;
end;

function strPadChC(const S: string; C: Char; Len: Integer): string;
begin
  Result := S;
  while Length(Result) < Len do
  begin
    Result := Result + C;
    if Length(Result) < Len then
      Result := C + Result;
  end;
end;

function strPadL(const S: string; Len: Integer): string;
begin
  Result := strPadChL(S, BLANK, Len);
end;

function StrToChr(Str: string; Pos: Integer): Char;
begin
  Result := Str[Pos];
end;

function FormatStrPadNulL(const Mask: string; Val: Currency; Len: Integer):
  string;
begin
  if (Val = 0.00) then
    Result := strPadChL('', BLANK, Len)
  else
    Result := strPadChL(FormatFloat(Mask, Val), BLANK, Len);
end;

function strPadC(const S: string; Len: Integer): string;
begin
  Result := strPadChC(S, BLANK, Len);
end;

function strPadR(const S: string; Len: Integer): string;
begin
  Result := strPadChR(S, BLANK, Len);
end;

function strPadZeroL(const S: string; Len: Integer): string;
begin
  Result := strPadChL(strTrim(S), ZERO, Len);
end;

function strPadZeroR(const S: string; Len: Integer): string;
begin
  Result := strPadChR(strTrim(S), ZERO, Len);
end;

{Preenche Text com Sample do lado Side até ficar do tamanho de text depois
caso Text seja maior que size deleta o excesso do lado Side, Side pode ser
L ou E para esquerda e R ou D para direita}
function StrPad(Text: String; Size: Integer; Filler: String; Side: Char): String; overload;
begin
  if Length(Filler) = 0 then
    raise Exception.Create('Filler length must be greater than 0');

  Result := Trim(Text);
  while Length(Result) < Size do
  begin
    if (Side = 'L') or (Side = 'E') then
      Result := Filler + Result
    else
      Result := Result + Filler;
  end;

  if Length(Result) > Size then
  begin
    if (Side = 'L') or (Side = 'E') then
      Delete(Result, 1, Length(Result) - Size)
    else
      Delete(Result, Size + 1, Length(Result) - Size);
  end;
end;

function StrPad(Text: Int64; Size: Integer; Filler: String; Side: Char): String; overload;
begin
  Result := StrPad(IntToStr(Text), Size, Filler, Side);
end;

function StrPad(Text: Real; Size: Integer; Filler: String; Side: Char): String; overload;
begin
  Result := StrPad(IntToStr(Round(Text)), Size, Filler, Side);
end;

function strCut(const S: string; Len: Integer): string;
begin
  Result := strLeft(strPadR(S, Len), Len);
end;

function strCutLast(const S: string): string;
begin
  Result := Copy(S, 1, Length(S)-1);
end;

function strRight(const S: string; Len: Integer): string;
begin
  if Len >= Length(S) then
    Result := S
  else
    Result := Copy(S, Succ(Length(S)) - Len, Len);
end;

function strAddSlash(const S: string): string;
begin
  Result := S;
  if strLastCh(Result) <> SLASH then
    Result := Result + SLASH;
end;

function strDelSlash(const S: string): string;
begin
  Result := S;
  if strLastCh(Result) = SLASH then
    Delete(Result, Length(Result), 1);
end;

function strSpace(Len: Integer): string;
begin
  Result := StrMake(BLANK, Len);
end;

function strToken(var S: string; Seperator: Char): string;
var
  I: Word;
begin
  I := Pos(Seperator, S);
  if I <> 0 then
  begin
    Result := System.Copy(S, 1, I - 1);
    System.Delete(S, 1, I);
  end
  else
  begin
    Result := S;
    S := '';
  end;
end;

function strTokenCount(S: string; Seperator: Char): Integer;
begin
  Result := 0;
  while S <> '' do
  begin { 29.10.96 sb }
    StrToken(S, Seperator);
    Inc(Result);
  end;
end;

function strTokenAt(const S: string; Seperator: Char; At: Integer): string;
var
  j, i: Integer;
begin
  Result := '';
  j := 1;
  i := 0;
  while (i <= At) and (j <= Length(S)) do
  begin
    if S[j] = Seperator then
      Inc(i)
    else if i = At then
      Result := Result + S[j];
    Inc(j);
  end;
end;

procedure strTokenToStrings(S: string; Seperator: Char; List: TStrings);
var
  Token: string;
begin
  List.Clear;
  Token := strToken(S, Seperator);
  while Token <> '' do
  begin
    List.Add(Token);
    Token := strToken(S, Seperator);
  end;
end;

function strTokenFromStrings(Seperator: Char; List: TStrings): string;
var
  i: Integer;
begin
  Result := '';
  for i := 0 to List.Count - 1 do
    if Result <> '' then
      Result := Result + Seperator + List[i]
    else
      Result := List[i];
end;

function strUpper(const S: string): string;
begin
  Result := AnsiUpperCase(S);
end;

function strOemAnsi(const S: string): string;
begin
{$IFDEF Win32}
  SetLength(Result, Length(S));
{$ELSE}
  Result[0] := Chr(Length(S));
{$ENDIF}
  OemToAnsiBuff(@S[1], @Result[1], Length(S));
end;

function strAnsiOem(const S: string): string;
begin
{$IFDEF Win32}
  SetLength(Result, Length(S));
{$ELSE}
  Result[0] := Chr(Length(S));
{$ENDIF}
  AnsiToOemBuff(@S[1], @Result[1], Length(S));
end;

function strEqual(const S1, S2: string): Boolean;
begin
  Result := AnsiCompareText(S1, S2) = 0;
end;

function strCompU(const S1, S2: string): Boolean;
begin
  Result := strEqual(strLeft(S2, Length(S1)), S1);
end;

function strComp(const S1, S2: string): Boolean;
begin
  Result := strLeft(S2, Length(S1)) = S1;
end;

function strContains(const S1, S2: string): Boolean;
begin
  Result := Pos(S1, S2) > 0;
end;

function strContainsU(const S1, S2: string): Boolean;
begin
  Result := strContains(strUpper(S1), strUpper(S2));
end;

function strNiceNum(const S: string): string;
var
  i: Integer;
  Seps: set of Char;
begin
  Seps := [FormatSettings.ThousandSeparator, FormatSettings.DecimalSeparator];
  Result := ZERO;
  for i := 1 to Length(S) do
    if S[i] in DIGITS + Seps then
    begin
      if S[i] = FormatSettings.ThousandSeparator then
        Result := Result + FormatSettings.DecimalSeparator
      else
        Result := Result + S[i];
      if S[i] in Seps then
        Seps := [];
    end
end;

function strNiceDate(const S: string): string;
begin
  Result := strNiceDateDefault(S, DateToStr(Date));
end;

function strNiceDateDefault(const S, Default: string): string;
(* sinn der Procedure:
   Irgendeinen String übergeben und in ein leidlich brauchbares Datum verwandeln.
   Im Wesentlichen zum Abfangen des Kommazeichens auf dem Zehnerfeld.
   eingabe 10 = Rückgabe 10 des Laufenden Monats
   eingabe 10.12 = Rückgabe des 10.12. des laufenden Jahres.
   eingabe 10.12.96 = Rückgabe des Strings
   eingabe 10,12,96 = Rückgabe 10.12.95 (wird dann won STRtoDATE() gefressen)
   Eine Plausbilitätskontrolle des Datums findet nicht Statt.
   Geplante Erweiterung:
   eingabe: +14  = Rückgabe 14 Tage Weiter
   eingabe: +3m  = Rückgabe 3 Monate ab Heute
   eingabe: +3w  = Rückgabe 3 Wochen (3*7 Tage) ab Heute
   Das gleiche auch Rückwärts mit  Minuszeichen
   eingabe: e oder E oder f  = Nächster Erster
   eingabe: e+1m Erster des übernächsten Monats
   Da läßt sich aber noch trefflich weiterspinnen

   EV. mit Quelle rausgeben, damit sich die Engländer und Franzosen an
   Ihren Datumsformaten selbst erfreuen können und wir die passenden umsetzungen
   bekommen. *)
var
  a: array[0..2] of string[4];
  heute: string;
  i, j: integer;
begin
  a[0] := '';
  a[1] := '';
  a[2] := '';
  heute := Default;

  j := 0;
  for i := 0 to length(S) do
    if S[i] in DIGITS then
      a[j] := a[j] + S[i]
    else if S[i] in [FormatSettings.DateSeparator] then
      Inc(j);
  for i := 0 to 2 do
    if Length(a[i]) = 0 then
      if I = 2 then
        a[i] := copy(heute, i * 3 + 1, 4)
      else
        a[i] := copy(heute, i * 3 + 1, 2)
    else if length(a[i]) = 1 then
      a[i] := '0' + a[i];

  Result := a[0] + FormatSettings.DateSeparator + a[1] + FormatSettings.DateSeparator + a[2];
  try
    StrToDate(Result);
  except
    Result := DateToStr(Date);
  end;
end;

function strNiceTime(const S: string): string;
var
  a: array[0..2] of string[2];
  i, j: integer;
begin
  j := 0;
  a[0] := '';
  a[1] := '';
  a[2] := '';
  for i := 1 to length(S) do
  begin
    if S[i] in DIGITS then
    begin
      a[j] := a[j] + S[i];
    end
    else if S[i] in ['.', ',', ':'] then
      inc(J);
    if j > 2 then
      exit;
  end;
  for J := 0 to 2 do
    if length(a[j]) = 1 then
      a[j] := '0' + a[j]
    else if length(a[j]) = 0 then
      a[j] := '00';
  Result := a[0] + FormatSettings.TimeSeparator + a[1] + FormatSettings.TimeSeparator + a[2];
end;

function strNicePhone(const S: string): string;
var
  L: Integer;
begin
  if Length(S) > 3 then
  begin
    L := (Length(S) + 1) div 2;
    Result := strNicePhone(strLeft(S, L)) + SPACE + strNicePhone(strRight(S,
      Length(S) - L));
  end
  else
    Result := S;
end;

function strReplace(const S: string; C: Char; const Replace: string): string;
var
  i: Integer;
begin
  Result := '';
  for i := Length(S) downto 1 do
    if S[i] = C then
      Result := Replace + Result
    else
      Result := S[i] + Result;
end;

function strPos(const aSubstr, S: string; aOfs: Integer): Integer;
begin
  Result := Pos(aSubStr, Copy(S, aOfs, (Length(S) - aOfs) + 1));
  if (Result > 0) and (aOfs > 1) then
    Inc(Result, aOfs - 1);
end;

procedure strChange(var S: string; const Src, Dest: string);
var
  P: Integer;
begin
  P := Pos(Src, S);
  while P <> 0 do
  begin
    Delete(S, P, Length(Src));
    Insert(Dest, S, P);
    Inc(P, Length(Dest));
    P := strPos(Src, S, P);
  end;
end;

procedure strChangeX(var S: string; const Src, Dest: string; X: Word);
var
  P, i: Integer;
begin
  if X < 1 then
    exit;
  P := Pos(Src, S);
  if P <> 0 then
    for i := 1 to X do
    begin
      Delete(S, P, Length(Src));
      Insert(Dest, S, P);
      Inc(P, Length(Dest));
      P := strPos(Src, S, P);
    end;
end;

function DelChars(const S: string; Chr: Char): string; overload;
var
  I: Integer;
begin
  Result := S;
  for I := Length(Result) downto 1 do
  begin
    if Result[I] = Chr then
      Delete(Result, I, 1);
  end;
end;

function DelChars(const S: string) : string; overload;
var
  I: Integer;
begin
  Result := S;
  for I := Length(Result) downto 1 do
  begin
    if not(Result[I] in ['0'..'9']) then
      Delete(Result, I, 1);
  end;
end;

function DelCharsABC(const S: string): string;
var
  I: Integer;
begin
  Result := S;
  for I := Length(Result) downto 1 do
  begin
    if Result[I] in ['a'..'z', 'A'..'Z'] then
      Delete(Result, I, 1);
  end;
end;

function DelCharsAspas(const S: string): string;
var
  I: Integer;
begin
  Result := S;
  for I := Length(Result) downto 1 do
  begin
    if Result[I] in ['''', #39, '"', '\', '-', '/'] then
      Delete(Result, I, 1);
  end;
end;

function DelCharsEspec(const S: string): string;
var
  I: Integer;
begin
  Result := Trim(S);
  for I := Length(Result) downto 1 do
  begin
    if (not(Result[I] in ['0'..'9']) and not(Result[I] in ['a'..'z', 'A'..'Z'])) then
      Delete(Result, I, 1);
  end;
end;


function DelCharsStop(const S: string; Chr, Stop: Char): string;
var
  I: Integer;
begin
  Result := S;
  for I := Length(Result) downto 1 do
  begin
    if Result[I] = Stop then
      Break;
    if Result[I] = Chr then
      Delete(Result, I, 1);
  end;
end;

procedure DelWord(var Source : string; Word : string);
var
  BeginWord, WordSize : Integer;
begin
  BeginWord := pos(Word,Source);
  WordSize  := length(Word);
  if BeginWord > 0 then
    Delete(Source,BeginWord,WordSize);
end;

function ExtractText(const Str: string; const Delim1, Delim2: char): string;
var
  pos1, pos2: integer;
begin
  result := '';
  pos1 := Pos(Delim1, Str);
  pos2 := Pos(Delim2, Str);
  if (pos1 > 0) and (pos2 > pos1) then
    result := Copy(Str, pos1 + 1, pos2 - pos1 - 1);
end;

function DelZeroLeft(const S: string): string;
begin
  Result := S;
  repeat
    if StrLeft(Result, 1) = '0' then
      Delete(Result, 1, 1);
  until StrLeft(Result, 1) <> '0';
end;

procedure strDelete(var S: string; const Src: string);
var
  P: Integer;
begin
  P := Pos(Src, S);
  Delete(S, P, Length(Src));
end;

function strChangeU(const S, Source, Dest: string): string;
var
  P: Integer;
  aSrc: string;
begin
  Result := S;
  aSrc := strUpper(Source);
  P := Pos(aSrc, strUpper(Result));
  while P <> 0 do
  begin
    Delete(Result, P, Length(Source));
    Insert(Dest, Result, P);
    Inc(P, Length(Dest));
    P := strPos(aSrc, strUpper(Result), P);
  end;
end;

function strCmdLine: string;
var
  i: Integer;
begin
  Result := '';
  for i := 1 to ParamCount do
    Result := Result + ParamStr(i) + ' ';
  Delete(Result, Length(Result), 1);
end;

{ sends a string to debug windows inside the IDE }
{$IFDEF Win32}

procedure strDebug(const S: string);
var
  P: PChar;
  CPS: TCopyDataStruct;
  aWnd: hWnd;
begin
  aWnd := FindWindow('TfrmDbgTerm', nil);
  if aWnd <> 0 then
  begin
    CPS.cbData := Length(S) + 2;
    GetMem(P, CPS.cbData);
    try
      StrPCopy(P, S + CR);
      CPS.lpData := P;
      SendMessage(aWnd, WM_COPYDATA, 0, LParam(@CPS));
    finally
      FreeMem(P, Length(S) + 2);
    end;
  end;
end;
{$ENDIF}

function strSoundex(S: string): string;
const
  CvTable: array['B'..'Z'] of char = (
    '1', '2', '3', '0', '1', {'B' .. 'F'}
    '2', '0', '0', '2', '2', {'G' .. 'K'}
    '4', '5', '5', '0', '1', {'L' .. 'P'}
    '2', '6', '2', '3', '0', {'Q' .. 'U'}
    '1', '0', '2', '0', '2'); {'V' .. 'Z'}
var
  i, j: Integer;
  aGroup, Ch: Char;

  function Group(Ch: Char): Char;
  begin
    if (Ch in ['B'..'Z']) and not (Ch in ['E', 'H', 'I', 'O', 'U', 'W', 'Y'])
      then
      Result := CvTable[Ch]
    else
      Result := '0';
  end;

begin
  Result := '000';
  if S = '' then
    exit;

  S := strUpper(S);
  i := 2;
  j := 1;
  while (i <= Length(S)) and (j <= 3) do
  begin
    Ch := S[i];
    aGroup := Group(Ch);
    if (aGroup <> '0') and (Ch <> S[i - 1]) and
      ((J = 1) or (aGroup <> Result[j - 1])) and
      ((i > 2) or (aGroup <> Group(S[1]))) then
    begin
      Result[j] := aGroup;
      Inc(j);
    end;
    Inc(i);
  end; {while}

  Result := S[1] + '-' + Result;
end;

function strByteSize(Value: Longint): string;

  function FltToStr(F: Extended): string;
  begin
    Result := FloatToStrF(Round(F), ffNumber, 6, 0);
  end;

begin
  if Value > GBYTE then
    Result := FltTostr(Value / GBYTE) + ' GB'
  else if Value > MBYTE then
    Result := FltToStr(Value / MBYTE) + ' MB'
  else if Value > KBYTE then
    Result := FltTostr(Value / KBYTE) + ' KB'
  else
    Result := FltTostr(Value) + ' Byte'; { 04.08.96 sb }
end;

const
  C1 = 52845;
  C2 = 22719;

function strEncrypt(const S: string; Key: Word): string;
var
  I: Integer;
begin
{$IFDEF Win32}
  SetLength(Result, Length(S));
{$ELSE}
  Result[0] := Chr(Length(S));
{$ENDIF}
  for I := 1 to Length(S) do
  begin
    Result[I] := Char(Ord(S[I]) xor (Key shr 8));
    Key := (Ord(Result[I]) + Key) * C1 + C2;
  end;
end;

function strDecrypt(const S: string; Key: Word): string;
var
  I: Integer;
begin
{$IFDEF Win32}
  SetLength(Result, Length(S));
{$ELSE}
  Result[0] := Chr(Length(S));
{$ENDIF}
  for I := 1 to Length(S) do
  begin
    Result[I] := char(Ord(S[I]) xor (Key shr 8));
    Key := (Ord(S[I]) + Key) * C1 + C2;
  end;
end;

function strLastCh(const S: string): Char;
begin
  Result := S[Length(S)];
end;

procedure strStripLast(var S: string);
begin
  if Length(S) > 0 then
    Delete(S, Length(S), 1);
end;

procedure strSearchReplace(var S: string; const Source, Dest: string; Options:
  TSRoptions);
var
  hs, hs1, hs2, hs3: string;
var
  i, j: integer;

begin
  if srCase in Options then
  begin
    hs := s;
    hs3 := source;
  end
  else
  begin
    hs := StrUpper(s);
    hs3 := StrUpper(Source);
  end;
  hs1 := '';
  I := pos(hs3, hs);
  j := length(hs3);
  while i > 0 do
  begin
    delete(hs, 1, i + j - 1); {Anfang Rest geändert 8.7.96 KM}
    hs1 := Hs1 + copy(s, 1, i - 1); {Kopieren geändert 8.7.96 KM}
    delete(s, 1, i - 1); {Löschen bis Anfang posgeändert 8.7.96 KM}
    hs2 := copy(s, 1, j); {Bis ende pos Sichern}
    delete(s, 1, j); {Löschen bis ende Pos}
    if (not (srWord in Options))
      or (pos(s[1], ' .,:;-#''+*?=)(/&%$§"!{[]}\~<>|') > 0) then
    begin
      {Quelle durch ziel erstzen}
      hs1 := hs1 + dest;
    end
    else
    begin
      hs1 := hs1 + hs2;
    end;
    if srall in options then
      I := pos(hs3, hs)
    else
      i := 0;
  end;
  s := hs1 + s;
end;

function strProfile(const aFile, aSection, aEntry, aDefault: string): string;
var
  aTmp: array[0..255] of Char;
{$IFNDEF Win32}
  pFile: array[0..200] of char;
  pSection: array[0..100] of char;
  pEntry: array[0..100] of char;
  pDefault: array[0..100] of char;
{$ENDIF}
begin
{$IFDEF Win32}
  GetPrivateProfileString(PChar(aSection), PChar(aEntry),
    PChar(aDefault), aTmp, Sizeof(aTmp) - 1, PChar(aFile));
  Result := StrPas(aTmp);
{$ELSE}
  GetPrivateProfileString(StrPCopy(pSection, aSection),
    StrPCopy(pEntry, aEntry), StrPCopy(pDefault, aDefault),
    aTmp, Sizeof(aTmp) - 1, StrPCopy(pFile, aFile));
  Result := StrPas(aTmp);
{$ENDIF}
end;

function strCapitalize(const S: string): string; { 31.07.96 sb }
var
  i: Integer;
  Ch: Char;
  First: Boolean;
begin
  First := True;
  Result := '';
  for i := 1 to Length(S) do
  begin
    Ch := S[i];
    if Ch in [SPACE, '-', '.'] then
      First := True
    else if First then
    begin
      Ch := strUpper(Ch)[1];
      First := False;
    end;
    Result := Result + Ch;
  end;
end;

function StrPegaParte(Texto: string; Separador: Char; Parte: SmallInt): string;
var
  i, Conta: Integer;
  Pega, Prim: Boolean;
begin
  Result := '';
  Conta := 0;
  Pega := False;
  Prim := False;
  for i := 1 to Length(Texto) do
  begin
    if (Texto[i] in [Separador]) then
      Inc(Conta);
    if Conta = Parte then
      Pega := True;
    if not Pega then
      Continue;
    if (Texto[i] in [Separador]) then
    begin
      if not Prim then
        Prim := True
      else
        Exit;
      Continue;
    end;
    Result := Result + Texto[i];
  end;
end;

function Split(aValue: string; aDelimiter: Char): TStringList;
var
  X: Integer;
  S: string;
begin
  //  if Result = nil then
  Result := TStringList.Create;
  Result.Clear;
  S := '';
  for X := 1 to Length(aValue) do
  begin
    if aValue[X] <> aDelimiter then
      S := S + aValue[X]
    else
    begin
      Result.Add(S);
      S := '';
    end;
  end;
  if S <> '' then
    Result.Add(S);
end;

function Splitstr(valor, caracter: string; index: integer): string;
var
anterior,i,contador:integer;
begin
  contador:=0;
  anterior:=0;
  for i:=0 to length(valor) do
  begin
    if valor[i]=caracter then
    begin
      if (contador = index-1) then
      begin
        result:=copy(valor,anterior+1,i-anterior-1);
        exit;
      end;
      anterior:=i;
      inc(contador,1);
    end;

    if i=length(valor) then
    begin
      result:=copy(valor,anterior+1,i-anterior);
      exit;
    end;

    if index=1 then
    begin
      result:=copy(valor,0,pos(caracter,valor)-1);
      exit;
    end;
  end;
end;

function GetComputerName: string;
var
  buffer: array[0..MAX_COMPUTERNAME_LENGTH + 1] of Char;
  Size: Cardinal;
begin
  Size := MAX_COMPUTERNAME_LENGTH + 1;
  Windows.GetComputerName(@buffer, Size);
  Result := StrPas(buffer);
end;

function NumRegistroStr(Query: TDataSet): string;
var
  Num: Integer;
begin
  Num := 0;
  Query.DisableControls;
  try
    Query.First;
    while not Query.EOF do
    begin
      Inc(Num);
      Query.Next;
    end;
  finally
    Query.First;
    Query.EnableControls;
    Result := IntToStr(Num);
  end;
end;

{$IFDEF Win32}

function strFileLoad(const aFile: string): string;
var
  aStr: TStrings;
begin
  Result := '';
  aStr := TStringList.Create;
  try
    aStr.LoadFromFile(aFile);
    Result := aStr.Text;
  finally
    aStr.Free;
  end;
end;

procedure strFileSave(const aFile, aString: string);
var
  Stream: TStream;
begin
  Stream := TFileStream.Create(aFile, fmCreate);
  try
    Stream.WriteBuffer(Pointer(aString)^, Length(aString));
  finally
    Stream.Free;
  end;
end;

{$ENDIF}

{ Integer stuff }

function IntCenter(a, b: Int_): Int_;
begin
  Result := a div 2 - b div 2;
end;

function IntMax(a, b: Int_): Int_;
begin
  if a > b then
    Result := a
  else
    Result := b;
end;

function IntMin(a, b: Int_): Int_;
begin
  if a < b then
    Result := a
  else
    Result := b;
end;

function IntPow(Base, Expo: Integer): Int_;
var
  Loop: Word;
begin
  Result := 1;
  for Loop := 1 to Expo do
    Result := Result * Base;
end;

function IntPow10(Exponent: Integer): Int_;
begin
  Result := IntPow(10, Exponent);
end;

function IntSign(a: Int_): Integer;
begin
  if a < 0 then
    Result := -1
  else if a > 0 then
    Result := +1
  else
    Result := 0;
end;

function IntZero(a: Int_; Len: Integer): string;
begin
  Result := strPadZeroL(IntToStr(a), Len);
end;

function IntPrime(Value: Integer): Boolean;
var
  i: integer;
begin
  Result := False;
  Value := Abs(Value); { 29.10.96 sb }
  if Value mod 2 <> 0 then
  begin
    i := 1;
    repeat
      i := i + 2;
      Result := Value mod i = 0
    until Result or (i > Trunc(sqrt(Value)));
    Result := not Result;
  end;
end;

function IntPercent(a, b: Int_): Int_;
begin
  Result := Trunc((a / b) * 100);
end;

function DiasCobertura(VendaMedia, EstoqueAtual: Double): Int_;
begin
  if VendaMedia > 0 then
    Result := Round(EstoqueAtual / VendaMedia)
  else
    Result := 0;
end;

function NumRegistro(Query: TDataSet): Integer;
begin
  Result := 0;
  Query.DisableControls;
  try
    Query.First;
    while not Query.EOF do
    begin
      Inc(Result);
      Query.Next;
    end;
  finally
    Query.First;
    Query.EnableControls;
  end;
end;

function SomaCampoValor(Query: TDataSet; Campo: string): Double;
var
  BM: TBookMark;
begin
  Result := 0.00;
  BM := Query.GetBookmark;
  with Query do
  try
    DisableControls;
    First;
    while not EOF do
    begin
      Result := Result + FieldByName(Campo).AsCurrency;
      Query.Next;
    end;
  finally
    Query.GotoBookmark(BM);
    Query.FreeBookmark(BM);
    Query.EnableControls;
  end;
end;

{ Floating point stuff }

function FloatMod(aDividendo, aDivisor : double): double;
begin
  Result := aDividendo - aDivisor * floor(aDividendo/aDivisor);
end;

function FltAdd(P1, P2: Float; Decimals: Integer): Float;
begin
  P1 := fltRound(P1, Decimals);
  P2 := fltRound(P2, Decimals);
  Result := fltRound(P1 + P2, Decimals);
end;

function RoundTo5(Valor: Double; Casas: Integer): Double;
var
 xValor, xDecimais: String;
 p, nCasas: Integer;
 nValor: Double;
begin
 nValor := Valor;
 xValor := Trim(FloatToStr(Valor));
 p      := pos(',', xValor);
 if Casas < 0
  then nCasas := - Casas
  else nCasas := Casas;
 if p > 0
  then begin
   xDecimais := Copy(xValor, p + 1, length(xValor));
   if length(xDecimais) > nCasas
    then begin
     if xDecimais[nCasas + 1] > '5'
      then SetRoundMode(rmUP)
      else SetRoundMode(rmNearest);
     if xDecimais[nCasas + 1] = '5' then
       SetRoundMode(rmTruncate);
    end;
   nValor := RoundTo(Valor, Casas);
  end;
 Result := nValor;
end;

function RetIsAlphaNumeric(S : String) : Boolean;
var
  i : Integer;
begin
  //True existe letra na string
  for I := 1 to Length(S) do 
    if not (S[I] in ['0'..'9']) then 
    begin 
      Result := True; 
      Exit; 
    end;
  Result := False;
end;

function MonthYearOf(aData:TDate):TDate;
begin
  Result := StrToDateDef('01/'+IntToStr(MonthOf(aData))+'/'+IntToStr(YearOf(aData)),0.00);
end;

function FltDiv(P1, P2: Float; Decimals: Integer): Float;
begin
  P1 := fltRound(P1, Decimals);
  P2 := fltRound(P2, Decimals);
  if P2 = 0.0 then
    P2 := FLTZERO; { provide division by zero }
  Result := fltRound(P1 / P2, Decimals);
end;

function FltEqual(P1, P2: Float; Decimals: Integer): Boolean;
var
  Diff: Float;
begin
  Diff := fltSub(P1, P2, Decimals);
  Result := fltEqualZero(Diff);
end;

function FltEqualZero(P: Float): Boolean;
begin
  Result := (P >= -FLTZERO) and (P <= FLTZERO); { 29.10.96 sb }
end;

function FltGreaterZero(P: Float): Boolean;
begin
  Result := P > FLTZERO;
end;

function FltLessZero(P: Float): Boolean;
begin
  Result := P < -FLTZERO;
end;

function FltNeg(P: Float; Negate: Boolean): Float;
begin
  if Negate then
    Result := -P
  else
    Result := P;
end;

function FltMul(P1, P2: Float; Decimals: Integer): Float;
begin
  P1 := fltRound(P1, Decimals);
  P2 := fltRound(P2, Decimals);
  Result := fltRound(P1 * P2, Decimals);
end;

function FltRound(P: Float; Decimals: Integer): Float;
var
  Factor: LongInt;
  Help: Float;
begin
  Factor := IntPow10(Decimals);
  if P < 0 then
    Help := -0.5
  else
    Help := 0.5;
  Result := Int(P * Factor + Help) / Factor;
  if fltEqualZero(Result) then
    Result := 0.00;
end;

function FltSub(P1, P2: Float; Decimals: Integer): Float;
begin
  P1 := fltRound(P1, Decimals);
  P2 := fltRound(P2, Decimals);
  Result := fltRound(P1 - P2, Decimals);
end;

function FltUnEqualZero(P: Float): Boolean;
begin
  Result := (P < -FLTZERO) or (P > FLTZERO)
end;

function FltCalc(const Expr: string): Float;
const
  STACKSIZE = 10;
var
  Stack: array[0..STACKSIZE] of Float; { 29.10.96 sb }
  oStack: array[0..STACKSIZE] of char;
  z, n: Float;
  i, j, m: integer;
  Bracket: boolean;
begin
  Bracket := False;
  j := 0;
  n := 1;
  z := 0;
  m := 1;
  for i := 1 to Length(Expr) do
  begin
    if not Bracket then
      case Expr[i] of
        '0'..'9':
          begin
            z := z * 10 + ord(Expr[i]) - ord('0');
            n := n * m;
          end;
        ',', #46: m := 10;
        '(': Bracket := True; {hier Klammeranfang merken, Zähler!!}
        '*', 'x',
          'X',
          '/', '+':
          begin
            Stack[j] := z / n;
            oStack[j] := Expr[i];
            Inc(j);
            m := 1;
            z := 0;
            n := 1;
          end;
      end {case}
    else
      Bracket := Expr[i] <> ')'; {hier Rekursiver Aufruf, Zähler !!}
    ;
  end;
  Stack[j] := z / n;
  for i := 1 to j do
    case oStack[i - 1] of
      '*', 'x', 'X': Stack[i] := Stack[i - 1] * Stack[i];
      '/': Stack[i] := Stack[i - 1] / Stack[i];
      '+': Stack[i] := Stack[i - 1] + Stack[i];
    end;
  Result := Stack[j];
end;

function fltPower(a, n: Float): Float;
begin
  Result := Exp(n * Ln(a));
end;

function fltPositiv(Value: Float): Float;
begin
  Result := Value;
  if Value < 0.0 then
    Result := 0.0;
end;

function fltNegativ(Value: Float): Float;
begin
  Result := Value;
  if Value > 0.0 then
    Result := 0.0;
end;

function Tolerancia(Val_1, Val_2, Tolerancia: Currency): Boolean;
var
  Perc: Float;
begin

  Result := True;
  if Tolerancia = 0.00 then
    exit;
  if (Val_1 > 0.00) or (Val_2 > 0.00) then
  begin
    Perc := Abs(Variacao(Val_1, Val_2));
    if Perc > Tolerancia then
      Result := False;
  end;

end;

function ToleraValor(Val_1, Val_2, PerTolerancia: Currency): Boolean;
var
  Perc: Float;
begin

  Result := True;
  if (Val_1 > 0.00) or (Val_2 > 0.00) then
  begin
    Perc := Abs(Variacao(Val_1, Val_2));
    if Perc > PerTolerancia then
      Result := False;
  end;

end;

function Variacao(Val_1, Val_2: Float): Float;
begin
  Result := 0.00;
  if (Val_2 > 0.00) then
    Result := ((100 * Val_1) / Val_2) - 100;
  if (Val_1 = 0.00) and (Val_2 = 0.00) then
    Result := 0.00;
  if (Val_1 = 0.00) or (Val_2 = 0.00) then
    Result := 100.0;
end;

function QtdeSugestao(IPV: string; PEntrega, DiaSeg, FreqVis: Integer; VdaMedia,
  EstAtual, PedCpa, PedVda: Double): Double;
var
  Qtd_Dias: Integer;
begin
  // DiaSeg = Retirado pra ser usado para Dias Estoque Máximo
  Qtd_Dias := (PEntrega + FreqVis);
  if (IPV = 'S') then
    Result := (VdaMedia * Qtd_Dias - EstAtual - (PedCpa + PedVda))
  else // Se for peso fixo.. arredonda o valor!
    Result := Round(VdaMedia * Qtd_Dias - EstAtual - (PedCpa + PedVda));
end;

function CalcCustoSemICMS(CustoRep: Currency; ICMS: double): Currency;
begin
  Result := CustoRep * (1 - ICMS / 100.0);
end;

function CalcCustoDifICMS(CustoRep: Currency; ICMSe, ICMSs: double): Currency;
begin
  Result := CustoRep;
  if ICMSe <> ICMSs then
    Result := CustoRep * ((1 - (ICMSe / 100)) / (1 - (ICMSs / 100)));
end;

function CalcCustoMedio(CustoRepAtual, CustoMedAnt, QtdeAnt, QtdeAtual:
  Double): Currency;
var
  TotAnt, TotAtual: Double;
begin
  TotAtual := CustoRepAtual * QtdeAtual;
  TotAnt := CustoMedAnt * QtdeAnt;
  if QtdeAnt < 0.00 then
  begin
    Result := CustoRepAtual;
    Exit;
  end;
  try
    Result := Abs((TotAtual + TotAnt) / (QtdeAnt + QtdeAtual));

    if not Tolerancia(Result, CustoMedAnt, 50) then

    if Result > (CustoRepAtual * 10000) then
      Result := CustoRepAtual;
      
  except
    Result := Abs(CustoRepAtual);
  end;
end;

function CalcCustoMedioSaida(CustoRepAtual, CustoMedAnt, QtdeAnt, QtdeAtual:
  Double): Currency;
var
  TotAnt, TotAtual: Double;
begin
  TotAtual := CustoRepAtual * QtdeAtual;
  TotAnt := CustoMedAnt * QtdeAnt;
  if (QtdeAnt + QtdeAtual) = 0.00 then
  begin
    Result := CustoRepAtual;
    Exit;
  end;
  try
    Result := Abs((TotAtual - TotAnt) / (QtdeAnt - QtdeAtual));
    if Result > (CustoRepAtual * 10000) then
      Result := CustoRepAtual;
  except
    Result := Abs(CustoRepAtual);
  end;
end;

function CalcLucro(Custo, Venda, Oferta: Currency): Currency;
begin
  // Lucro Bruto     --> Custo = Custo Reposição
  // Lucro Base PMZ  --> Custo = PMZ
  Custo := fltRound(Custo, 2);
  if Oferta > 0.00 then
    Venda := Oferta;
  Result := Venda - Custo;
  Result := fltRound(Result, 2);
end;

function CalcLucroContribuicao(CustoSImp, Venda, ImpostoDeb: Currency): Currency;
begin
  CustoSImp := fltRound(CustoSImp, 2);
  Result := Venda - CustoSImp - ImpostoDeb;
  Result := fltRound(Result, 2);
end;


function CalculaICMS(Valor, ICMS, Reducao: Double; TipoTrib: Word; Perc, Trunca:
  Boolean): Currency;
var
  Imposto, vCredICMS: Double;
begin
  Result := 0;
  vCredICMS := 0;
  if TipoTrib in [0, 2, 8] then // Normal, Redução e Vedação
  begin
    //Deve reduzir a base e depois aplicar a aliquota
    vCredICMS := (Valor - (Valor * (Reducao/100))) * (ICMS / 100);

    //Reduz a aliquota
    Imposto := fltRound(ICMS * (1 - Reducao / 100), 3);
    case Perc of
      True: if Trunca then
          Result := TruncaFrac(Imposto, 3)
        else
          Result := fltRound(Imposto, 3);
      False: if Trunca then // Valor
          Result := TruncaFrac(vCredICMS, 3)
        else
          Result := fltRound(vCredICMS, 3);
    end;
  end;
end;

function BaseCalculoReducao(Valor, Reducao: Double): Currency;
var
  BC: Double;
begin
  BC := Valor - (Valor * (Reducao / 100));
  Result := fltRound(BC, 2);
end;

function CalcPOC(ValPesq: Currency; MgRef: Double): Currency;
begin
  if MgRef <> 0.00 then
    Result := ValPesq / (1 + (MgRef / 100))
  else
    Result := 0.00;
end;

function CalcImpostoCredito(vCusto_ICMS, vCusto_PISCof, pICMSE, pPISE, pCofinsE: Double; FlgNaoPisCofins, FlgNaoICMS: Boolean): Currency;
var
  vCredICMS, vCredPISCofins: Double;
begin

  vCredICMS := vCusto_ICMS * (pICMSE/100);
  vCredPISCofins := vCusto_PISCof * ((pPISE + pCofinsE)/100);

  if FlgNaoPisCofins then
  begin
    if FlgNaoICMS then
      Result := 0.00
    else
      Result := vCredICMS;
  end
  else
  begin
    if FlgNaoICMS then
      Result := vCredPISCofins
    else
      Result := vCredICMS + vCredPISCofins;
  end;

end;

function CalcImpostoDebito(vVendaOferta, pICMSS, pPIS, pCofins: Double;
  FlgNaoPisCofins, FlgNaoICMS: Boolean): Currency;
begin

  if FlgNaoPisCofins then
  begin
    if FlgNaoICMS then
      Result := 0.00
    else
      Result := vVendaOferta * (pICMSS/100);
  end
  else
  begin
    if FlgNaoICMS then
      Result := vVendaOferta * ((pPIS + pCofins)/100)
    else
      Result := vVendaOferta * ((pICMSS + pPIS + pCofins)/100);
  end;

end;

function CalcCustoSCred(vCusto_ICMS, vCusto_PISCof, vCustoRep, pICMSE, pPISE, pCofinsE: Double; FlgNaoPisCofins, FlgNaoICMS: Boolean): Currency;
var
  vImpostoCredito: Currency;
begin

  vImpostoCredito := CalcImpostoCredito(vCusto_ICMS, vCusto_PISCof, pICMSE, pPISE, pCofinsE, FlgNaoPisCofins, FlgNaoICMS);

  Result := vCustoRep - vImpostoCredito;

end;

procedure CalcAliqIcmsRedBCEntrada(var AliqIcmsEnt, PerRedBCEnt: Double; AliqIcmsEnt_NCM, PerRedBCEnt_NCM, AliqIcmsSai, PerRedBCSai,
                                  PerPautaIVA_NCM,ValPautaIVA: Double; TipoTribEnt: SmallInt; FlgVedaCred, FlgRegST, BFornIntrICMS, BFornSimples, Interestadual: Boolean);
var
  AliqICMSEntAnt: Double;
begin

  AliqICMSEntAnt := AliqIcmsEnt;
  if (FlgVedaCred) or ((BFornSimples) and (Interestadual)) then
  begin
    if (AliqIcmsEnt * (1 - PerRedBCEnt / 100)) > (AliqIcmsSai * (1 - PerRedBCSai / 100)) then
    begin
      AliqIcmsEnt  := AliqIcmsSai; // Crédito Vedado na Entrada, será igual ao perc.aliquota da saida
      PerRedBCEnt := PerRedBCSai;
    end;
  end
  else
  begin
    AliqIcmsEnt := 0.00;
    if (PerPautaIVA_NCM > 0.00) or (ValPautaIVA > 0.00) then
    begin
      AliqIcmsEnt := AliqIcmsEnt_NCM;
      PerRedBCEnt := PerRedBCEnt_NCM;
    end;
  end;

  if (AliqIcmsEnt = 0.00) then
  begin
    if (TipoTribEnt = 3) or FlgRegST then // Tipo Substituicao Entrada = Somente calcula Crédito se for Substituição
      AliqIcmsEnt := AliqICMSEntAnt
    else
      AliqIcmsEnt := 0.00;
  end;

  if (BFornIntrICMS) and (TipoTribEnt <> 3) then
  begin
    AliqIcmsEnt := 0.00;
    PerRedBCEnt := 0.00;
  end;

end;

procedure CalcFator(ValTotal, ValItem: Currency; var CustoUnit: Currency);
var
  ValFator: Double;
begin
  if (ValItem <> 0.00) and (ValTotal <> 0.00) then
  begin
    ValFator := ValItem/ValTotal;

    if ValItem <> 0.00 then
      CustoUnit := CustoUnit + (CustoUnit * ValFator);
  end;

end;

function CalcCustoTotSemIPI_SUBS(ValCustoEmb, QtdEnt, ValDesc, ValAcresc, ValDespAcess, ValFreteItem: Double; BNaoDescBCST: Boolean): Currency;
begin

  Result := 0.00;

  if (ValCustoEmb = 0.00) or (QtdEnt = 0.00) then
    Exit;

  Result := CalculaTabelaLiquido(ValCustoEmb*QtdEnt, iif(BNaoDescBCST, 0.00, ValDesc), 0.00, ValAcresc, 0.00, 'N');
  Result := CalculaTabelaLiquido(Result, 0.00, 0.00, ValFreteItem, 0.00, 'N');

  Result := CalculaTabelaLiquido(Result, 0.00, 0.00, ValDespAcess, 0.00, 'N');

end;

function CalcCustoTotSemSUBS(ValCustoEmb, QtdEnt, ValDesc, ValAcresc, ValDespAcess, ValIPIItem, ValFreteItem, ValFreteDest,
                             ValTotalNF: Double; BDevol, RecalcIPI, BNaoDescBCST, BGuia, BRegST: Boolean): Currency;
var
  VRatFrDest: Double;
begin

  Result := CalcCustoTotSemIPI_SUBS(ValCustoEmb, QtdEnt, ValDesc, ValAcresc, ValDespAcess, ValFreteItem, BNaoDescBCST);

  Result := CalculaTabelaLiquido(Result, 0.00, 0.00, ValIPIItem, 0.00, 'N');
//  Result := CalculaTabelaLiquido(Result, 0.00, 0.00, ValFreteItem, PerFrete, 'N');

  if (ValFreteDest <> 0.00) and (ValTotalNF <> 0.00) then
  begin
    VRatFrDest := ValRatItemBruto(True, Result, ValFreteDest, ValTotalNF);
    Result := Result + VRatFrDest;
  end;

  if (BGuia and (Not BRegST)) and (ValFreteDest <> 0.00) and (ValTotalNF = 0.00) then  {quando valor total nf for ZERO, deverá atribuir o valor já rateado na variável "ValFreteDest"}
    Result := Result + ValFreteDest;

end;

function CalcVendaVarejo(PerPautaIVA, PerPautaIVA_NCM, ValPautaIVA, CustoTotEmbSemSUB, QtdTot: Double; BFornPauta: Boolean): Currency;
var
  ValTotPautaIVA: Double;
begin

  ValTotPautaIVA := ValPautaIVA*QtdTot;

  if (ValTotPautaIVA > CustoTotEmbSemSUB) and (BFornPauta) then
    Result := ValTotPautaIVA
  else
  begin
    if PerPautaIVA_NCM <> 0.00 then
      Result { VendaVarejo }  := CustoTotEmbSemSUB*(1+(PerPautaIVA_NCM/100))
    else
    begin
      if PerPautaIVA <> 0.00 then
        Result { VVarejo } := CustoTotEmbSemSUB*(1+(PerPautaIVA/100))
      else
        Result { VVarejo } := 0.00;
    end;

    Result := fltRound(Result, 2);

  end;

end;

function CalcValSubstituicao(VdaVarejo, AliqIcmsEnt, PerRedBCEnt, AliqIcmsEnt_NCM, PerRedBCEnt_NCM, AliqIcmsSai, PerRedBCSai,
                             PerPautaIVA_NCM,ValPautaIVA, ValCustoEmbSemIPIeSTeFrete: Double;
                             TipoTribEnt, TipoTribSai: SmallInt; FlgVedaCred, FlgRegST, BFornIntrICMS, BFornSimples, Interestadual: Boolean;
                             FlgNovoCalc : Boolean; TiRet : Integer;
                             var ValSTCRED: Currency ): Currency;
var
  ValBCSTEnt, ValBCSTSai, ValSTDEB, ValVdaVarejo: Double;
begin
  {TiRet
   0 - ValSubst
   1 - BC ST
   2 - Venda Varejo}
   CalcAliqIcmsRedBCEntrada(AliqIcmsEnt, PerRedBCEnt, AliqIcmsEnt_NCM, PerRedBCEnt_NCM, AliqIcmsSai, PerRedBCSai,
                          PerPautaIVA_NCM,ValPautaIVA, TipoTribEnt, FlgVedaCred, FlgRegST, BFornIntrICMS, BFornSimples, Interestadual);

    ValBCSTEnt := fltRound(ValCustoEmbSemIPIeSTeFrete * (1 - PerRedBCEnt / 100), 4);

  if (BFornIntrICMS) and (TipoTribEnt <> 3)then // M.E. e Simples tem B.C. igual a Zero, consequentemente não tem Crédito.
    ValSTCRED := 0.00
  else
    if ((BFornSimples) and (not Interestadual)) then
      ValSTCRED := ValBCSTEnt * (AliqIcmsSai/100)
    else
      ValSTCRED := ValBCSTEnt * (AliqIcmsEnt/100);

  ValBCSTSai := fltRound(VdaVarejo * (1 - PerRedBCSai / 100), 4);
  if (TiRet = 1) and (not FlgNovoCalc) then
  begin
    Result := iif(ValBCSTSai > 0, ValBCSTSai, 0.00);
    Exit;
  end;
  ValSTDEB := ValBCSTSai*(AliqIcmsSai/100);


  //Novo Calculo ST
  if FlgNovoCalc then
  begin
    ValVdaVarejo := VdaVarejo - ValSTCRED;
    ValVdaVarejo := ValVdaVarejo /(1-((AliqIcmsSai - (AliqIcmsSai*(PerRedBCSai/100)))/100));
    if TiRet = 2 then
    begin
      Result := iif(ValVdaVarejo > 0, ValVdaVarejo, 0.00);
      Exit;
    end;
    ValBCSTSai := ValVdaVarejo - (ValVdaVarejo  *(PerRedBCSai / 100));
    if TiRet = 1 then
    begin
      Result := iif(ValBCSTSai > 0, ValBCSTSai, 0.00);
      Exit;
    end;
    ValSTDEB := ValBCSTSai * (AliqIcmsSai/100);
    {ValSTDEB := ValBCSTSai - ValSTCRED;//(ValBCSTSai * (AliqIcmsEnt/100));
    ValSTDEB := ValSTDEB /(1-((AliqIcmsSai - (AliqIcmsSai*(PerRedBCSai/100)))/100));

    ValSTDEB  := ValSTDEB * (AliqIcmsSai/100);  }
    if ValSTDEB < 0.00 then
      ValSTDEB := 0.00;
  end;
  //Fim novo calculo
  if (TipoTribSai=3) and (ValSTDEB <> 0.00) then
    Result {ValST} := fltRound(ValSTDEB - ValSTCRED, 4)
  else
    Result {ValST} := 0.00;

  Result := fltRound(Result, 2);

end;

function CalcValFCPST(VdaVarejo, AliqIcmsEnt, PerRedBCEnt, AliqIcmsEnt_NCM, PerRedBCEnt_NCM, AliqIcmsSai, PerRedBCSai,
                             PerPautaIVA_NCM,ValPautaIVA, ValCustoEmbSemIPIeSTeFrete: Double;
                             TipoTribEnt, TipoTribSai: SmallInt; FlgVedaCred, FlgRegST, BFornIntrICMS, BFornSimples, Interestadual: Boolean;
                             FlgNovoCalc : Boolean; TiRet : Integer; PerFCPSai, PerFCPENT : Double): Currency;
var
  ValBCSTEnt, ValBCSTSai, ValFCPDeb, ValFCPCred, ValVdaVarejo: Double;
begin
  {TiRet
   0 - ValSubst
   1 - BC ST
   2 - Venda Varejo}
  CalcAliqIcmsRedBCEntrada(AliqIcmsEnt, PerRedBCEnt, AliqIcmsEnt_NCM, PerRedBCEnt_NCM, AliqIcmsSai, PerRedBCSai,
                          PerPautaIVA_NCM,ValPautaIVA, TipoTribEnt, FlgVedaCred, FlgRegST, BFornIntrICMS, BFornSimples, Interestadual);

  ValBCSTEnt := fltRound(ValCustoEmbSemIPIeSTeFrete * (1 - PerRedBCEnt / 100), 4);

  if (BFornIntrICMS) and (TipoTribEnt <> 3)then // M.E. e Simples tem B.C. igual a Zero, consequentemente não tem Crédito.
    ValFCPCred := 0.00
  else
    if ((BFornSimples) and (not Interestadual)) then
      ValFCPCred := ValBCSTEnt * (PerFCPENT/100)
    else
      ValFCPCred := ValBCSTEnt * (PerFCPENT/100);


  ValBCSTSai := fltRound(VdaVarejo * (1 - PerRedBCSai / 100), 4);


  ValFCPDeb := ValBCSTSai*(PerFCPSai/100);



  if (TipoTribSai=3) and (ValFCPDeb <> 0.00) then
    Result {ValST} := fltRound(ValFCPDeb - ValFCPCred, 4)
  else
    Result {ValST} := 0.00;

  Result := fltRound(Result, 2);

end;

function CalcVariacaoPesq(ValPesq, ValVenda: Currency): Currency;
begin
  if ValPesq <> 0.00 then
    Result := ((ValPesq - ValVenda) / ValPesq) * 100
  else
    Result := 0.00;
end;

function TruncaFrac(Valor: Currency; Casa: SmallInt): Currency;
var
  i, Mult: Integer;
begin
  Mult := 1;
  for i := 1 to Casa do
    Mult := Mult * 10;
  Result := (Trunc(Valor * Mult) / Mult);
end;

function TruncaFracDouble(const aValor: Double; const aCasas: SmallInt): Double;
var
  vCasasStr: string;
  vCasasDec: Integer;
begin
  Result    := 0.00;
  vCasasStr := '';
  vCasasDec := 0;
  vCasasStr := '1' + StrMake('0', aCasas);
  vCasasDec := StrToInt(vCasasStr);
  Result    := Trunc(aValor * vCasasDec) / vCasasDec;
end;

// Valor Tabela - Desconto + Acrescimo

function CalculaTabelaLiquido(Tabela:Currency; Val_Desc : Double; Per_Desc,
  Val_Acr, Per_Acr: Currency; Acr_Bruto: string): Double;
var
  Acrescimo: Currency;
  Desconto : Double;
begin
  Desconto := Val_Desc + ((Tabela * Per_Desc) / 100);
  if Acr_Bruto = 'S' then
    Acrescimo := Val_Acr + ((Tabela * Per_Acr) / 100)
  else
    Acrescimo := Val_Acr + (((Tabela - Desconto) * Per_Acr) / 100);
  Result := (Tabela - Desconto + Acrescimo);
end;

// Valor Tabela ou Tabela Liq + IPI

function CalculaTabelaFinal(Tabela, TabelaLiq, Val_IPI_Calc: Currency;
  IPI_Bruto: string): Currency;
begin
  if IPI_Bruto = 'S' then
    Result := Tabela + Val_IPI_Calc
  else
    Result := TabelaLiq + Val_IPI_Calc;
end;

function CalculaValorIPI(Tabela, Tabela_Liq, Val_IPI, Per_IPI: Currency;
  IPI_Bruto: string): Currency;
begin
  if IPI_Bruto = 'S' then
    Result := (Val_IPI + ((Tabela * Per_IPI) / 100))
  else
    Result := (Val_IPI + ((Tabela_Liq * Per_IPI) / 100));
end;

function CalculaValor(Valor, val1: Currency; per1: Double): Currency;
begin
  Result := val1 + Valor * (1 + (per1 / 100));
end;

function CalculaValorPerc(CValor: Currency; DPerc: Double; BAcresc: Boolean):
  Currency;
begin
  if BAcresc then
    Result := CValor * (1 + (DPerc / 100))
  else
    Result := CValor * (1 - (DPerc / 100));
end;

function CalcParcLiquido(Parcela, Juros, Devolucao, Desconto, Credito, Retencao, TaxaAdmin, Outros : Currency): Currency;
begin
  {pagar}Result := Parcela + (Juros + Credito) - (Desconto + Devolucao + Retencao + TaxaAdmin) + Outros;
  (*
  TpConta: Smallint;
    case TpConta of
    {pagar} 0 : Result := Parcela + (Juros + Devolucao) - (Desconto + Credito);
    {receb} 1 : Result := Parcela + (Juros + Devolucao) - (Desconto + Credito);
  *)
end;


function CalcPerDescSobreDesc(PDesc1, PDesc2, PDesc3, PDesc4: Double): Currency;
begin
  Result := 1 - (1 - (PDesc1 / 100)) * (1 - (PDesc2 / 100)) * (1 - (PDesc3 /
    100)) * (1 - (PDesc4 / 100));
end;

function CalcValTabLiq(VTabela, VDAcess, VDesc, VAcresc, VFrete: Currency): Currency;
var
  VEncargos: Double;
begin
  Result := 0.00;
  if (VTabela = 0.00) then
    Exit;
  VEncargos := VAcresc + VDAcess + VFrete - VDesc;

  Result := VTabela + VEncargos;
end;

function CalcValTabFinal(VTabela, VTabLiq, VSubst, VIPI: Currency; IPIBr: Boolean): Currency;
var
  IPI: Currency;
begin
  IPI := CalculaValorIPI(VTabela, VTabLiq, VIPI, 0.00, SimNao(IPIBr));
  Result := VTabLiq + IPI;
  Result := Result + VSubst;
end;

function MemSomaValorCurr(Qry: TDataSet; Campo: string): Currency;
var
  BM: TBookMark;
begin
  Result := 0.00;
  BM := Qry.GetBookmark;
  with Qry do
  try
    DisableControls;
    First;
    while not EOF do
    begin
      Result := Result + FieldByName(Campo).AsCurrency;
      Next;
    end;
    GotoBookmark(BM);
  finally
    FreeBookmark(BM);
    EnableControls;
  end;
end;

procedure RateiaValItemSoma(var ValItem: Currency; BRateia, BRatTotItem:
  Boolean; ValRat, ValTotItem: Currency);
begin
  if BRateia then
    if (ValRat > 0.00) and (ValTotItem > 0.00) then
      case BRatTotItem of
        True: ValItem := ValItem * (1 + (ValRat / ValTotItem));
        False: ValItem := ValItem + ValRat;
      end;
end;

procedure RateiaValItemSubtrai(var ValItem: Currency; BRateia, BRatTotItem:
  Boolean; ValRat, ValTotItem: Currency);
begin
  if BRateia then
    if (ValRat > 0.00) and (ValTotItem > 0.00) then
      case BRatTotItem of
        True: ValItem := ValItem * (1 - (ValRat / ValTotItem));
        False: ValItem := ValItem - ValRat;
      end;
end;

function ValRatItemBruto(BRateia: Boolean; ValItem, ValRat, ValTotItem:
  Currency): Double;
begin
  Result := 0.00;
  if BRateia then
    if (ValRat > 0.00) and (ValTotItem > 0.00) then
      Result := ValItem * (ValRat / ValTotItem);
end;

function QtdRatItemBruto(BRateia: Boolean; QtdTotItem, QtdItem, ValItem, ValRat,
  ValTotItem: Currency): Currency;
begin
  Result := 0.00;
  if BRateia and ((ValRat > 0.00) and (ValTotItem > 0.00)) then
    Result := (ValRat / QtdTotItem) * QtdItem;
end;

procedure RegraImpostoCredito(FlgIdCtbGeraPisCofins, FlgNaoICMS, FlgNaoPISCof, FlgIntICMS, FlgIntPISCof: String;
                              var FlgNaoCredICMS, FlgNaoCredPISCof: String);
begin
  // Nivel do Produto
  FlgNaoCredICMS := FlgNaoICMS;
  FlgNaoCredPISCof := FlgNaoPISCof;
  // Nível do fornecedor prevalesce somente Crédito
  // Atenção: Nivel do fornecedor não influi para regra de Débito
  if FlgIntICMS = 'S' then
    FlgNaoCredICMS := 'S';
  if FlgIntPISCof = 'S' then
    FlgNaoCredPISCof := 'S';
  if FlgIdCtbGeraPisCofins = 'S' then  // Quando não gera PIS/COFINS no Id. Contábil, deverá não incidir PIS/COFINS no item.
    FlgNaoCredPISCof := 'S';

end;

procedure CalcItemVVarejo(MTabItens: TDataSet; ColEmb, ColQtd: string;
  BFreteBC: Boolean;
  VTabLiq, VTabFinal, VTotLiqItens, VDAcessRat, VAcrescRat, VDescRat, VFreteRat,
  VEncFinRat: Currency);
var
  PICMSE, PICMSS, PSubst, VCredICMSRet, VDebICMSRet, VICMSRet, VVarejo,
    VDAcAcrEncFin: Currency;
begin
  if (VTotLiqItens = 0.00) or (MTabItens.FieldByName(ColQtd).AsFloat = 0.00)
    then
    Exit;
  if MTabItens.FieldByName('TIPO_TRIBUTACAO').AsInteger = 3 then // Substituição
  begin
    PICMSE := MTabItens.FieldByName('PER_ICMS_ENTRADA').AsFloat;
    PICMSS := MTabItens.FieldByName('PER_ICMS_SAIDA').AsFloat;
    //
    VDAcAcrEncFin := VDAcessRat + VAcrescRat + VEncFinRat;
    VCredICMSRet := VTabLiq * (PICMSE / 100);
    VICMSRet := MTabItens.FieldByName('VAL_SUBST').AsCurrency;
    PSubst := MTabItens.FieldByName('PER_SUBST').AsFloat;
    //
    if MTabItens.FieldByName('VAL_SUBST').AsCurrency <> 0.00 then
    begin
      //      VICMSRet := MTabItens.FieldByName('VAL_SUBST').AsCurrency;
      VDebICMSRet := VCredICMSRet + VICMSRet;
      if MTabItens.FieldByName('VAL_VENDA_VAREJO').AsCurrency <> 0.00 then
        VVarejo := MTabItens.FieldByName('VAL_VENDA_VAREJO').AsCurrency *
          MTabItens.FieldByName(ColQtd).AsFloat
      else
      begin
        try
          if PICMSS <> 0.00 then
            VVarejo := ((VICMSRet * MTabItens.FieldByName(ColQtd).AsFloat) /
              (PICMSS / 100)) + VTabLiq
          else
            VVarejo := 0.00;
          VVarejo := VVarejo * MTabItens.FieldByName(ColQtd).AsFloat;
        except on EDivByZero do
            VVarejo := 0.00;
        end;
        RateiaValItemSoma(VVarejo, True, False, VDAcAcrEncFin, VTotLiqItens);
        RateiaValItemSoma(VVarejo, BFreteBC, False, VFreteRat, VTotLiqItens);
      end;
      //      PSubst := ((VVarejo * 100)/VTabFinal + (VDAcAcrEncFin/VTotLiqItens)) - 100;
    end
    else
    begin
      if MTabItens.FieldByName('VAL_VENDA_VAREJO').AsCurrency <> 0.00 then
        VVarejo := MTabItens.FieldByName('VAL_VENDA_VAREJO').AsCurrency *
          MTabItens.FieldByName(ColQtd).AsFloat
      else
      begin
        VVarejo := VTabFinal * (1 + (PSubst / 100)) + (VDAcAcrEncFin /
          VTotLiqItens);
        RateiaValItemSoma(VVarejo, BFreteBC, False, VFreteRat, VTotLiqItens);
        //        VVarejo := VVarejo * MTabItens.FieldByName(ColQtd).AsFloat;
      end;
      VDebICMSRet := VVarejo * (PICMSS / 100);
      VICMSRet := VDebICMSRet - VCredICMSRet;
    end;
    // Atualiza Campos Calculados!!
    MTabItens.FieldByName('VAL_VENDA_VAREJO_CALC').AsFloat := VVarejo;
    MTabItens.FieldByName('VAL_ICMS_RET_CRED').AsFloat := VCredICMSRet;
    MTabItens.FieldByName('VAL_ICMS_RET_DEB').AsFloat := VDebICMSRet;
    MTabItens.FieldByName('VAL_ICMS_RET').AsFloat := VICMSRet;
  end;
end;

{ Rectangle Calculations }

function RectHeight(const R: TRect): Integer;
begin
  Result := R.Bottom - R.Top;
end;

function RectWidth(const R: TRect): Integer;
begin
  Result := R.Right - R.Left;
end;

procedure RectGrow(var R: TRect; Delta: Integer);
begin
  with R do
  begin
    Dec(Left, Delta);
    Dec(Top, Delta);
    Inc(Right, Delta);
    Inc(Bottom, Delta);
  end;
end;

procedure RectRelativeMove(var R: TRect; DX, DY: Integer);
begin
  with R do
  begin
    Inc(Left, DX);
    Inc(Right, DX);
    Inc(Top, DY);
    Inc(Bottom, DY);
  end;
end;

procedure RectMoveTo(var R: TRect; X, Y: Integer);
begin
  with R do
  begin
    Right := X + Right - Left;
    Bottom := Y + Bottom - Top;
    Left := X;
    Top := Y;
  end;
end;

function RectSet(Left, Top, Right, Bottom: Integer): TRect;
begin
  Result.Left := Left;
  Result.Top := Top;
  Result.Right := Right;
  Result.Bottom := Bottom;
end;

function RectSetPoint(const TopLeft, BottomRight: TPoint): TRect;
begin
  Result.TopLeft := TopLeft;
  Result.BottomRight := BottomRight;
end;

function RectInclude(const R1, R2: TRect): Boolean;
begin
  Result := (R1.Left >= R2.Left) and (R1.Top >= R2.Top)
    and (R1.Right <= R2.Right) and (R1.Bottom <= R2.Bottom);
end;

function RectPoint(const R: TRect; P: TPoint): Boolean;
begin
  Result := (p.x > r.left) and (p.x < r.right) and (p.y > r.top) and (p.y <
    r.bottom);
end;

function RectIntersection(const R1, R2: TRect): TRect;
begin
  with Result do
  begin
    Left := intMax(R1.Left, R2.Left);
    Top := intMax(R1.Top, R2.Top);
    Right := intMin(R1.Right, R2.Right);
    Bottom := intMin(R1.Bottom, R2.Bottom);
  end;

  if not RectIsValid(Result) then
    Result := RectSet(0, 0, 0, 0);
end;

function RectIsIntersection(const R1, R2: TRect): Boolean;
begin
  Result := not RectIsNull(RectIntersection(R1, R2));
end;

function RectIsValid(const R: TRect): Boolean;
begin
  with R do
    Result := (Left <= Right) and (Top <= Bottom);
end;

function RectsAreValid(const Arr: array of TRect): Boolean;
var
  I: Integer;
begin
  for I := Low(Arr) to High(Arr) do
    if not RectIsValid(Arr[I]) then
    begin
      Result := False;
      exit;
    end;
  Result := True;
end;

function RectNull: TRect;
begin
  Result := RectSet(0, 0, 0, 0);
end;

function RectIsNull(const R: TRect): Boolean;
begin
  with R do
    Result := (Left = 0) and (Right = 0) and (Top = 0) and (Bottom = 0);
end;

function RectIsSquare(const R: TRect): Boolean;
begin
  Result := RectHeight(R) = RectWidth(R);
end;

function RectCentralPoint(const R: TRect): TPoint;
begin
  Result.X := R.Left + (RectWidth(R) div 2);
  Result.Y := R.Top + (RectHeight(R) div 2);
end;

function rectBounds(aLeft, aTop, aWidth, aHeight: Integer): TRect;
begin
  Result := rectSet(aLeft, aTop, aLeft + aWidth, aTop + aHeight);
end;

{ variant functions }

{$IFDEF Win32}

function varIIF(aTest: Boolean; TrueValue, FalseValue: Variant): Variant;
begin
  if aTest then
    Result := TrueValue
  else
    Result := FalseValue;
end;

procedure varDebug(const V: Variant);
begin
  strDebug(varToStr(v));
end;

function varToStr(const V: Variant): string;
begin
  case TVarData(v).vType of
    varSmallInt: Result := IntToStr(TVarData(v).VSmallInt);
    varInteger: Result := IntToStr(TVarData(v).VInteger);
    varSingle: Result := FloatToStr(TVarData(v).VSingle);
    varDouble: Result := FloatToStr(TVarData(v).VDouble);
    varCurrency: Result := FloatToStr(TVarData(v).VCurrency);
    varDate: Result := DateToStr(TVarData(v).VDate);
    varBoolean: Result := varIIf(TVarData(v).VBoolean, 'True', 'False');
    varByte: Result := IntToStr(TVarData(v).VByte);
    {$IFDEF VER150}
    varString: Result := StrPas(TVarData(v).VString);
    {$ELSE}
    varString: Result := StrPas(PAnsiChar(TVarData(v).VString));
    {$ENDIF}
    varEmpty,
      varNull,
      varVariant,
      varUnknown,
      varTypeMask,
      varArray,
      varByRef,
      varDispatch,
      varError: Result := '';
  end;
end;

function iif(Condicao: Boolean; Verdadeiro, Falso: Variant): Variant;
begin
  if Condicao then
    Result := Verdadeiro
  else
    Result := falso;
end;

{$ENDIF}

{ file functions }

procedure fileShredder(const Filename: string);
var
  aFile: Integer;
  aSize: Integer;
  P: Pointer;
begin
  aSize := fileSize(Filename);
  aFile := FileOpen(FileName, fmOpenReadWrite);
  try
    Getmem(P, aSize);
    fillchar(P^, aSize, 'X');
    FileWrite(aFile, P^, aSize);
    Freemem(P, aSize);
  finally
    FileClose(aFile);
    DeleteFile(Filename);
  end;
end;

function fileSize(const FileName: string): LongInt;
var
  SearchRec: TSearchRec;
begin { !Win32! -> GetFileSize }
  if FindFirst(FileName, faAnyFile, SearchRec) = 0 then
    Result := SearchRec.Size
  else
    Result := 0;
end;

function fileWildcard(const Filename: string): Boolean;
begin
  Result := (Pos('*', Filename) <> 0) or (Pos('?', Filename) <> 0);
end;

function fileShellOpen(const aFile: string): Boolean;
var
  Tmp: array[0..100] of char;
begin
  Result := ShellExecute(Application.Handle,
    'open', StrPCopy(Tmp, aFile), nil, nil, SW_NORMAL) > 32;
end;

function fileShellPrint(const aFile: string): Boolean;
var
  Tmp: array[0..100] of char;
begin
  Result := ShellExecute(Application.Handle,
    'print', StrPCopy(Tmp, aFile), nil, nil, SW_HIDE) > 32;
end;

function fileCopy(const SourceFile, TargetFile: string): Boolean;
const
  BlockSize = 1024 * 16;
var
  FSource, FTarget: Integer;
  BRead, Bwrite: Word;
  Buffer: Pointer;
begin
  Result := False;
  FSource := FileOpen(SourceFile, fmOpenRead + fmShareDenyNone); { Open Source }
  if FSource >= 0 then
  try
    FTarget := FileCreate(TargetFile); { Open Target }
    try
      getmem(Buffer, BlockSize);
      try
        FileSeek(FSource, 0, soFromBeginning);
        repeat
          BRead := FileRead(FSource, Buffer^, BlockSize);
          BWrite := FileWrite(FTarget, Buffer^, Bread);
        until (Bread = 0) or (Bread <> BWrite);
        if Bread = Bwrite then
          Result := True;
      finally
        freemem(Buffer, BlockSize);
      end;
      FileSetDate(FTarget, FileGetDate(FSource));
    finally
      FileClose(FTarget);
    end;
  finally
    FileClose(FSource);
  end;
end;

function ConvertStringToPChar(StringValue: string): PChar;
var
  PCharString: array[0..255] of Char;
begin
  Result := StrPCopy(PCharString, StringValue);
end;

function ConverteStringImpDireta(aText : string) : string;
begin
  Result := aText;
  Result := StringReplace(Result,char(199),'Ã',[rfReplaceAll]);
  Result := StringReplace(Result,char(144),'É',[rfReplaceAll]);
  Result := StringReplace(Result,chr(135) ,'ç',[rfReplaceAll]);
  Result := StringReplace(Result,chr(147) ,'ô',[rfReplaceAll]);
  Result := StringReplace(Result,Chr(128) ,'Ç',[rfReplaceAll]);
  Result := StringReplace(Result,Chr(229) ,'Õ',[rfReplaceAll]);
  Result := StringReplace(Result,Chr(224) ,'Ó',[rfReplaceAll]);
end;

function StrToPChar(const Str: string): PChar;
{Converte String em Pchar}
type
  TRingIndex = 0..7;
var
  Ring: array[TRingIndex] of PChar;
  RingIndex: TRingIndex;
  Ptr: PChar;
begin
  Ptr := @Str[Length(Str)];
  Inc(Ptr);
  RingIndex := 0;
  if Ptr^ = #0 then
  begin
    Result := @Str[1];
  end
  else
  begin
    Result := StrAlloc(Length(Str) + 1);
    RingIndex := (RingIndex + 1) mod (High(TRingIndex) + 1);
    StrPCopy(Result, Str);
    StrDispose(Ring[RingIndex]);
    Ring[RingIndex] := Result;
  end;
end;

function DeleteFiles(FilePath, FileMask: string): Boolean;
var
  DeleteFilesSearchRec: TSearchRec;
begin
  Result := False;
  FindFirst(FilePath + BARRA + FileMask, faAnyFile, DeleteFilesSearchRec);
  if not (DeleteFilesSearchRec.Name = '') then
  begin
    Result := True;
    DeleteFile(
{$IFDEF WIN32}ConvertStringToPChar({$ENDIF}
      FilePath + BARRA + DeleteFilesSearchRec.Name
{$IFDEF WIN32}){$ENDIF}
      );
    while True do
    begin
      if FindNext(DeleteFilesSearchRec) < 0 then
      begin
        Break;
      end
      else
      begin
        DeleteFile(
{$IFDEF WIN32}ConvertStringToPChar({$ENDIF}
          FilePath + BARRA + DeleteFilesSearchRec.Name
{$IFDEF WIN32}){$ENDIF}
          );
      end;
    end;
  end;
end;

{$IFDEF Win32}

function fileTemp(const aExt: string): string;
var
  Buffer: array[0..1023] of Char;
  aFile: string;
begin
  GetTempPath(Sizeof(Buffer) - 1, Buffer);
  GetTempFileName(Buffer, 'TMP', 0, Buffer);
  SetString(aFile, Buffer, StrLen(Buffer));
  Result := ChangeFileExt(aFile, aExt);
  RenameFile(aFile, Result);
end;

function RenomeiaArquivo(aFileName, aNewFileName : string) : Boolean;
begin
  Result := RenameFile(aFileName,aNewFileName);
end;

function fileExec(const aCmdLine: string; aHide, aWait: Boolean): Boolean;
var
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
begin
  {setup the startup information for the application }
  FillChar(StartupInfo, SizeOf(TStartupInfo), 0);
  with StartupInfo do
  begin
    cb := SizeOf(TStartupInfo);
    dwFlags := STARTF_USESHOWWINDOW or STARTF_FORCEONFEEDBACK;
    if aHide then
      wShowWindow := SW_HIDE
    else
      wShowWindow := SW_SHOWNORMAL;
  end;

  Result := CreateProcess(nil, PChar(aCmdLine), nil, nil, False,
    NORMAL_PRIORITY_CLASS, nil, nil, StartupInfo, ProcessInfo);
  if aWait then
    if Result then
    begin
      WaitForInputIdle(ProcessInfo.hProcess, INFINITE);
      WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
    end;
end;

function fileRedirectExec(const aCmdLine: string; Strings: TStrings): Boolean;
var
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
  aOutput: Integer;
  aFile: string;
begin
  Strings.Clear;

  { Create temp. file for output }
  aFile := FileTemp('.tmp');
  aOutput := FileCreate(aFile);
  try
    {setup the startup information for the application }
    FillChar(StartupInfo, SizeOf(TStartupInfo), 0);
    with StartupInfo do
    begin
      cb := SizeOf(TStartupInfo);
      dwFlags := STARTF_USESHOWWINDOW or STARTF_FORCEONFEEDBACK or
        STARTF_USESTDHANDLES;
      wShowWindow := SW_HIDE;
      hStdInput := INVALID_HANDLE_VALUE;
      hStdOutput := aOutput;
      hStdError := INVALID_HANDLE_VALUE;
    end;

    Result := CreateProcess(nil, PChar(aCmdLine), nil, nil, False,
      NORMAL_PRIORITY_CLASS, nil, nil, StartupInfo, ProcessInfo);
    if Result then
    begin
      WaitForInputIdle(ProcessInfo.hProcess, INFINITE);
      WaitForSingleObject(ProcessInfo.hProcess, INFINITE);
    end;
  finally
    FileClose(aOutput);
    Strings.LoadFromFile(aFile);
    DeleteFile(aFile);
  end;
end;

function fileLongName(const aFile: string): string;
var
  aInfo: TSHFileInfo;
begin
  if SHGetFileInfo(PChar(aFile), 0, aInfo, Sizeof(aInfo), SHGFI_DISPLAYNAME) <> 0
    then
    Result := StrPas(aInfo.szDisplayName)
  else
    Result := aFile;
end;

function fileTypeName(const aFile: string): string;
var
  aInfo: TSHFileInfo;
begin
  if SHGetFileInfo(PChar(aFile), 0, aInfo, Sizeof(aInfo), SHGFI_TYPENAME) <> 0
    then
    Result := StrPas(aInfo.szTypeName)
  else
  begin
    Result := ExtractFileExt(aFile);
    Delete(Result, 1, 1);
    Result := strUpper(Result) + ' File';
  end;
end;

function fileShortName(const aFile: string): string;
var
  aTmp: array[0..255] of char;
begin
  if GetShortPathName(PChar(aFile), aTmp, Sizeof(aTmp) - 1) = 0 then
    Result := aFile
  else
    Result := StrPas(aTmp);
end;

{$ENDIF}

function ExtractName(const Filename: string): string;
var
  aExt: string;
  aPos: Integer;
begin
  aExt := ExtractFileExt(Filename);
  Result := ExtractFileName(Filename);
  if aExt <> '' then
  begin
    aPos := Pos(aExt, Result);
    if aPos > 0 then
      Delete(Result, aPos, Length(aExt));
  end;
end;

Function fncGetStatusWinService(const sWinService : string; const sComputerName : string = '') : integer;
var
    {Nome do computador onde esta localizado o serviço}
    sComputerNameEx : string;
    chrComputerName : array[0..255] of char;
//    cSize           : Cardinal;
    {Handle do Gerenciador de Serviços}
    hServiceControl : SC_Handle;
    {Handle do Serviço}
    hService        : SC_Handle;
    {Status do Serviço}
    tStatus         : TServiceStatus;
    {Status Atual do Serviço}
    iStatus         : integer;
begin
    iStatus:=0;
//    Result:=0;
    {Verifica se nome do computador foi declarado}
    if (sComputerName = '') then
    begin
        {Caso não tenha sido declarado captura o nome do computador local}
        FillChar(chrComputerName, SizeOf(chrComputerName), #0);
        //GetComputerName(chrComputerName, cSize);
        sComputerNameEx:=chrComputerName;
    end
    else sComputerNameEx:=sComputerName;
    {Conecta ao Gerenciador de Serviços}
    hServiceControl:=OpenSCManager(PChar(sComputerNameEx), nil, SC_MANAGER_CONNECT);
    {Se conseguiu se conectar}
    if not(hServiceControl = 0) then
    begin
        {Conecta o Serviço Especificado}
        {Solicitando SERVICE_QUERY_STATUS ou o status do serviço}
        hService:=OpenService(hServiceControl, PChar(sWinService), SERVICE_QUERY_STATUS);
        {Se conseguiu se conectar}
        if not(hService = 0) then
        begin
            if (QueryServiceStatus(hService, tStatus)) then
            begin
                iStatus:=tStatus.dwCurrentState;
            end;
            {Fecha Handle do Serviço}
            CloseServiceHandle(hService);
        end
        else iStatus:=-1;
        {Fecha conexão com o Gerenciador de Serviços}
        CloseServiceHandle(hServiceControl);
    end
    else iStatus:=-2;
    {Retorna o valor do Status para a função}
    Result:=iStatus;
end;

{ date calculations }

function dateYear(D: TDateTime): Integer;
var
  Year, Month, Day: Word;
begin
  DecodeDate(D, Year, Month, Day);
  Result := Year;
end;

function dateMonth(D: TDateTime): Integer;
var
  Year, Month, Day: Word;
begin
  DecodeDate(D, Year, Month, Day);
  Result := Month;
end;

function dateBeginOfYear(D: TDateTime): TDateTime;
var
  Year, Month, Day: Word;
begin
  DecodeDate(D, Year, Month, Day);
  Result := EncodeDate(Year, 1, 1);
end;

function dateEndOfYear(D: TDateTime): TDateTime;
var
  Year, Month, Day: Word;
begin
  DecodeDate(D, Year, Month, Day);
  Result := EncodeDate(Year, 12, 31);
end;

function dateBeginOfMonth(D: TDateTime): TDateTime;
var
  Year, Month, Day: Word;
begin
  //StartOfAMonth - DateUtils
  DecodeDate(D, Year, Month, Day);
  Result := EncodeDate(Year, Month, 1);
end;

function dateEndOfMonth(D: TDateTime): TDateTime;
var
  Year, Month, Day: Word;
begin
  DecodeDate(D, Year, Month, Day);
  if Month = 12 then
  begin
    Inc(Year);
    Month := 1;
  end
  else
    Inc(Month);
  Result := EncodeDate(Year, Month, 1) - 1;
end;

function dateWeekOfMonth(D: TDateTime): Word;
var
  Semana: Word;
begin
  if ((dateDayOfMonth(D) div 7) + 1) <= 1 then
    Semana := 1
  else
    Semana := ((dateDayOfMonth(D) div 7) + 1);
  if (dateDayOfMonth(D) > 28) and (DayOfWeek(dateBeginOfMonth(D)) > 5) then
    Inc(Semana);
  Result := Semana;
end;

function dateWeekOfYear(D: TDateTime): Integer; { Armin Hanisch }
const
  t1: array[1..7] of ShortInt = (-1, 0, 1, 2, 3, -3, -2);
  t2: array[1..7] of ShortInt = (-4, 2, 1, 0, -1, -2, -3);
var
  doy1,
    doy2: Integer;
  NewYear: TDateTime;
begin
  NewYear := dateBeginOfYear(D);
  doy1 := dateDayofYear(D) + t1[DayOfWeek(NewYear)];
  doy2 := dateDayofYear(D) + t2[DayOfWeek(D)];
  if doy1 <= 0 then
    Result := dateWeekOfYear(NewYear - 1)
  else if (doy2 >= dateDayofYear(dateEndOfYear(NewYear))) then
    Result := 1
  else
    Result := (doy1 - 1) div 7 + 1;
end;

function dateMonthBetween(DDe, DAte: TDateTime): Integer;
var
  MesAnoDe, MesAnoAte: string;
  DataDe: TDateTime;
begin
  if DDe > DAte then
  begin
    Result := 0;
    Exit;
  end;
  DataDe := DDe;
  MesAnoAte := IntToStr(MonthOf(DAte)) +
    inttostr(YearOf(DAte));
  Result := -1;
  repeat
    MesAnoDe := IntToStr(MonthOf(DataDe)) + inttostr(YearOf(DataDe));
    Inc(Result);
    DataDe := IncMonth(DataDe);
  until
    (MesAnoDe = MesAnoAte);
end;

function dateDayOfYear(D: TDateTime): Integer;
begin
  Result := Trunc(D - dateBeginOfYear(D)) + 1;
end;

function dateDayOfMonth(D: TDateTime): Integer;
var
  Year, Month, Day: Word;
begin
  DecodeDate(D, Year, Month, Day);
  Result := Day;
end;

function dateDayOfWeek(D: TDateTime): TDayOfWeek;
begin
  Result := TDayOfWeek(Pred(DayOfWeek(D)));
end;

function dateLeapYear(D: TDateTime): Boolean;
var
  Year, Month, Day: Word;
begin
  DecodeDate(D, Year, Month, Day);
  Result := (Year mod 4 = 0) and ((Year mod 100 <> 0) or (Year mod 400 = 0));
end;

function dateBeginOfQuarter(D: TDateTime): TDateTime;
var
  Year, Month, Day: Word;
begin
  DecodeDate(D, Year, Month, Day);
  Result := EncodeDate(Year, ((Month - 1 div 3) * 3) + 1, 1);
end;

function dateEndOfQuarter(D: TDateTime): TDateTime;
begin
  Result := dateBeginOfQuarter(dateBeginOfQuarter(D) + (3 * 31)) - 1;
end;

function dateBeginOfWeek(D: TDateTime; Weekday: Integer): TDateTime;
begin
  Result := D;
  while DayOfWeek(Result) <> Weekday do
    Result := Result - 1;
end;

function dateDaysInMonth(D: TDateTime): Word;
const
  DaysPerMonth: array[1..12] of Byte = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31,
    30, 31);
var
  Month: Word;
begin
  Month := dateMonth(D);
  Result := DaysPerMonth[Month];
  if (Month = 2) and dateLeapYear(D) then
    Inc(Result);
end;

function dateDay(D: TDateTime): Integer;
var
  Year, Month, Day: Word;
begin
  DecodeDate(D, Year, Month, Day);
  Result := Day;
end;

function dateQuicken(D: TDateTime; var Key: Char): TDateTime;
const
{$IFDEF German}
  _ToDay = 'H';
  _PrevYear = 'J';
  _NextYear = 'R';
  _PrevMonth = 'M';
  _NextMonth = 'T';
  _BeginQuart = 'Q';
  _EndQuart = 'U';
{$ELSE}
  _ToDay = 'T';
  _PrevYear = 'Y';
  _NextYear = 'R';
  _PrevMonth = 'M';
  _NextMonth = 'H';
  _BeginQuart = 'Q';
  _EndQuart = 'U';
{$ENDIF}
begin
  case Upcase(Key) of { Quicken Date Fast Keys }
    '+': Result := D + 1;
    '-': Result := D - 1;
    _ToDay: Result := Date;
    _PrevYear: if D <> dateBeginOfYear(D) then
        Result := dateBeginOfYear(D)
      else
        Result := dateBeginOfYear(D - 1);
    _NextYear: if D <> dateEndOfYear(D) then
        Result := dateEndOfYear(D)
      else
        Result := dateEndOfYear(Date + 1);
    _PrevMonth: if D <> dateBeginOfMonth(D) then
        Result := dateBeginOfMonth(D)
      else
        Result := dateBeginOfMonth(D - 1);
    _NextMonth: if D <> dateEndOfMonth(D) then
        Result := dateEndOfMonth(D)
      else
        Result := dateEndOfMonth(D + 1);
    _BeginQuart: Result := dateBeginOfQuarter(D);
    _EndQuart: Result := dateEndOfQuarter(D);
  else
    begin
      Result := D;
      exit;
    end;
  end;
  Key := #0;
end;

function DiaFixo(DtaEmissao : TDateTime; NumCond, DiaBase : integer): TDateTime;
begin
  Result := Date; //Só para não ficar dando Warning na compilação.
  if DiaBase = 0 then
    Result := DtaEmissao;
  if (DiaBase > 0) and (DiaBase <=7) then //Dia da Semana
  begin
    if DayOfWeek(DtaEmissao) < DiaBase then
      Result := IncWeek(DtaEmissao,NumCond)+ (DiaBase - DayOfWeek(DtaEmissao))
    else if DayOfWeek(DtaEmissao) > DiaBase then
      Result := IncWeek(DtaEmissao,NumCond) - (DayOfWeek(DtaEmissao) - DiaBase)
    else if DayOfWeek(DtaEmissao) = DiaBase then
      Result := IncWeek(DtaEmissao,NumCond);
  end
  else if (DiaBase >= 8) then //Dia do Mês
  begin
    Try
      if (DayOf(DtaEmissao) < NumCond) and (DayOf(DtaEmissao) < (DiaBase - 7)) then
        Result  := StrToDate(IntToStr(NumCond)+'/'+
                             IntToStr(MonthOf(DtaEmissao))+'/'+
                             IntToStr(YearOf(DtaEmissao)))
      else
        Result  := StrToDate(IntToStr(NumCond)+'/'+
                             IntToStr(MonthOf(IncMonth(DtaEmissao,1)))+'/'+
                             IntToStr(YearOf(IncMonth(DtaEmissao,1))));
    Except
      if (NumCond >= 29) and (MonthOf(DtaEmissao) = 2) then
        Result := StrToDate('01/03'+'/'+IntToStr(YearOf(DtaEmissao)))
      else
        Result := DtaEmissao;
    End;
  end;
end;

function DiasEntreDatas(aDtaIni, aDtaFim : TDateTime) : Integer;
begin
  Result := DaysBetween(aDtaIni,aDtaFim);
  Result := Result+1;
end;

function DataSemanaVerbaComprador(DtaMesAno: TDateTime; Semana: Word; Termino:
  Boolean): TDateTime;
var
  Inicio: Boolean;
begin
  if not (dateDay(dateBeginOfWeek(DtaMesAno, 1)) > dateDay(DtaMesAno)) then
    DtaMesAno := dateBeginOfWeek(DtaMesAno, 1);

  Inicio := not Termino;
  case Semana of
    1: if Inicio then
        Result := DtaMesAno
      else
        Result := EndOfTheWeek(DtaMesAno); { termino }
    2: if Inicio then
        Result := EndOfTheWeek(DtaMesAno) + 1
      else
        Result := EndOfTheWeek(EndOfTheWeek(DtaMesAno) + 1);
    3: if Inicio then
        Result := EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(DtaMesAno) + 1)) + 1
      else
        Result := EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(DtaMesAno)
          + 1)) + 1);
    4: if Inicio then
        Result := EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(DtaMesAno)
          + 1)) + 1) + 1
      else
        Result :=
          EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(DtaMesAno) + 1)) + 1) + 1);
    5: if Inicio then
        Result :=
          EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(DtaMesAno) + 1)) + 1)) + 1)) + 1
      else
        Result := dateEndOfMonth(DtaMesAno);
  else
    Result := DtaMesAno;
  end;
end;

function SemanaVerbaComprador(DtaMesAno: TDateTime): Word;
var
  DataInicioMes,
    DtaIniSemana1, DtaIniSemana2, DtaIniSemana3, DtaIniSemana4, DtaIniSemana5,
    DtaFimSemana1, DtaFimSemana2, DtaFimSemana3, DtaFimSemana4, DtaFimSemana5:
  TDateTime;
begin
  DataInicioMes := dateBeginOfMonth(DtaMesAno);

  DtaIniSemana1 := DataInicioMes;
  DtaFimSemana1 := EndOfTheWeek(DataInicioMes);

  DtaIniSemana2 := EndOfTheWeek(DataInicioMes) + 1;
  DtaFimSemana2 := EndOfTheWeek(EndOfTheWeek(DataInicioMes) + 1);

  DtaIniSemana3 := EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(DataInicioMes) + 1)) +
    1;
  DtaFimSemana3 :=
    EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(DataInicioMes) + 1)) +
    1);

  DtaIniSemana4 :=
    EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(DataInicioMes) + 1)) + 1)
    + 1;
  DtaFimSemana4 :=
    EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(DataInicioMes)
    + 1)) + 1) + 1);

  DtaIniSemana5 :=
    EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(EndOfTheWeek(DataInicioMes) + 1)) + 1)) + 1)) + 1;
  DtaFimSemana5 := dateEndOfMonth(DataInicioMes);

  Result := 1;
  if (DtaIniSemana1 <= (DtaMesAno+1)) and (DtaMesAno <= DtaFimSemana1) then
    Result := 1;
  if (DtaIniSemana2 <= (DtaMesAno+1)) and (DtaMesAno <= DtaFimSemana2) then
    Result := 2;
  if (DtaIniSemana3 <= (DtaMesAno+1)) and (DtaMesAno <= DtaFimSemana3) then
    Result := 3;
  if (DtaIniSemana4 <= (DtaMesAno+1)) and (DtaMesAno <= DtaFimSemana4) then
    Result := 4;
  if (DtaIniSemana5 <= (DtaMesAno+1)) and (DtaMesAno <= DtaFimSemana5) then
    Result := 5;

end;

function MesesEntre(const dta1,dta2:TDateTime):integer;
var
  d1,m1,y1: word;
  d2,m2,y2: word;
begin
  if (MonthOf(dta1) = MonthOf(dta2)) and (YearOf(dta1) = YearOf(dta2)) then
    Result := 1
  else
  begin
    decodedate(dta1,y1,m1,d1);
    decodedate(dta2,y2,m2,d2);
    result:=(m2-m1)+(y2-y1)*12;
  end;
end;



{ time functions }

function timeHour(T: TDateTime): Integer;
var
  Hour, Minute, Sec, Sec100: Word;
begin
  DecodeTime(T, Hour, Minute, Sec, Sec100);
  Result := Hour;
end;

function timeMin(T: TDateTime): Integer;
var
  Hour, Minute, Sec, Sec100: Word;
begin
  DecodeTime(T, Hour, Minute, Sec, Sec100);
  Result := Minute;
end;

function timeSec(T: TDateTime): Integer;
var
  Hour, Minute, Sec, Sec100: Word;
begin
  DecodeTime(T, Hour, Minute, Sec, Sec100);
  Result := Sec;
end;

function timeToInt(T: TDateTime): Integer;
begin
  Result := Trunc((MSecsPerday * T) / 1000);
end;

{$IFDEF Win32}
(*function  timeZoneOffset: Integer;
var
  aTimeZoneInfo : TTimeZoneInformation;
begin
  if GetTimeZoneInformation(aTimeZoneInfo)<>-1 then
     Result := aTimeZoneInfo.Bias
  else
     Result := 0;
end;  *)
{$ENDIF}

{ Communications Functions }

function comIsCis(const S: string): Boolean;
var
  aSt: string;
  PreId,
    PostId: Integer;
begin
  Result := strContainsU('@compuserve.com', S);
  { 28.7.96 sb This is also on CIS }
  if not Result then
    if Pos(',', S) > 0 then
    try
      aSt := S;
      PreId := StrToInt(strToken(aSt, ','));
      PostId := StrToInt(aSt);
      Result := (PreId > 0) and (PostId > 0);
    except
      Result := False;
    end;
end;

function comIsInt(const S: string): Boolean;
var
  aSt: string;
  PreId,
    PostId: string;
begin
  try
    aSt := S;
    PreId := strToken(aSt, '@');
    PostId := aSt;
    Result := (Length(PreId) > 0) and (Length(PostId) > 0);
  except
    Result := False;
  end;
end;

{ converts a CIS adress to a correct Internet adress }

function comCisToInt(const S: string): string;
var
  P: Integer;
begin
  p := Pos('INTERNET:', S);
  if P = 1 then
    Result := Copy(S, P + 1, Length(S))
  else
  begin
    Result := S;
    P := Pos(',', Result);
    if P > 0 then
      Result[P] := '.';
    Result := Result + '@compuserve.com'; { 22.07.96 sb  Error }
  end;
end;

{ converts a internet adress to a correct CServe adress }

function comIntToCis(const S: string): string;
var
  P: Integer;
begin
  p := Pos('@COMPUSERVE.COM', strUpper(S));
  if p > 0 then
  begin
    Result := strLeft(S, P - 1);
    P := Pos('.', Result);
    if P > 0 then
      Result[P] := ',';
  end
  else
    Result := 'INTERNET:' + S;
end;

{ converts a fax adress to a correct CServe adress }

function comFaxToCis(const S: string): string;
begin
  Result := 'FAX:' + S;
end;

function comNormFax(const Name, Fax: string): string;
begin
  if Name <> '' then
    Result := Name + '[fax: ' + Name + '@' + strTrim(Fax) + ']'
  else
    Result := '[fax: ' + strTrim(Fax) + ']';
end;

function comNormInt(const Name, Int: string): string;
begin
  Result := '';
  if comIsInt(Int) then
    if Name <> '' then
      Result := Name + '|smtp: ' + strTrim(Int)
    else
      Result := 'smtp: ' + strTrim(Int);
end;

function comNormCis(const Name, Cis: string): string;
begin
  Result := '';
  if Name <> '' then
    Result := Name + '[compuserve: ' + strTrim(Cis) + ']'
  else
    Result := '[compuserve: ' + strTrim(Cis) + ']';
end;

function comNormPhone(const Phone: string): string;

  function strValueAt(const S: string; At: Integer): string;
  const
    Seperator = ',';
    Str = '"';
  var
    j, i: Integer;
    FSkip: Boolean;
  begin
    Result := '';
    j := 1;
    i := 0;
    FSkip := False;
    while (i <= At) and (j <= Length(S)) do
    begin
      if (S[j] = Str) then
        FSkip := not FSkip
      else if (S[j] = Seperator) and not FSkip then
        Inc(i)
      else if i = At then
        Result := Result + S[j];
      Inc(j);
    end;
  end;

var
  aNumber,
    aCountry,
    aPrefix,
    aDefault,
    aLocation: string;

  i: Integer;
begin
  aDefault := '1,"Hamburg","","","40",49,0,0,0,"",1," "';
  aLocation := strProfile('telephon.ini', 'Locations', 'CurrentLocation', '');
  if aLocation <> '' then
  begin
    aLocation := strTokenAt(aLocation, ',', 0);
    if aLocation <> '' then
    begin
      aLocation := strProfile('telephon.ini', 'Locations', 'Location' +
        aLocation, '');
      if aLocation <> '' then
        aDefault := aLocation;
    end;
  end;

  Result := '';
  aNumber := strTrim(Phone);
  if aNumber <> '' then
    for i := Length(aNumber) downto 1 do
      if not (aNumber[i] in DIGITS) then
      begin
        if aNumber[i] <> '+' then
          aNumber[i] := '-';
        if i < Length(aNumber) then { remove duplicate digits }
          if aNumber[i] = aNumber[i + 1] then
            Delete(aNumber, i, 1);
      end;

  if aNumber <> '' then
  begin
    if aNumber[1] = '+' then
      aCountry := strToken(aNumber, '-')
    else
      aCountry := '+' + strValueAt(aDefault, 5);

    aNumber := strTrimChL(aNumber, '-');

    if aNumber <> '' then
    begin
      if strTokenCount(aNumber, '-') > 1 then
        aPrefix := strTrimChL(strToken(aNumber, '-'), '0')
      else
        aPrefix := strValueAt(aDefault, 4);

      aNumber := strNicePhone(strTrimChA(aNumber, '-'));
      Result := aCountry + ' (' + aPrefix + ') ' + aNumber;
    end;
  end;
end;

{ system functions }

{$IFDEF Win32}

function sysTempPath: string;
var
  Buffer: array[0..1023] of Char;
begin
  SetString(Result, Buffer, GetTempPath(Sizeof(Buffer) - 1, Buffer));
end;
{$ELSE}

function sysTempPath: string;
var
  Buffer: array[0..255] of char;
begin
  GetTempFileName(#0, 'TMP', 0, Buffer); { 15.07.96 sb }
  Result := StrPas(Buffer);
  DeleteFile(Result);
  Result := ExtractFilePath(Result);
end;
{$ENDIF}

(*procedure sysDelay(aMs: Longint);
var
  TickCount       : LongInt;
begin
  TickCount:=GetTickCount;
  while GetTickCount - TickCount < aMs do Application.ProcessMessages;
end;  *)

procedure sysBeep;
begin
  messageBeep($FFFF);
end;

function sysColorDepth: Integer;
var
  aDC: hDC;
begin
  aDC := 0;
  try
    aDC := GetDC(0);
    Result := 1 shl (GetDeviceCaps(aDC, PLANES) * GetDeviceCaps(aDC,
      BITSPIXEL));
  finally
    ReleaseDC(0, aDC);
  end;
end;

function OS_MaiorQue256Cores: Boolean;
var
  QtdeCores: Integer;
begin
  QtdeCores := sysColorDepth;

  Result := (QtdeCores > 256) or (QtdeCores = 1);

end;

function TempodeDesigner: Boolean;
begin
  Result := (FindWindow('TAppBuilder', nil) <> 0);
end;

function MessageDlgDef(const Msg: string; AType: TMsgDlgType; AButtons:
  TMsgDlgButtons;
  DefButton: TModalResult; HelpCtx: LongInt): Word;
var
  i: Integer;
begin
  with CreateMessageDialog(Msg, AType, AButtons) do
  try
    HelpContext := HelpCtx;
    for i := 0 to ComponentCount - 1 do
      if (Components[i] is TButton) and (TButton(Components[i]).ModalResult =
        DefButton) then
        ActiveControl := (Components[i] as TWinControl);
    Result := ShowModal;
  finally
    Free;
  end;
end;

{$IFDEF Win32}

procedure sysSaverRunning(Active: Boolean);
var
  aParam: Longint;
begin
  SystemParametersInfo(SPI_SCREENSAVERRUNNING, Word(Active), @aParam, 0);
end;
{$ENDIF}

{ registry functions }

{$IFDEF Win32 }

procedure regParsePath(const Path: string; var aPath, aValue: string);
begin
  aPath := Path;
  aValue := '';
  while (Length(aPath) > 0) and (strLastCh(aPath) <> BARRA) do
  begin
    aValue := strLastCh(aPath) + aValue;
    strStripLast(aPath);
  end;
end;

function regReadString(aKey: HKEY; const Path: string): string;
var
  aRegistry: TRegistry;
  aPath: string;
  aValue: string;
begin
  aRegistry := TRegistry.Create;
  try
    with aRegistry do
    begin
      RootKey := aKey;
      regParsePath(Path, aPath, aValue);
      OpenKey(aPath, True);
      Result := ReadString(aValue);
    end;
  finally
    aRegistry.Free;
  end;
end;

procedure regWriteString(aKey: HKEY; const Path, Value: string);
var
  aRegistry: TRegistry;
  aPath: string;
  aValue: string;
begin
  aRegistry := TRegistry.Create;
  try
    with aRegistry do
    begin
      RootKey := aKey;
      regParsePath(Path, aPath, aValue);
      OpenKey(aPath, True);
      WriteString(aValue, Value);
    end;
  finally
    aRegistry.Free;
  end;
end;

procedure regDelValue(aKey: hKey; const Path: string);
var
  aRegistry: TRegistry;
  aPath: string;
  aValue: string;
begin
  aRegistry := TRegistry.Create;
  try
    with aRegistry do
    begin
      RootKey := aKey;
      regParsePath(Path, aPath, aValue);
      OpenKey(aPath, True);
      DeleteValue(aValue);
    end;
  finally
    aRegistry.Free;
  end;
end;

(*!!!
function regReadString(aKey: hKey; const Value: String): String;
var
  aTmp  : array[0..255] of char;
  aCb,
  aType : Integer;
begin
  Result:='';
  if aKey<> 0 then
  begin
    aCb:=Sizeof(aTmp)-1;
   { aData:=@aTmp; }
    if RegQueryValueEx(aKey,PChar(Value),nil,@aType,@aTmp,@aCb)=ERROR_SUCCESS then
       if aType=REG_SZ then Result:=String(aTmp);
  end;
end; *)

function regInfoString(const Value: string): string;
var
  aKey: hKey;
begin
  Result := '';
  if RegOpenKey(HKEY_LOCAL_MACHINE, REG_CURRENT_VERSION, aKey) = ERROR_SUCCESS
    then
  begin
    Result := regReadString(aKey, Value);
    RegCloseKey(aKey);
  end;
end;

function regCurrentUser: string;
begin
  Result := regInfoString(REG_CURRENT_USER);
end;

function regCurrentCompany: string;
begin
  Result := regInfoString(REG_CURRENT_COMPANY);
end;

{ Add a shell extension to the registry }

procedure regWriteShellExt(const aExt, aCmd, aMenu, aExec: string);
var
  s, aPath: string;
begin
  with TRegistry.Create do
  try
    RootKey := HKEY_CLASSES_ROOT;
    aPath := aExt;
    if KeyExists(aPath) then
    begin
      OpenKey(aPath, False);
      S := ReadString('');
      CloseKey;
      if S <> '' then
        if KeyExists(S) then
          aPath := S;
    end;

    OpenKey(aPath + '\Shell\' + aCmd, True);
    WriteString('', aMenu);
    CloseKey;

    OpenKey(aPath + '\Shell\' + aCmd + '\Command', True);
    WriteString('', aExec + ' %1');
    CloseKey;
  finally
    Free;
  end;
end;

procedure regValueList(aKey: HKEY; const Path: string; var aValue: TStringList);
var
  aRegistry: TRegistry;
begin
  aRegistry := TRegistry.Create;
  try
    with aRegistry do
    begin
      RootKey := aKey;
      OpenKey(Path, True);
      GetValueNames(aValue);
    end;
  finally
    aRegistry.Free;
  end;
end;

procedure regKeyList(aKey: HKEY; const Path: string; var aValue: TStringList);
var
  aRegistry: TRegistry;
begin
  aRegistry := TRegistry.Create;
  try
    with aRegistry do
    begin
      RootKey := aKey;
      OpenKey(Path, True);
      GetKeyNames(aValue);
    end;
  finally
    aRegistry.Free;
  end;
end;

function regValueExist(aKey: HKEY; const Path: string): Boolean;
var
  aRegistry: TRegistry;
  aPath: string;
  aValue: string;
begin
  aRegistry := TRegistry.Create;
  try
    with aRegistry do
    begin
      RootKey := aKey;
      regParsePath(Path, aPath, aValue);
      OpenKey(aPath, True);
      Result := ValueExists(aValue)
    end;
  finally
    aRegistry.Free;
  end;
end;

function regReadValue(aKey: HKEY; const Path: string; Typ: TDataType): Variant;
var
  aRegistry: TRegistry;
  aPath: string;
  aValue: string;
begin
  aRegistry := TRegistry.Create;
  try
    with aRegistry do
    begin
      RootKey := aKey;
      regParsePath(Path, aPath, aValue);
      if OpenKey(aPath, True) then
        if ValueExists(aValue) then
          case Typ of
            dtInteger: Result := ReadInteger(aValue);
            dtBoolean: Result := ReadBool(aValue);
            dtString: Result := ReadString(aValue);
            dtDate: Result := ReadDate(aValue);
            dtFloat: Result := ReadFloat(aValue);
            dtCurrency: Result := ReadCurrency(aValue);
            dtTime: Result := REadTime(aValue);
          end;
    end;
  finally
    aRegistry.Free;
  end;
end;

function regWriteValue(aKey: HKEY; const Path: string; Value: Variant; Typ:
  TDataType): Boolean;
var
  aRegistry: TRegistry;
  aPath: string;
  aValue: string;
begin
  Result := True;
  aRegistry := TRegistry.Create;
  try
    with aRegistry do
    begin
      RootKey := aKey;
      regParsePath(Path, aPath, aValue);
      if OpenKey(aPath, True) then
        case Typ of
          dtInteger: WriteInteger(aValue, Value);
          dtBoolean: WriteBool(aValue, Value);
          dtString: WriteString(aValue, Value);
          dtDate: WriteDate(aValue, Value);
          dtFloat: WriteFloat(aValue, Value);
          dtCurrency: WriteCurrency(aValue, Value);
          dtTime: WriteTime(aValue, Value);
        end
      else
        Result := False;
    end;
  finally
    aRegistry.Free;
  end;
end;

{$ENDIF}

{ other stuff }

function MsgBox(const aTitle, aMsg: string; aFlag: Integer): Integer;
var
  ActiveWindow: hWnd;
  WindowList: Pointer;
  TmpA: array[0..200] of char;
  TmpB: array[0..100] of char;
begin
  ActiveWindow := GetActiveWindow;
  WindowList := DisableTaskWindows(0);
  try
    StrPCopy(TmpB, aTitle);
    StrPCopy(TmpA, aMsg);
{$IFDEF Win32}
    Result := Windows.MessageBox(Application.Handle, TmpA, TmpB, aFlag);
{$ELSE}
    Result := WinProcs.MessageBox(Application.Handle, TmpA, TmpB, aFlag);
{$ENDIF}
  finally
    EnableTaskWindows(WindowList);
    SetActiveWindow(ActiveWindow);
  end;
end;

{function Question(const Msg: String):Boolean;
begin
  if IsWin95 or IsWinNT then
    Result:=MsgBox(LoadStr(SMsgdlgConfirm),Msg, MB_ICONQUESTION or MB_YESNO)=IDYES
  else
    Result:=messageDlg(Msg,mtConfirmation,[mbYes,mbNo],0)=mrYes;
end;}

{procedure Information(const Msg: String);
begin
  if IsWin95 or IsWinNT then
     MsgBox(LoadStr(SMsgdlgInformation), Msg, MB_ICONINFORMATION or MB_OK )
  else
     messageDlg(Msg,mtInformation,[mbOk],0);
end;}

{function Confirmation(const Msg: String): Word;
begin
  if IsWin95 or IsWinNT then
     case MsgBox(LoadStr(SMsgDlgConfirm),Msg,MB_ICONQUESTION or MB_YESNOCANCEL) of
       IDYES    : Result := mrYes;
       IDNO     : Result := mrNo;
       IDCANCEL : Result := mrCancel;
       else       Result := mrCancel;
     end
  else
     Result:=MessageDlg(Msg,mtConfirmation,[mbYes,mbNo,mbCancel],0);
end;
}

{ TPersistentRect }

constructor TPersistentRect.Create;
begin
  FRect := rectSet(10, 10, 100, 20);
end;

procedure TPersistentRect.Assign(Source: TPersistent);
var
  Value: TPersistentRect;
begin
  Value := Source as TPersistentRect;
  FRect := rectBounds(Value.Left, Value.Top, Value.Width, Value.Height);
  exit;
  inherited Assign(Source);
end;

procedure TPersistentRect.SetLeft(Value: Integer);
begin
  if Value <> Left then
  begin
    if Assigned(FOnConvert) then
      Value := FOnConvert(Self, Value, False);
    FRect := rectBounds(Value, Top, Width, Height);
  end;
end;

procedure TPersistentRect.SetTop(Value: Integer);
begin
  if Value <> Top then
  begin
    if Assigned(FOnConvert) then
      Value := FOnConvert(Self, Value, False);
    FRect := rectBounds(Left, Value, Width, Height);
  end;
end;

procedure TPersistentRect.SetHeight(Value: Integer);
begin
  if Value <> Height then
  begin
    if Assigned(FOnConvert) then
      Value := FOnConvert(Self, Value, False);
    FRect := rectBounds(Left, Top, Width, Value);
  end;
end;

procedure TPersistentRect.SetWidth(Value: Integer);
begin
  if Value <> Width then
  begin
    if Assigned(FOnConvert) then
      Value := FOnConvert(Self, Value, False);
    FRect := rectBounds(Left, Top, Value, Height);
  end;
end;

function TPersistentRect.GetLeft: Integer;
begin
  Result := FRect.Left;
  if Assigned(FOnConvert) then
    Result := FOnConvert(Self, Result, True);
end;

function TPersistentRect.GetTop: Integer;
begin
  Result := FRect.Top;
  if Assigned(FOnConvert) then
    Result := FOnConvert(Self, Result, True);
end;

function TPersistentRect.GetHeight: Integer;
begin
  Result := rectHeight(FRect);
  if Assigned(FOnConvert) then
    Result := FOnConvert(Self, Result, True);
end;

function TPersistentRect.GetWidth: Integer;
begin
  Result := rectWidth(FRect);
  if Assigned(FOnConvert) then
    Result := FOnConvert(Self, Result, True);
end;

{$IFDEF Win32}

{ TPersistentRegistry }

function TPersistentRegistry.ReadComponent(const Name: string;
  Owner, Parent: TComponent): TComponent;
var
  DataSize: Integer;
  MemStream: TMemoryStream;
  Reader: TReader;
begin
  DataSize := GetDataSize(Name);
  MemStream := TMemoryStream.Create;
  try
    MemStream.SetSize(DataSize);
    ReadBinaryData(Name, MemStream.Memory^, DataSize);
    MemStream.Position := 0;

    Reader := TReader.Create(MemStream, 256);
    try
      Reader.Parent := Parent;
      Result := Reader.ReadRootComponent(nil);
      if Owner <> nil then
      try
        Owner.InsertComponent(Result);
      except
        Result.Free;
        raise;
      end;
    finally
      Reader.Free;
    end;

  finally
    MemStream.Free;
  end;
end;

procedure TPersistentRegistry.WriteComponent(const Name: string; Component:
  TComponent);
var
  MemStream: TMemoryStream;
begin
  MemStream := TMemoryStream.Create;
  try
    MemStream.WriteComponent(Component);
    WriteBinaryData(Name, MemStream.Memory^, MemStream.Size);
  finally
    MemStream.Free;
  end;
end;

{$ENDIF}

{ TSystemMetric }

constructor TSystemMetric.Create;
begin
  inherited Create;
  Update;
end;

procedure TSystemMetric.Update;

  function GetSystemPoint(ax, ay: Integer): TPoint;
  begin
    Result := Point(GetSystemMetrics(ax), GetSystemMetrics(ay));
  end;

begin
  FMenuHeight := GetSystemMetrics(SM_CYMENU);
  FCaptionHeight := GetSystemMetrics(SM_CYCAPTION);
  FBorder := GetSystemPoint(SM_CXBORDER, SM_CYBORDER);
  FFrame := GetSystemPoint(SM_CXFRAME, SM_CYFRAME);
  FDlgFrame := GetSystemPoint(SM_CXDLGFRAME, SM_CYDLGFRAME);
  FBitmap := GetSystemPoint(SM_CXSIZE, SM_CYSIZE);
  FHScroll := GetSystemPoint(SM_CXHSCROLL, SM_CYHSCROLL);
  FVScroll := GetSystemPoint(SM_CXVSCROLL, SM_CYVSCROLL);
  FThumb := GetSystemPoint(SM_CXHTHUMB, SM_CYVTHUMB);
  FFullScreen := GetSystemPoint(SM_CXFULLSCREEN, SM_CYFULLSCREEN);
  FMin := GetSystemPoint(SM_CXMIN, SM_CYMIN);
  FMinTrack := GetSystemPoint(SM_CXMINTRACK, SM_CYMINTRACK);
  FCursor := GetSystemPoint(SM_CXCURSOR, SM_CYCURSOR);
  FIcon := GetSystemPoint(SM_CXICON, SM_CYICON);
  FDoubleClick := GetSystemPoint(SM_CXDOUBLECLK, SM_CYDOUBLECLK);
  FIconSpacing := GetSystemPoint(SM_CXICONSPACING, SM_CYICONSPACING);
  FColorDepth := sysColorDepth;
end;

{ TDesktopCanvas }

constructor TDesktopCanvas.Create;
begin
  inherited Create;
  DC := GetDC(0);
  Handle := DC;
end;

destructor TDesktopCanvas.Destroy;
begin
  Handle := 0;
  ReleaseDC(0, DC);
  inherited Destroy;
end;

{$IFNDEF Win32}

procedure DoneXProcs; far;
begin
  SysMetric.Free;
end;

{$ENDIF}

{$IFDEF Win32}

function CheckNT: Boolean;
var
  aVersion: TOSVersionInfo;
begin
  aVersion.dwOSVersionInfoSize := SizeOf(aVersion);
  Result := GetVersionEx(aVersion) and (aVersion.dwPLatformId =
    VER_PLATFORM_WIN32_NT);
end;
{$ENDIF}

function FileVerInfo(const Arquivo: string): string;
var
  Major, Minor, Release, Build: Integer;
  Zero: DWORD; {a variavel que recebe zero}
  TamanhoVersao: DWORD;
  PDadosVersao: pointer;
  PInfoFixaArquivo: PVSFixedFileInfo;
  TamanhoFixoInfoArquivo: UINT; //Inteiro de 32 bits;
begin
  Major := 0;
  Minor := 0;
  Release := 0;
  Build := 0;
  {Pergunta ao windows tamanho do buffer para alocar a informação sobre a versão}

  TamanhoVersao := GetFileVersionInfoSize(pChar(Arquivo), Zero);

  {Se não há informações sobre a versão}

  if TamanhoVersao = 0 then
  begin
    result := '';
    ShowMessage('Sem informações sobre a versão no arquivo '+Arquivo);
    exit;
  end;

  {Aloca memória para guardar as informaçoes da versão}

  PDadosVersao := AllocMem(TamanhoVersao);

  try

    {Carrega recurso da versão do executável}

    if GetFileVersionInfo(pChar(Arquivo), 0, TamanhoVersao, PDadosVersao) = false
      then
      raise Exception.Create('Impossível obter informações da versão');

    {Pega a porção fixa sobre a versão no buffer}

    if VerQueryValue(PDadosVersao, '\', pointer(PInfoFixaArquivo),
      TamanhoFixoInfoArquivo) = false then
    begin

      {Sem informações fixas nos recursos do arquivo}

      ShowMessage('Sem informações fixas sobre a versão');
      result := '';
      exit;
    end;

    {Extrai as informações fixas do resource do arquivo}

    Major := PInfoFixaArquivo^.dwFileVersionMS shr 16;
    Minor := PInfoFixaArquivo^.dwFileVersionMS and $FFFF;
    Release := PInfoFixaArquivo^.dwFileVersionLS shr 16;
    Build := PInfoFixaArquivo^.dwFileVersionLS and $FFFF;
  finally
    FreeMem(PDadosVersao);
  end;
  result := IntToStr(Major) + '.' + IntToStr(Minor) + '.' + IntToStr(Release) +
    '.' + IntToStr(Build);
end;

function GetAdapterStatus: string;
var
  ncb: TNCB;
  //  res : Byte;
  //  NetName : array[0..50] of char;
  Adapter: TAdapter;
begin
  FillChar(ncb, sizeof(ncb), 0);
  ncb.ncb_command := Char(NCBRESET);
  ncb.ncb_lana_num := Char(0);
  //  res := Byte(NetBios(@ncb));

  FillChar(ncb, sizeof(ncb), 0);
  ncb.ncb_command := Char(NCBASTAT);
  ncb.ncb_lana_num := Char(0);
  StrCopy(ncb.ncb_callname, '* ');
  ncb.ncb_buffer := @Adapter;
  ncb.ncb_length := sizeof(Adapter);
  //  res := Byte(NetBios(@ncb));
  with Adapter.Adapt do
  begin
    Result := IntToHex(Integer(adapter_address[0]), 2) +
      IntToHex(Integer(adapter_address[1]), 2) +
      IntToHex(Integer(adapter_address[2]), 2) +
      IntToHex(Integer(adapter_address[3]), 2) +
      IntToHex(Integer(adapter_address[4]), 2) +
      IntToHex(Integer(adapter_address[5]), 2);
  end;
end;

function ValorPorExtenso(Literal: Double): string;
var
  i, centena, dezena, unidade: integer;
  valor, monta, extenso: string;
begin
  extenso := '';
  if literal = 0.00 then
    result := 'Zero'
  else
  begin
    valor := FormatFloat('000000000000.00', literal);
    i := 1;
    while i <= 13 do
    begin
      if (Pos(valor[i], '0123456789') = 0) then
        valor[i] := '0';
      if (Pos(valor[i + 1], '0123456789') = 0) then
        valor[i + 1] := '0';
      if (Pos(valor[i + 2], '0123456789') = 0) then
        valor[i + 2] := '0';
      if (i = 13) then
        centena := 0
      else
        centena := StrToInt(valor[i]);
      dezena := StrToInt(valor[i + 1]);
      if dezena > 1 then
        unidade := StrToInt(valor[i + 2])
      else
        unidade := StrToInt(copy(valor, (i + 1), 2));

      if (((i = 13) and (StrToFloat(copy(valor, 14, 2)) > 0.01)) and
        ((StrToFloat(copy(valor, 1, 12))) <> 0.00)) then
        extenso := Trim(extenso) + ' e';
      monta :=
        'Duzentos    Trezentos   QuatrocentosQuinhentos  Seiscentos  Setecentos  Oitocentos  Novecentos';

      if ((dezena + unidade) = 0) then
        monta := '            Cem         ' + monta
      else
        monta := '            Cento       ' + monta;
      extenso := Trim(extenso) + ' ' + Trim(copy(monta, ((centena * 12) + 1),
        12));

      if ((centena <> 0) and ((dezena + unidade) > 0)) then
        extenso := Trim(extenso) + ' e';
      monta :=
        '                  Vinte    Trinta   Quarenta CinquentaSessenta Setenta  Oitenta  Noventa';
      extenso := Trim(extenso) + ' ' + Trim(copy(monta, ((dezena * 9) + 1), 9));

      if ((dezena > 1) and (unidade > 0)) then
        extenso := Trim(extenso) + ' e';
      monta :=
        '         Um       Dois     Tres     Quatro   Cinco    Seis     Sete     Oito     Nove     Dez      Onze     Doze     Treze    Quatorze Quinze   Dezeseis Dezesete Dezoito  Dezenove';
      extenso := Trim(extenso) + ' ' + Trim(copy(monta, ((unidade * 9) + 1),
        9));
      if ((centena + dezena + unidade) > 0) then
      begin
        if i = 1 then
          if (((centena + dezena) = 0) and (unidade <= 1)) then
            extenso := Trim(extenso) + ' Bilhão'
          else
            extenso := Trim(extenso) + ' Bilhões';
        if (i = 4) then
          if ((centena + dezena = 0) and (unidade <= 1)) then
            extenso := Trim(extenso) + ' Milhão'
          else
            extenso := Trim(extenso) + ' Milhões';
        if i = 7 then
          extenso := Trim(extenso) + ' Mil';
        if ((i < 10) and (StrToFloat(copy(valor, (i + 3), (13 - i))) > 1.00))
          then
          extenso := extenso + ' e';
      end;
      if ((i = 1) and (StrToFloat(copy(valor, 4, 9)) = 0.00) and ((centena +
        unidade + dezena) <> 0)) then
        extenso := Trim(extenso) + ' de';
      if ((i = 4) and (StrToFloat(copy(valor, 7, 6)) = 0.00) and ((centena +
        unidade + dezena) <> 0)) then
        extenso := Trim(extenso) + ' de';
      if ((i = 10) and (StrToFloat(copy(valor, 1, 12)) <> 0.00)) then
        if (StrToFloat(copy(valor, 1, 12)) = 1.00) then
          extenso := Trim(extenso) + ' Real'
        else
          extenso := Trim(extenso) + ' Reais';
      if ((i = 13) and ((dezena + unidade) <> 0)) then
        if ((dezena + unidade) = 1) then
          extenso := Trim(extenso) + ' Centavo'
        else
          extenso := Trim(extenso) + ' Centavos';
      i := i + 3;
    end;
    if literal < 0.00 then
      extenso := Trim(extenso) + ' Negativo';
    if (literal < 1.0) then
      if (StrToInt(copy(valor, 14, 2)) = 1) then
        extenso := Trim(extenso) + ' de Real'
          //  "de real/de reais" podem ser substituidos por campos de arquivos de parametros
      else // o que dá mais flexibilidade, caso aconteçam mais planos econômicos.
        extenso := Trim(extenso) + ' de Reais';
    result := extenso;
  end;
end;

function NumeroPorExtenso(Literal: Integer): string;
var
  i, centena, dezena, unidade: integer;
  valor, monta, extenso: string;
begin
  extenso := '';
  if literal = 0.00 then
    result := 'Zero'
  else
  begin
    valor := FormatFloat('000000000000.00', literal);
    i := 1;
    while i <= 13 do
    begin
      if (Pos(valor[i], '0123456789') = 0) then
        valor[i] := '0';
      if (Pos(valor[i + 1], '0123456789') = 0) then
        valor[i + 1] := '0';
      if (Pos(valor[i + 2], '0123456789') = 0) then
        valor[i + 2] := '0';
      if (i = 13) then
        centena := 0
      else
        centena := StrToInt(valor[i]);
      dezena := StrToInt(valor[i + 1]);
      if dezena > 1 then
        unidade := StrToInt(valor[i + 2])
      else
        unidade := StrToInt(copy(valor, (i + 1), 2));

      if (((i = 13) and (StrToFloat(copy(valor, 14, 2)) > 0.01)) and
        ((StrToFloat(copy(valor, 1, 12))) <> 0.00)) then
        extenso := Trim(extenso) + ' e';
      monta :=
        'Duzentos    Trezentos   QuatrocentosQuinhentos  Seiscentos  Setecentos  Oitocentos  Novecentos';

      if ((dezena + unidade) = 0) then
        monta := '            Cem         ' + monta
      else
        monta := '            Cento       ' + monta;
      extenso := Trim(extenso) + ' ' + Trim(copy(monta, ((centena * 12) + 1),
        12));

      if ((centena <> 0) and ((dezena + unidade) > 0)) then
        extenso := Trim(extenso) + ' e';
      monta :=
        '                  Vinte    Trinta   Quarenta CinquentaSessenta Setenta  Oitenta  Noventa';
      extenso := Trim(extenso) + ' ' + Trim(copy(monta, ((dezena * 9) + 1), 9));

      if ((dezena > 1) and (unidade > 0)) then
        extenso := Trim(extenso) + ' e';
      monta :=
        '         Um       Dois     Tres     Quatro   Cinco    Seis     Sete     Oito     Nove     Dez      Onze     Doze     Treze    Quatorze Quinze   Dezeseis Dezesete Dezoito  Dezenove';
      extenso := Trim(extenso) + ' ' + Trim(copy(monta, ((unidade * 9) + 1),
        9));
      if ((centena + dezena + unidade) > 0) then
      begin
        if i = 1 then
          if (((centena + dezena) = 0) and (unidade <= 1)) then
            extenso := Trim(extenso) + ' Bilhão'
          else
            extenso := Trim(extenso) + ' Bilhões';
        if (i = 4) then
          if ((centena + dezena = 0) and (unidade <= 1)) then
            extenso := Trim(extenso) + ' Milhão'
          else
            extenso := Trim(extenso) + ' Milhões';
        if i = 7 then
          extenso := Trim(extenso) + ' Mil';
        if ((i < 10) and (StrToFloat(copy(valor, (i + 3), (13 - i))) > 1.00))
          then
          extenso := extenso + ' e';
      end;
      if ((i = 1) and (StrToFloat(copy(valor, 4, 9)) = 0.00) and ((centena +
        unidade + dezena) <> 0)) then
        extenso := Trim(extenso) + ' de';
      if ((i = 4) and (StrToFloat(copy(valor, 7, 6)) = 0.00) and ((centena +
        unidade + dezena) <> 0)) then
        extenso := Trim(extenso) + ' de';
      i := i + 3;
    end;
    result := extenso;
  end;
end;

function DataPromissoria(Data: TDate): string;
var
  Dia, Mes, Ano: Word;
begin
  try
    DecodeDate(Data, Ano, Mes, Dia);
    if Dia = 1 then
      result := NumeroPorExtenso(Dia) + ' dia de ' + FormatDateTime('mmmm',Data) + ' do ano de ' +
        NumeroPorExtenso(Ano)
    else
      result := NumeroPorExtenso(Dia) + ' dias de ' + FormatDateTime('mmmm',Data) + ' do ano de ' +
        NumeroPorExtenso(Ano);
  except
    begin
      MessageDlg('Erro durante conversão de Data!', mtError, [mbOK], 0);
      result := '';
    end;
  end;
end;

function DataPorExtenso(Data: TDate): string;
var
  Dia, Mes, Ano: Word;
const
  Meses: array[1..12] of string = ('Janeiro', 'Fevereiro', 'Março', 'Abril',
    'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro',
    'Outubro', 'Novembro', 'Dezembro');
begin
  try
    DecodeDate(Data, Ano, Mes, Dia);
    result := IntToStr(Dia) + ' de ' + Meses[Mes] + ' de ' + IntToStr(Ano);
  except
    begin
      MessageDlg('Erro durante conversão de Data!', mtError, [mbOK], 0);
      result := '';
    end;
  end;
end;

function MesPorExtenso(Data: TDate): string;
var
  Dia, Mes, Ano: Word;
const
  Meses: array[1..12] of string = ('Janeiro', 'Fevereiro', 'Março', 'Abril',
    'Maio', 'Junho', 'Julho', 'Agosto', 'Setembro',
    'Outubro', 'Novembro', 'Dezembro');
begin
  try
    DecodeDate(Data, Ano, Mes, Dia);
    result := Meses[Mes];
  except
    begin
      MessageDlg('Erro durante conversão de Data!', mtError, [mbOK], 0);
      result := '';
    end;
  end;
end;

function MesPorExtenso(aMes: integer): string; overload;
const
  Meses: array[1..12] of string = ('Jan', 'Fev', 'Mar', 'Abr',
    'Mai', 'Jun', 'Jul', 'Ago', 'Set',
    'Out', 'Nov', 'Dez');
begin
  Result := Meses[aMes];
end;

function UltimoDiaMes(Mdt: TDateTime): TDateTime;
var
  ano, mes, dia : word;
  mDtTemp : TDateTime;
begin
  Decodedate(mDt, ano, mes, dia);
  mDtTemp := (mDt - dia) + 33;
  Decodedate(mDtTemp, ano, mes, dia);
  Result := mDtTemp - dia;
end;

function PrimeiroDiaMes(Data: TDateTime): TDateTime;
var
  Dia, Mes, Ano: Word;
begin
  DecodeDate (Data, Ano, Mes, Dia);
  Result := EncodeDate (Ano, Mes, 1);
end;


function RemoverAcentos(sTexto: string): string;
const
  ComAcento = 'àâêôûãõáéíóúçüÀÂÊÔÛÃÕÁÉÍÓÚÇÜ';
  SemAcento = 'aaeouaoaeioucuAAEOUAOAEIOUCU';
var
  x: Integer;
begin
  for x := 1 to Length(sTexto) do
    if Pos(sTexto[x], ComAcento) <> 0 then
      sTexto[x] := SemAcento[Pos(sTexto[x], ComAcento)];
  Result := sTexto;
end;

function RemoverCaracteres(aTexto: string): string;
const
  Caracteres = '"!@#$%¨&*()_-;|\/´`{[ª}]º^~<>?°*-+,.';
var
  x: Integer;
begin
  for x := 1 to Length(Trim(aTexto)) do
    if Pos(aTexto[x], Caracteres) <> 0 then
      aTexto[x] := ' ';
  Result := aTexto;
end;

function CalculaPercentual(Valor, ValPerc: Double): Currency;
begin
  Result := (Valor * ValPerc)/100;
end;

function AdicionaPercentual(Valor, ValPerc: Double): Currency;
begin
  Result := Valor + CalculaPercentual(Valor, ValPerc);
end;

function CalculaPercentVariacao(aValRef, aValAlt : Double) : Double;
begin
  Result := ((aValAlt - aValRef) * 100) / aValRef;
end;

function CalculaDifPercent(aValRef, aValAlt : Double) : Double;
begin
  if aValRef = 0 then
    Result := 0
  else
    Result := aValAlt * 100/ aValRef;//100 - Abs(CalculaPercentVariacao(aValRef, aValAlt));
end;

procedure CalculaValoresPisCofins(FlgIgnoraIdCtb, FlgNaoPisCof, NTransfCredForn: String; FlgSTPisCof, FlgIPIPisCof: Boolean; TipoNaoPisCof: Integer;
  ValTotal, ValIcmsST, ValIPI: Currency; PerPis, PerCofins, ValIcms: Double;
  var ValBasePis, ValBaseCofins, ValPis, ValCofins, ValIsentoPisCof, ValAliqZero, ValMonofasico, ValSubstituicao, ValNaoTribut, ValImune, ValSuspensao: Currency);
begin

  ValBasePis := 0.00;
  ValBaseCofins := 0.00;
  ValPis := 0.00;
  ValCofins := 0.00;
  ValIsentoPisCof := 0.00;
  ValAliqZero := 0.00;
  ValMonofasico := 0.00;
  ValSubstituicao := 0.00;
  ValNaoTribut := 0.00;
  ValImune := 0.00;
  ValSuspensao := 0.00;

  //Alimenta campos referentes ao PIS/Cofins
  if (FlgIgnoraIdCtb = 'N') and (FlgNaoPisCof = 'N') and (NTransfCredForn = 'N') then
  begin

    //Considerar o ICMS-ST e IPI na BC Crédito Pis/Cofins Regra de Empresa)
    if FlgSTPisCof and FlgIPIPisCof then
    begin
      ValBasePis := fltRound(ValTotal-ValIcms, 2);
      ValBaseCofins := fltRound(ValTotal-ValIcms, 2);
      ValPis := fltRound(((ValTotal-ValIcms) * (PerPIS/100)), 2);
      ValCofins := fltRound(((ValTotal-ValIcms) * (PerCofins/100)), 2);
    end
    else
    begin
    
      //Não considerar ST nem IPI na base
      if (not FlgSTPisCof) and (not FlgIPIPisCof) then
      begin
        ValBasePis := fltRound(ValTotal - ValIcmsST - ValIPI - ValIcms, 2);
        ValBaseCofins := fltRound(ValTotal - ValIcmsST - ValIPI - ValIcms, 2);
        ValPis := fltRound(((ValTotal - ValIcmsST - ValIPI-ValIcms) * (PerPIS/100)), 2);
        ValCofins := fltRound(((ValTotal - ValIcmsST - ValIPI-ValIcms) * (PerCofins/100)), 2);
      end;

      //Não considerar apenas ST
      if (not FlgSTPisCof) and (FlgIPIPisCof) then
      begin
        ValBasePis := fltRound(ValTotal - ValIcmsST - ValIcms, 2);
        ValBaseCofins := fltRound(ValTotal - ValIcmsST - ValIcms, 2);
        ValPis := fltRound(((ValTotal - ValIcmsST-ValIcms) * (PerPIS/100)), 2);
        ValCofins := fltRound(((ValTotal - ValIcmsST-ValIcms) * (PerCofins/100)), 2);
      end;

      //Não considerar apenas IPI
      if (FlgSTPisCof) and (not FlgIPIPisCof) then
      begin
        ValBasePis := fltRound(ValTotal - ValIPI - ValIcms, 2);
        ValBaseCofins := fltRound(ValTotal - ValIPI - ValIcms, 2);
        ValPis := fltRound(((ValTotal - ValIPI-ValIcms) * (PerPIS/100)), 2);
        ValCofins := fltRound(((ValTotal - ValIPI-ValIcms) * (PerCofins/100)), 2);
      end;

    end;

    ValIsentoPisCof := 0.00;
    ValAliqZero := 0.00;
    ValMonofasico := 0.00;
    ValSubstituicao := 0.00;
    ValNaoTribut := 0.00;
    ValImune := 0.00;
    ValSuspensao := 0.00
  end
  else
  begin
    if (FlgIgnoraIdCtb = 'S') or (NTransfCredForn = 'S') then
    begin
      ValBasePis := 0.00;
      ValBaseCofins := 0.00;
      ValPis := 0.00;
      ValCofins := 0.00;
      ValIsentoPisCof := 0.00;
      ValAliqZero := 0.00;
      ValMonofasico := 0.00;
      ValSubstituicao := 0.00;
      ValImune := 0.00;
      ValSuspensao := 0.00;

      if FlgSTPisCof and FlgIPIPisCof then
        ValNaoTribut := fltRound(ValTotal-ValIcms, 2);

      if (not FlgSTPisCof) and (not FlgIPIPisCof) then
        ValNaoTribut := fltRound(ValTotal - ValIcmsST - ValIPI-ValIcms, 2);

      if (not FlgSTPisCof) and (FlgIPIPisCof) then
        ValNaoTribut := fltRound(ValTotal - ValIcmsST-ValIcms, 2);

      if (FlgSTPisCof) and (not FlgIPIPisCof) then
        ValNaoTribut := fltRound(ValTotal - ValIPI-ValIcms, 2);

    end
    else
    begin
      ValPis := 0.00;
      ValCofins := 0.00;

      if FlgSTPisCof and FlgIPIPisCof then
        ValIsentoPisCof := fltRound(ValTotal-ValIcms, 2);

      if (not FlgSTPisCof) and (not FlgIPIPisCof) then
        ValIsentoPisCof := fltRound(ValTotal - ValIcmsST - ValIPI-ValIcms, 2);

      if (not FlgSTPisCof) and (FlgIPIPisCof) then
        ValIsentoPisCof := fltRound(ValTotal - ValIcmsST-ValIcms, 2);

      if (FlgSTPisCof) and (not FlgIPIPisCof) then
        ValIsentoPisCof := fltRound(ValTotal - ValIPI-ValIcms, 2);

      ValBasePis := 0.00;
      ValBaseCofins := 0.00;

      //Aliquota Zero
      if TipoNaoPisCof = 0 then
        ValAliqZero := fltRound(ValTotal - ValIcmsST-ValIcms, 2)
      else
        ValAliqZero := 0.00;

      //Monofasico
      if TipoNaoPisCof = 1 then
        ValMonofasico := fltRound(ValTotal - ValIcmsST-ValIcms, 2)
      else
        ValMonofasico := 0.00;

      //Substituição
      if TipoNaoPisCof = 2 then
        ValSubstituicao := fltRound(ValTotal - ValIcmsST-ValIcms, 2)
      else
        ValSubstituicao := 0.00;

      //Imune
      if TipoNaoPisCof = 3 then
        ValImune := fltRound(ValTotal - ValIcmsST-ValIcms, 2)
      else
        ValImune := 0.00;

      //Suspensão
      if TipoNaoPisCof = 4 then
        ValSuspensao := fltRound(ValTotal - ValIcmsST-ValIcms, 2)
      else
        ValSuspensao := 0.00;

      ValNaoTribut := 0.00;
      ValIsentoPisCof := 0.00;
    end;    
  end;//

end;

function PeriodoDataDias(DiaIni,DiaFim:Integer; MesAno,Semanal:String): TStringList;
var
  Dias, i, x: Integer;
  DtaIni, DtaFim: TDate;
begin
  //QtdDias recebe a quantidade de dias que tem um periodo
  //Exemplo: Mensal = 30 Dias - Semanal = 7 Dias
  Result := TStringList.Create;

  if Semanal = 'S' then
  begin
    if DiaIni <= DiaFim then
      Dias := (((7-DiaIni)+1)-(7-DiaFim))
    else
      Dias := (((7-DiaIni)+1)+(DiaFim));

    x := DiaIni;
    Result.Add(IntToStr(x));
    for i:=1 to Pred(Dias) do
    begin
      //Semanal - Dia 8 é o limite para voltar no dia 1
      inc(x);
      if x = 8 then
        x := 1;
      Result.Add(IntToStr(x));
    end;
  end
  else
  begin
    DtaIni := RetornaDataValida(strPadZeroL(IntToStr(DiaIni),2)+'/'+MesAno);

    if DiaIni <= DiaFim then
      DtaFim := RetornaDataValida(strPadZeroL(IntToStr(DiaFim),2)+'/'+MesAno)
    else
      DtaFim := IncMonth(RetornaDataValida(strPadZeroL(IntToStr(DiaFim),2)+'/'+MesAno));

    while DtaIni <= DtaFim do
    begin
      Result.Add(FormatDateTime('DD',DtaIni));
      DtaIni := IncDay(DtaIni,1);
    end;
  end;

 { if DiaIni <= DiaFim then
    Dias := (((QtdDias-DiaIni)+1)-(QtdDias-DiaFim))
  else
    Dias := (((QtdDias-DiaIni)+1)+(DiaFim));

  Result := TStringList.Create;

  x := DiaIni;
  Result.Add(IntToStr(x));
  for i:=1 to Pred(Dias) do
  begin
    //Mensal - Dia 31 é o limite para voltar no dia 1
    //Semanal - Dia 8 é o limite para voltar no dia 1
    if x = (QtdDias+1) then
      x := 1;
    inc(x);

    Result.Add(IntToStr(x));
  end; }
end;

function  RetornaDataValida(pData : string) : TDate;
var
  dia, mes , ano :string;
begin
   if Length(pData) = 10 then
   begin
     dia := Copy(pData,1,2);
     mes := Copy(pData,4,2);
     ano := Copy(pData,7,4);

     if(StrToInt(Mes) = 1) and (StrToInt(dia) > 31) then
       Result := StrToDate('31/'+mes+'/'+ano)
     else if(StrToInt(Mes) = 2) and (StrToInt(dia) > 28) then
       Result := StrToDate('28/'+mes+'/'+ano)
     else if(StrToInt(Mes) = 3) and (StrToInt(dia) > 31) then
       Result := StrToDate('31/'+mes+'/'+ano)
     else if(StrToInt(Mes) = 4) and (StrToInt(dia) > 30) then
       Result := StrToDate('30/'+mes+'/'+ano)
     else if(StrToInt(Mes) = 5) and (StrToInt(dia) > 31) then
       Result := StrToDate('31/'+mes+'/'+ano)
     else if(StrToInt(Mes) = 6) and (StrToInt(dia) > 30) then
       Result := StrToDate('30/'+mes+'/'+ano)
     else if(StrToInt(Mes) = 7) and (StrToInt(dia) > 31) then
       Result := StrToDate('31/'+mes+'/'+ano)
     else if(StrToInt(Mes) = 8) and (StrToInt(dia) > 31) then
       Result := StrToDate('31/'+mes+'/'+ano)
     else if(StrToInt(Mes) = 9) and (StrToInt(dia) > 30) then
       Result := StrToDate('30/'+mes+'/'+ano)
     else if(StrToInt(Mes) = 10) and (StrToInt(dia) > 31) then
       Result := StrToDate('31/'+mes+'/'+ano)
     else if(StrToInt(Mes) = 11) and (StrToInt(dia) > 30) then
       Result := StrToDate('30/'+mes+'/'+ano)
     else if(StrToInt(Mes) = 12) and (StrToInt(dia) > 31) then
       Result := StrToDate('31/'+mes+'/'+ano)
     else
       Result := StrToDate(dia+'/'+mes+'/'+ano)
   end;
end;

function CorrigeDataInvertida(aDta: string): TDate;
begin
  Try
    Result := StrToDate(Copy(aDta,7,2)+'/'+Copy(aDta,5,2)+'/'+Copy(aDta,1,4));
  Except
    Result := 0.00
  End
end;


function KillTask(ExeFileName: string): Integer;
const
  PROCESS_TERMINATE = $0001;
var
  ContinueLoop: BOOL;
  FSnapshotHandle: THandle;
  FProcessEntry32: TProcessEntry32;
begin
  Result := 0;
  FSnapshotHandle := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  FProcessEntry32.dwSize := SizeOf(FProcessEntry32);
  ContinueLoop := Process32First(FSnapshotHandle, FProcessEntry32);

  while Integer(ContinueLoop) <> 0 do
  begin
    if ((UpperCase(ExtractFileName(FProcessEntry32.szExeFile)) =
      UpperCase(ExeFileName)) or (UpperCase(FProcessEntry32.szExeFile) =
      UpperCase(ExeFileName))) then
      Result := Integer(TerminateProcess(
        OpenProcess(PROCESS_TERMINATE,
        BOOL(0),
        FProcessEntry32.th32ProcessID),
        0));
    ContinueLoop := Process32Next(FSnapshotHandle, FProcessEntry32);
  end;
  CloseHandle(FSnapshotHandle);
end;

function MataProcesso(aProcessName : String) : Boolean;
const
  PROCESS_TERMINATE = $0001;
var
  ContinueLoop: BOOL;
  FSnapshotHandle: THandle;
  FProcessEntry32: TProcessEntry32;
begin
  FSnapshotHandle := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  FProcessEntry32.dwSize := SizeOf(FProcessEntry32);
  ContinueLoop := Process32First(FSnapshotHandle, FProcessEntry32);
  while Integer(ContinueLoop) <> 0 do
  begin
    if ((UpperCase(ExtractFileName(FProcessEntry32.szExeFile)) =
      UpperCase(aProcessName)) or (UpperCase(FProcessEntry32.szExeFile) =
      UpperCase(aProcessName))) then
      Result := Integer(TerminateProcess(
                        OpenProcess(PROCESS_TERMINATE,
                                    BOOL(0),
                                    FProcessEntry32.th32ProcessID),
                                    0)) > 0;
     ContinueLoop := Process32Next(FSnapshotHandle, FProcessEntry32);
  end;
  CloseHandle(FSnapshotHandle);
end;

function GetPastaUsuario : string;
var
  Registro: TRegistry;
begin
  Registro := TRegistry.Create;
  try
    Registro.OpenKeyReadOnly('Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders\');
    Result := Registro.ReadString('AppData');
  finally
    FreeAndNil(Registro);
  end;
end;

function InputComData(var Data: string): Boolean;
var 
  Form: TForm; 
  Edt: TMaskEdit; 
begin 
  Result := false;

  Form := TForm.Create(Application); 
  try 
    {config form} 
    Form.BorderStyle := bsDialog; 
    Form.Caption := 'Data'; 
    Form.Position := poScreenCenter; 
    Form.Width := 200; 
    Form.Height := 150; 

    {config label} 
    with TLabel.Create(Form) do begin 
      Parent := Form; 
      Caption := 'Entre com a data:'; 
      Left := 10; 
      Top := 10; 
    end; 

    {config edit mask} 
    Edt := TMaskEdit.Create(Form); 
    with Edt do begin 
      Parent := Form; 
      Left := 10; 
      Top := 25; 
      Width := Form.ClientWidth - 20; 
      EditMask := '!99/99/0000;1;_'; 
    end; 

    {config btn ok} 
    with TBitBtn.Create(Form) do begin 
      Parent := Form; 
      { Posiciona de acordo com a largura do form } 
      Left := Form.ClientWidth - (Width * 2) - 20; 
      Top := 70; 
      Kind := bkOK; 
    end; 

    {config btn cancel} 
    with TBitBtn.Create(Form) do begin 
      Parent := Form; 
      Left := Form.ClientWidth - Width - 10; 
      Top := 70; 
      Kind := bkCancel; { Botão Cancel } 
    end; 

    {Se for OK... } 
    if Form.ShowModal = mrOK then begin 
      if edt.Text = '  /  /    ' then 
        Data := '' 
      else 
        Data := Edt.Text; 
      Result := true; 
    end; 
  finally 
    Form.Free; 
  end; 
end;

function InputComFone(var Fone: string): Boolean;
var
  Form: TForm;
  Edt: TMaskEdit;
begin
  Result := false;

  Form := TForm.Create(Application);
  try 
    {config form} 
    Form.BorderStyle := bsDialog; 
    Form.Caption := 'Fone';
    Form.Position := poScreenCenter; 
    Form.Width := 200; 
    Form.Height := 150; 

    {config label}
    with TLabel.Create(Form) do begin 
      Parent := Form; 
      Caption := 'Entre com o Fone:';
      Left := 10; 
      Top := 10;
    end; 

    {config edit mask} 
    Edt := TMaskEdit.Create(Form); 
    with Edt do begin
      Parent := Form; 
      Left := 10; 
      Top := 25; 
      Width := Form.ClientWidth - 20; 
      EditMask := '(99)9999\-9999;0;';
    end; 

    {config btn ok} 
    with TBitBtn.Create(Form) do begin 
      Parent := Form;
      { Posiciona de acordo com a largura do form } 
      Left := Form.ClientWidth - (Width * 2) - 20; 
      Top := 70; 
      Kind := bkOK; 
    end;

    {config btn cancel} 
    with TBitBtn.Create(Form) do begin 
      Parent := Form;
      Left := Form.ClientWidth - Width - 10; 
      Top := 70; 
      Kind := bkCancel; { Botão Cancel }
    end;

    {Se for OK... }
    if Form.ShowModal = mrOK then begin
      if edt.Text = '(  )    -    ' then
        Fone := ''
      else
        Fone := Edt.Text;
      Result := true;
    end;
  finally
    Form.Free; 
  end;
end;

function InputComCel(var Cel: string): Boolean;
var
  Form: TForm;
  Edt: TMaskEdit;
begin
  Result := false;

  Form := TForm.Create(Application);
  try 
    {config form} 
    Form.BorderStyle := bsDialog; 
    Form.Caption := 'Celular';
    Form.Position := poScreenCenter; 
    Form.Width := 200; 
    Form.Height := 150; 

    {config label}
    with TLabel.Create(Form) do begin 
      Parent := Form; 
      Caption := 'Entre com o Celular:';
      Left := 10; 
      Top := 10;
    end; 

    {config edit mask} 
    Edt := TMaskEdit.Create(Form); 
    with Edt do begin
      Parent := Form; 
      Left := 10; 
      Top := 25; 
      Width := Form.ClientWidth - 20; 
      EditMask := '(99)99999\-9999;0;';
    end; 

    {config btn ok} 
    with TBitBtn.Create(Form) do begin 
      Parent := Form;
      { Posiciona de acordo com a largura do form } 
      Left := Form.ClientWidth - (Width * 2) - 20; 
      Top := 70; 
      Kind := bkOK; 
    end;

    {config btn cancel} 
    with TBitBtn.Create(Form) do begin 
      Parent := Form;
      Left := Form.ClientWidth - Width - 10; 
      Top := 70; 
      Kind := bkCancel; { Botão Cancel }
    end;

    {Se for OK... }
    if Form.ShowModal = mrOK then begin
      if edt.Text = '(  )     -    ' then
        Cel := ''
      else
        Cel := Edt.Text;
      Result := true;
    end;
  finally
    Form.Free; 
  end;
end;


procedure DisableTaskMgr(bTF: Boolean);
var
  reg: TRegistry;
begin
  reg := TRegistry.Create;
  reg.RootKey := HKEY_CURRENT_USER;

  reg.OpenKey('Software', True);
  reg.OpenKey('Microsoft', True);
  reg.OpenKey('Windows', True);
  reg.OpenKey('CurrentVersion', True);
  reg.OpenKey('Policies', True);
  reg.OpenKey('System', True);

  if bTF = True then
  begin
    reg.WriteString('DisableTaskMgr', '1');
  end
  else if bTF = False then
  begin
    reg.DeleteValue('DisableTaskMgr');
  end;
  reg.CloseKey;
end;

procedure CriaTabModDocFiscal(var Tab: TClientDataset; AOwner: TComponent);
var
  i: integer;
const
  aDados: array[1..21, 0..1] of string = (
    ('01', 'Nota Fiscal'),
    ('02', 'Nota Fiscal de Venda a Consumidor'),
    ('03', 'Nota Fiscal de Entrada'),
    ('04', 'Nota Fiscal de Produtor'),
    ('06', 'Nota Fiscal / Compra de Energia Eletrica'),
    ('07', 'Nota Fiscal de Serviço de Transporte'),
    ('08', 'Conhecimento de Transporte Rodoviário de Cargas'),
    ('09', 'Conhecimento de Transporte Aquaviário de Cargas'),
    ('10', 'Conhecimento Aéreo'),
    ('11', 'Conhecimento de Transporte Ferroviário de Cargas'),
    ('13', 'Bilhete de Passagem Rodoviário'),
    ('14', 'Bilhete de Passagem Aquaviário e Nota de Bagagem'),
    ('15', 'Bilhete de Passagem e Nota de Bagagem'),
    ('16', 'Bilhete de Passagem Ferroviário'),
    ('17', 'Despacho de Transporte'),
    ('18', 'Resumo Movimento Diário'),
    ('20', 'Ordem de Coleta de Cargas'),
    ('21', 'Nota Fiscal de Serviço de Comunicação'),
    ('22', 'Nota Fiscal de Serviço de Telecomunicação'),
    ('24', 'Autorização de Carregamento e Transporte'),
    ('25', 'Manifesto de Carga'));
begin
  Tab := TClientDataSet.Create(AOwner);
  with Tab do
  begin
    with FieldDefs.AddFieldDef do
    begin
      DataType := ftInteger;
      Name := 'CODIGO';
    end;
    with FieldDefs.AddFieldDef do
    begin
      DataType := ftString;
      Size := 50;
      Name := 'DES_MODELO';
    end;
    with IndexDefs.AddIndexDef do
    begin
      Fields := 'CODIGO';
      Name := 'CODINDEX';
    end;
    CreateDataSet; // cria em memória
    for i := 1 to length(aDados) do
    begin // grava os dados
      append;
      fieldByName('CODIGO').AsString := aDados[i, 0];
      fieldByName('DES_MODELO').AsString := aDados[i, 0] + ' - ' + aDados[i, 1];
      post;
    end;
  end;
end;

function AjudaNumSerie: TForm;
var
  MmTexto: TMemo;
begin
  Result := TForm.Create(nil);
  try
    with Result do
    begin
      Caption := 'Ajuda - Como Preencher a Série e Sub-Série?';
      Width := 500;
      Height := 300;
      Position := poOwnerFormCenter;
      BorderStyle := bsDialog;
      MmTexto := TMemo.Create(Result);
      MmTexto.Parent := Result;
      Mmtexto.Align := alClient;
      MmTexto.ScrollBars := ssVertical;
      MmTexto.ReadOnly := True;
      Mmtexto.Lines.Add('SÉRIE:' + CRLF);
      Mmtexto.Lines.Add('Em se tratando de documento sem seriação, deixar em branco as três posições;');
      Mmtexto.Lines.Add(' - No caso de Nota Fiscal, modelo 1 e 1-A (código 01), preencher com o algarismo designativo da série ( "1", "2" etc.) deixando em branco as posições não significativas;');
      Mmtexto.Lines.Add(' - Em se tratando de documentos com seriação indicada por letra, preencher com a respectiva letra (B, C ou E). No caso de documentos fiscais de "Série Única" preencher com a letra U;');
      Mmtexto.Lines.Add(' - Em se tratando dos documentos fiscais de série indicada por letra seguida da expressão "Única" ("Série B-Única", "Série C-Única ou Série E-Única"), preencher com a respectiva letra (B, C ou E) na primeira posição e com a letra U na segunda ' + 'posição, deixando em branco a posição não significativa;');
      Mmtexto.Lines.Add(' - No caso de documento fiscal de "Série Única" seguida por algarismo arábico ("Série Única 1", "Série Única 2" etc.) preencher com a letra U na primeira posição, deixando em branco as posições não significativas. O algarismo respectivo deverá ' + 'ser indicado no campo Subsérie;');
      Mmtexto.Lines.Add(' - Quando se tratar de Nota Fiscal de Microempresa, confeccionada até 31 de dezembro de 1998, quanto ao ICMS, colocar a letra "M";');
      Mmtexto.Lines.Add(CRLF + 'SUB-SÉRIE:' + CRLF);
      Mmtexto.Lines.Add('Em se tratando de documento fiscal sem subseriação deixar em branco as duas posições;');
      Mmtexto.Lines.Add(' - No caso de Nota Fiscal, modelo 1 e 1-A (código 01), preencher com brancos;');
      Mmtexto.Lines.Add(' - No caso de subsérie designada por algarismo aposto à letra indicativa da série ( "Série B Subsérie 1", "Série B Subsérie 2" ou "Série B-1", "Série B-2" etc.) ou de documento fiscal de série Única com subsérie designada por algarismo ( "Série ' +
        'Única 1", "Série Única 2" etc.), preencher com o algarismo de subsérie ("1", "2" etc.) deixando em branco a posição não significativa;');
      Mmtexto.Lines.Add(' - No caso de subseriação de documentos fiscais de séries "A-única", "B-única", "C-única" e "E-única", preencher com o algarismo de subsérie ( "1", "2" etc.) deixando em branco a posição não significativa;');
    end;
  finally
    //Mmtexto.Free;
    //Ajuda.Free;
  end;
end;

function Modulo10(Valor: string): string;
{
   Rotina usada para cálculo de alguns dígitos verificadores
   Pega-se cada um dos dígitos contidos no parâmetro VALOR, da direita para a
   esquerda e multiplica-se por 2121212...
   Soma-se cada um dos subprodutos. Caso algum dos subprodutos tenha mais de um
   dígito, deve-se somar cada um dos dígitos. (Exemplo: 7*2 = 14 >> 1+4 = 5)
   Divide-se a soma por 10.
   Faz-se a operação 10-Resto da divisão e devolve-se o resultado dessa operação
   como resultado da função Modulo10.
   Obs.: Caso o resultado seja maior que 9, deverá ser substituído por 0 (ZERO).
}
var
  Auxiliar: string;
  Contador, Peso: integer;
  Digito: integer;
begin
  Auxiliar := '';
  Peso := 2;
  for Contador := Length(Valor) downto 1 do
  begin
    Auxiliar := IntToStr(StrToInt(Valor[Contador]) * Peso) + Auxiliar;
    if Peso = 1 then
      Peso := 2
    else
      Peso := 1;
  end;

  Digito := 0;
  for Contador := 1 to Length(Auxiliar) do
  begin
    Digito := Digito + StrToInt(Auxiliar[Contador]);
  end;
  Digito := 10 - (Digito mod 10);
  if (Digito > 9) then
    Digito := 0;
  Result := IntToStr(Digito);
end;

function Modulo11(Value: string): char;
var soma, fator, i: Integer;
begin
  {Função para validar o dígito verificar (5ª casa)
   do código de barra de boletos capturados
   pelo leitor (44 posições)}
  soma := 0;
  fator := 2;
  for i := Length ( Value ) downto 1 do
  begin
    soma := soma + chInt ( Value[i] ) * fator;
    Inc ( fator );
    if fator = 10 then
    fator := 2;
  end;
  
  soma := 11 - ( soma mod 11 );
  if soma >= 10 then
    Result := '1'
  else
    Result := intCh ( soma );
end;

function chInt ( ch: Char ): ShortInt;
begin
  Result := Ord ( ch ) - Ord ('0');
end;


function intCh ( int: ShortInt ): Char;
begin
  Result := Chr (int + Ord ('0'));
end;

//----------------------------------------------------------------------
// FUNCAO RETORNACMC7
// ===============
// Objetivo : retorna o CMC7 do cheque
// Parametros: string( banco,agencia,conta,numero do cheque, camara de compensacao e tipo do cheque
// Retorna...: string com o CMC7 do cheque
//-----------------------------------------------------------------------

function RetornaCMC7(pBanco, pAgencia, pConta, pNrCheque,
  pCamaraCompesacao, pTipificacao: string): string;
var
  I: Integer;
  vVal1, vVal2, vVal3, vSoma, vPeso: Real;
  vCampo, vDv1, vDv2, vDv3, cmc7, vRetorno, vZero: string;
begin
  // contador: 1234 5678 9. 123 456789 . 1 2 3456789.12 3 4
  // conteudo: <745 0030 2< 018 000379 5 > 7 0030079144 9 :
  //            --- ---- -  --- ------ -   - ---------- -
  //            |   |    |  |   |      |   | |          |
  //            |   |    |  |   |      |   | |          -> digito verificador 3
  //            |   |    |  |   |      |   | ------------> conta corrente
  //            |   |    |  |   |      |   --------------> digito verificador 1
  //            |   |    |  |   |      ------------------> Tipificação ( 5 padrao/normal, 8 ch tributário, 9 administrativo )
  //            |   |    |  |   -------------------------> cheque
  //            |   |    |  -----------------------------> compe ( camara de compensação )
  //            |   |    --------------------------------> digito verificador 2
  //            |   -------------------------------------> agência
  //            -----------------------------------------> banco
  // zeros a esquerda do banco
  vZero := '';
  for I := 1 to 3 do
    if pBanco[I] in ['0'..'9'] then
      vZero := vZero + pBanco[I]
    else
      vZero := '0' + vZero;
  pBanco := vZero;
  // zeros a esquerda da agencia
  vZero := '';
  for I := 1 to 4 do
    if pAgencia[I] in ['0'..'9'] then
      vZero := vZero + pAgencia[I]
    else
      vZero := '0' + vZero;
  pAgencia := vZero;
  // zeros a esquerda da conta
  vZero := '';
  for I := 1 to 10 do
    if pConta[I] in ['0'..'9'] then
      vZero := vZero + pConta[I]
    else
      vZero := '0' + vZero;
  pConta := vZero;
  // zeros a esquerda do NrCheque
  vZero := '';
  for I := 1 to 6 do
    if pNrCheque[I] in ['0'..'9'] then
      vZero := vZero + pNrCheque[I]
    else
      vZero := '0' + vZero;
  pNrCheque := vZero;
  // zeros a esquerda do CamaraCompesacao
  vZero := '';
  for I := 1 to 3 do
    if pCamaraCompesacao[I] in ['0'..'9'] then
      vZero := vZero + pCamaraCompesacao[I]
    else
      vZero := '0' + vZero;
  pCamaraCompesacao := vZero;
  //
  CMC7 := '<' + pBanco + pAgencia + '0<' + pCamaraCompesacao + pNrCheque +
    pTipificacao + '>0' + pConta + '0:';
  //
  // calculo do digito (2)
  //
  vRetorno := '';
  vcampo := copy(CMC7, 11, 3) + copy(CMC7, 14, 6) + copy(CMC7, 20, 1);
  //  vVal1:=0;
  vSoma := 0;
  for I := 1 to Length(vcampo) do
  begin
    if (i div 2 = i / 2) then
      vPeso := 2
    else
      vPeso := 1;
    //    vVal2:=0;
    if vcampo[I] in ['0'..'9'] then
    begin
      vVal1 := StrToFloat(vcampo[I]) * vPeso;
      if (vVal1 > 9) then
        vVal2 := StrToFloat(copy(formatFloat('0', vVal1), 1, 1)) +
          StrToFloat(copy(formatFloat('0', vVal1), length(formatFloat('0',
          vVal1)), 1))
      else
        vVal2 := vVal1;
      vSoma := vSoma + vVal2;
    end;
  end;
  vVal3 := round((10 - (vSoma / 10)) * 100) / 100;
  //  vExt1:=vVal3;
  //  vVal4:=Int(vExt1);
  vDv2 := copy(formatFloat('0.0', frac(vVal3)), 3, 1);
  //
  // calculo do digito (1)
  //
  vcampo := copy(CMC7, 2, 7);
  //  vVal1:=0;
  vSoma := 0;
  for I := 1 to Length(vcampo) do
  begin
    if (i div 2 = i / 2) then
      vPeso := 1
    else
      vPeso := 2;
    //    vVal2:=0;
    if vcampo[I] in ['0'..'9'] then
    begin
      vVal1 := StrToFloat(vcampo[I]) * vPeso;
      if (vVal1 > 9) then
        vVal2 := StrToFloat(copy(formatFloat('0', vVal1), 1, 1)) +
          StrToFloat(copy(formatFloat('0', vVal1), length(formatFloat('0',
          vVal1)), 1))
      else
        vVal2 := vVal1;
      vSoma := vSoma + vVal2;
    end;
  end;
  vVal3 := round((10 - (vSoma / 10)) * 100) / 100;
  //  vExt1:=vVal3;
  //  vVal4:=Int(vExt1);
  vDv1 := copy(formatFloat('0.0', frac(vVal3)), 3, 1);
  //
  // calculo do digito (3)
  //
  vcampo := copy(CMC7, 23, 10);
  //  vVal1:=0;
  vSoma := 0;
  for I := 1 to Length(vcampo) do
  begin
    if (i div 2 = i / 2) then
      vPeso := 2
    else
      vPeso := 1;
    //    vVal2:=0;
    if vcampo[I] in ['0'..'9'] then
    begin
      vVal1 := StrToFloat(vcampo[I]) * vPeso;
      if (vVal1 > 9) then
        vVal2 := StrToFloat(copy(formatFloat('0', vVal1), 1, 1)) +
          StrToFloat(copy(formatFloat('0', vVal1), length(formatFloat('0',
          vVal1)), 1))
      else
        vVal2 := vVal1;
      vSoma := vSoma + vVal2;
    end;
  end;
  vVal3 := round((10 - (vSoma / 10)) * 100) / 100;
  //  vExt1:=vVal3;
  //  vVal4:=Int(vExt1);
  vDv3 := copy(formatFloat('0.0', frac(vVal3)), 3, 1);
  //
  vRetorno := '<' + pBanco + pAgencia + vDV2 + '<' + pCamaraCompesacao +
    pNrCheque + pTipificacao + '>' + vDV1 + pConta + vDV3 + ':';
  //
  result := vRetorno;
end;

//----------------------------------------------------------------------
// FUNCAO ValidaCMC7
// ===============
// Objetivo : Valida CMC7 do cheque
// Parametros: CMC7
// Retorna...: Boolean - Verdadeiro se CMC7 e Válido,Falso caso contrário.
//-----------------------------------------------------------------------

function ValidaCMC7(CMC7: string): boolean;
var
  I: Integer;
  vVal1, vVal2, vVal3, vSoma, vPeso: Real;
  vCampo, vDv1, vDv2, vDv3: string;
  vRetorno: boolean;
begin
  // contador: 1234 5678 9. 123 456789 . 1 2 3456789.12 3 4
  // conteudo: <745 0030 2< 018 000379 5 > 7 0030079144 9 :
  //            --- ---- -  --- ------ -   - ---------- -
  //            |   |    |  |   |      |   | |          |
  //            |   |    |  |   |      |   | |          -> digito verificador 3
  //            |   |    |  |   |      |   | ------------> conta corrente
  //            |   |    |  |   |      |   --------------> digito verificador 1
  //            |   |    |  |   |      ------------------> Tipificação ( 5 padrao/normal, 8 ch tributário, 9 administrativo )
  //            |   |    |  |   -------------------------> cheque
  //            |   |    |  -----------------------------> compe ( camara de compensação )
  //            |   |    --------------------------------> digito verificador 2
  //            |   -------------------------------------> agência
  //            -----------------------------------------> banco
  //
  // calculo do digito (2)
  //
  vRetorno := False;
  vcampo := copy(CMC7, 11, 3) + copy(CMC7, 14, 6) + copy(CMC7, 20, 1);
  //  vVal1:=0;
  vSoma := 0;
  for I := 1 to Length(vcampo) do
  begin
    if (i div 2 = i / 2) then
      vPeso := 2
    else
      vPeso := 1;
    //    vVal2:=0;
    if vcampo[I] in ['0'..'9'] then
    begin
      vVal1 := StrToFloat(vcampo[I]) * vPeso;
      if (vVal1 > 9) then
        vVal2 := StrToFloat(copy(formatFloat('0', vVal1), 1, 1)) +
          StrToFloat(copy(formatFloat('0', vVal1), length(formatFloat('0',
          vVal1)), 1))
      else
        vVal2 := vVal1;
      vSoma := vSoma + vVal2;
    end;
  end;
  vVal3 := round((10 - (vSoma / 10)) * 100) / 100;
  //  vExt1:=vVal3;
  //  vVal4:=Int(vExt1);
  vDv2 := copy(formatFloat('0.0', frac(vVal3)), 3, 1);
  if vDv2 = copy(CMC7, 9, 1) then
    vRetorno := true;
  //
  // calculo do digito (1)
  //
  if vRetorno then
  begin
    vRetorno := False;
    vcampo := copy(CMC7, 2, 7);
    //    vVal1:=0;
    vSoma := 0;
    for I := 1 to Length(vcampo) do
    begin
      if (i div 2 = i / 2) then
        vPeso := 1
      else
        vPeso := 2;
      //      vVal2:=0;
      if vcampo[I] in ['0'..'9'] then
      begin
        vVal1 := StrToFloat(vcampo[I]) * vPeso;
        if (vVal1 > 9) then
          vVal2 := StrToFloat(copy(formatFloat('0', vVal1), 1, 1)) +
            StrToFloat(copy(formatFloat('0', vVal1), length(formatFloat('0',
            vVal1)), 1))
        else
          vVal2 := vVal1;
        vSoma := vSoma + vVal2;
      end;
    end;
    vVal3 := round((10 - (vSoma / 10)) * 100) / 100;
    //    vExt1:=vVal3;
    //    vVal4:=Int(vExt1);
    vDv1 := copy(formatFloat('0.0', frac(vVal3)), 3, 1);
    if vDv1 = copy(CMC7, 22, 1) then
      vRetorno := true;
  end;
  //
  // calculo do digito (3)
  //
  if vRetorno then
  begin
    vRetorno := False;
    vcampo := copy(CMC7, 23, 10);
    //    vVal1:=0;
    vSoma := 0;
    for I := 1 to Length(vcampo) do
    begin
      if (i div 2 = i / 2) then
        vPeso := 2
      else
        vPeso := 1;
      //      vVal2:=0;
      if vcampo[I] in ['0'..'9'] then
      begin
        vVal1 := StrToFloat(vcampo[I]) * vPeso;
        if (vVal1 > 9) then
          vVal2 := StrToFloat(copy(formatFloat('0', vVal1), 1, 1)) +
            StrToFloat(copy(formatFloat('0', vVal1), length(formatFloat('0',
            vVal1)), 1))
        else
          vVal2 := vVal1;
        vSoma := vSoma + vVal2;
      end;
    end;
    vVal3 := round((10 - (vSoma / 10)) * 100) / 100;
    //    vExt1:=vVal3;
    //    vVal4:=Int(vExt1);
    vDv3 := copy(formatFloat('0.0', frac(vVal3)), 3, 1);
    if vDv3 = copy(CMC7, 33, 1) then
      vRetorno := true;
  end;
  //
  result := vRetorno;
end;

function ValidaCMC7Leitor(CMC7: string): boolean;
var
  vBloco, vDigV : string;
begin
  (*NOVA - Léo*)
  vBloco := Copy(CMC7,1,4)+Copy(CMC7,6,39);
  vDigV  := Copy(CMC7,5,1);

  Result := vDigV = Modulo11(vBloco);
end;

function ConvertLinhaDigCodBarra(aLinhaDig : String) : string;
begin
  Result := copy(aLinhaDig, 1 , 4 ) +
            copy(aLinhaDig, 33, 15) +
            copy(aLinhaDig, 5 , 5 ) +
            copy(aLinhaDig, 11, 10) +
            copy(aLinhaDig, 22, 10);
end;

function ConvertCodBarraLinhaDig(aCodBarr : String) : string;
var
   p1, p2, p3, p4, p5, p6,
   Campo1, Campo2, Campo3, Campo4, Campo5,
   Codigo : string;
begin
   p1 := Copy(aCodBarr,1,4);
   p2 := Copy(aCodBarr,20,5);
   p3 := Modulo10(p1+p2);
   p4 := p1+p2+p3;
   p5 := Copy(p4,1,5);
   p6 := Copy(p4,6,5);
   Campo1 := p5+p6;//p5+'.'+p6;

   {
      Campo 2 - composto pelas posiçoes 6 a 15 do campo livre
      e DV (modulo10) deste campo
   }
   p1 := Copy(aCodBarr,25,10);
   p2 := Modulo10(p1);
   p3 := p1+p2;
   p4 := Copy(p3,1,5);
   p5 := Copy(p3,6,6);
   Campo2 := p4+p5;//p4+'.'+p5;

   {
      Campo 3 - composto pelas posicoes 16 a 25 do campo livre
      e DV (modulo10) deste campo
   }
   p1 := Copy(aCodBarr,35,10);
   p2 := Modulo10(p1);
   p3 := p1+p2;
   p4 := Copy(p3,1,5);
   p5 := Copy(p3,6,6);
   Campo3 := p4+p5;//p4+'.'+p5;

   {
      Campo 4 - digito verificador do codigo de barras
   }
   Campo4 := Copy(aCodBarr,5,1);

   {
      Campo 5 - composto pelo valor nominal do documento, sem indicacao
      de zeros a esquerda e sem edicao (sem ponto e virgula). Quando se
      tratar de valor zerado, a representacao deve ser 000 (tres zeros).
   }
   Campo5 := Copy(aCodBarr,6,14);

   Result := Campo1 + Campo2 + Campo3 + Campo4 + Campo5;//Campo1 + ' ' + Campo2 + ' ' + Campo3 + ' ' + Campo4 + ' ' + Campo5;
End;

function ValidaCMC7_2(CMC7: string): boolean;
var 
  campo1, campo2, campo3 : String; 
begin
  {Essa funfa legal!!!}
  CMC7 := SoNumero(CMC7);
  campo1 := Copy(CMC7,1,7);
  campo2 := Copy(CMC7,9,10);
  campo3 := Copy(CMC7,20,10);
  Result := True;
  if Modulo10(campo1) <> Copy(CMC7,19,1) then
     Result := False
  Else
  if Modulo10(campo2) <> Copy(CMC7,8,1) then
     Result := False
  Else
  if Modulo10(campo3) <> Copy(CMC7,30,1) then
     Result := False;
end;

function ValidaCBarraBol(aCodBarra : string): Boolean;
var bloco1,digi1_func,
    bloco2,digi2_func,
    bloco3,digi3_func,
    bloco4,digi4_func,
    NumBarra :String;
begin
  Result := True;

  //PARA BOLETOS DE ARRECADAÇÃO (Ex: Luz, IPTU, Água, etc...)

  //Captura os 4 blocos de 12 posições do campo MaskEdit!
  bloco1 := copy(aCodBarra,1,12);
  bloco2 := copy(aCodBarra,15,12);
  bloco3 := copy(aCodBarra,29,12);
  bloco4 := copy(aCodBarra,43,12);

  //Código de barras completo!
  NumBarra := bloco1+bloco2+bloco3+bloco4;

  digi1_func := copy(aCodBarra,1,11);
  digi1_func := digi1_func + CalcDigM10(digi1_func);

  digi2_func := copy(aCodBarra,15,11);
  digi2_func := digi2_func + CalcDigM10(digi2_func);

  digi3_func := copy(aCodBarra,29,11);
  digi3_func := digi3_func + CalcDigM10(digi3_func);

  digi4_func := copy(aCodBarra,43,11);
  digi4_func := digi4_func + CalcDigM10(digi4_func);

  if (digi1_func <> bloco1) or (digi2_func <> bloco2) or (digi3_func <> bloco3) or (digi4_func <> bloco4) then
  begin
     ShowMessage('Código de barras inválido');
     Result := False;
  end;
end;

//----------------------------------------------------------------------
// FUNCAO RetParteCMC7
// ===============
// Objetivo : Parte CMC7 do cheque
// Parametros: CMC7 e tipo do retorno conforme abaixo
// Retorna...: string  0=banco, 1=agencia, 2=conta,
//                     3=numero do cheque, 4=camara de compensacao e
//                     5=tipo do cheque
//-----------------------------------------------------------------------

function RetParteCMC7(CMC7: string; Tipo: Smallint): string;
begin
  Result := '';
  if Trim(CMC7) = '' then
    Exit;
  if (Tipo < 0) or (Tipo > 5) then
    Exit;
  case tipo of
    0: Result := Copy(CMC7, 02, 03); // Banco
    1: Result := Copy(CMC7, 05, 04); // Agencia
    2: Result := Copy(CMC7, 23, 10); // Conta Corrente
    3: Result := Copy(CMC7, 14, 06); // Nr do Cheque
    4: Result := Copy(CMC7, 11, 03); // Camara de Compensação
    5: Result := Copy(CMC7, 20, 01); // Tipificação
  end;
end;

function GetDigAgCC(aAgCC : string) : string;
var vInfo : TStrings;
begin
  vInfo  := Split(aAgCC, '-');
  Result := vInfo.Strings[1];
end;

function ValidaFormatoCC(aCC : string) : Boolean;
var
 vInfo : TStrings;
 vCC, vDig : string;
begin
  Result := False;
  Try
    vInfo := Split(aCC, '-');
    vCC   := vInfo.Strings[0];
    vDig  := vInfo.Strings[1];
  Except
    Exit;
  End;
  Result := True;
end;

function ValidaFormatoAgencia(aAg : string) : Boolean;
var
 vInfo : TStrings;
 vAg, vDig : string;
begin
  Result := False;
  Try
    vInfo := Split(aAg, '-');
    vAg   := vInfo.Strings[0];
    vDig  := vInfo.Strings[1];
  Except
    Exit;
  End;
  Result := True;
end;

function GetAgCCSemDig(aAgCC : string) : string;
var vInfo : TStrings;
begin
  vInfo  := Split(aAgCC, '-');
  Result := vInfo.Strings[0];
end;
//----------------------------------------------------------------------
// FUNCAO CalcMod11
// ===============
// Objetivo : Calcular digito Verificador de Agencia e C/C do Bradesco
//            Peso 2 a 7
// Parametros: Agencia e ou C/C
// Retorna...: string - o digito
//-----------------------------------------------------------------------

function CalcMod11(Value: string): string;
var
  numero: string;
  Peso, total, contador, Modulo, Digito: Integer;
begin
  numero := Value;
  peso := 2;
  total := 0;
  digito := 0;
  contador := Length(numero);
  while (contador > 0) do
  begin
    total := total + (StrToInt(Copy(numero, contador, 1)) * peso);
    Dec(contador);
    Inc(peso);
    if Peso > 7 then
      Peso := 2;
  end;
  if (total >= 11) then
  begin
    modulo := total mod 11;
    if (modulo > 1) then
      digito := 11 - modulo
    else if (modulo = 1) then
      digito := 0
    else if (modulo = 0) then
      digito := 0;
  end
  else
    digito := 11 - total;

  Result := IntToStr(Digito);
end;

{procedure ExecuteShellCommand(cmdline: string; hidden: Boolean);
const
  flags: array[Boolean] of Integer = (SW_SHOWNORMAL, SW_HIDE);
var
  cmdbuffer: array[0..MAX_PATH] of Char;
begin
  GetEnvironmentVariable('COMSPEC', cmdBUffer, SizeOf(cmdBuffer));
  StrCat(cmdbuffer, ' /C ');
  StrPCopy(StrEnd(cmdbuffer), cmdline);
  WinExec(cmdbuffer, flags[hidden]);
end;}

procedure ExecuteShellCommand2(cmdline: string);
var
   SEI: TShellExecuteInfo;
begin
  FillChar(SEI, SizeOf(SEI), 0);
  with SEI do
  begin
    cbSize := SizeOf(SEI);
    fMask := see_Mask_NoCloseProcess;
    Wnd := Application.MainForm.Handle;
    lpFile := PChar(cmdline);
    nShow := sw_ShowNormal;
    if not ShellExecuteEx(@SEI) then
      raise Exception.Create('Erro na execução do arquivo '+cmdline);
  end;
end;

procedure ExecuteShellCommand3(cmdline: string);
begin
  ShellExecute(Application.Handle, nil,{$IFDEF VER150}PAnsiChar(cmdline){$ELSE}PWideChar(cmdline){$ENDIF},nil,nil,SW_SHOWNORMAL);
end;

procedure ExecutaeEsperaTerminar(Comando: string);
var
  SI: TStartupInfo;
  PI: TProcessInformation;
begin
  FillChar(SI, SizeOf(SI), 0);
  SI.cb := SizeOf(StartupInfo);
  SI.dwFlags := STARTF_USESHOWWINDOW;
  SI.wShowWindow := SW_HIDE;
  if CreateProcess(nil, PChar(Comando), nil, nil, False, NORMAL_PRIORITY_CLASS,
       nil, nil, SI, PI) then
    WaitForSingleObject(PI.hProcess, INFINITE);
end;

Procedure ExecuteProgram(Nome,Parametros:String);
Var
  Comando : Array[0..1024] of Char;
  Parms : Array[0..1024] of Char;
Begin
  StrPCopy(Comando,Nome);
  StrPCopy(Parms,Parametros);
  ShellExecute(0,nil,Comando,Parms,nil,sw_showmaximized);
End;

procedure Delay(dwMilliseconds: Longint);
var
  iStart, iStop: DWORD;
begin
  iStart := GetTickCount;
  repeat
    iStop := GetTickCount;
    Application.ProcessMessages;
  until (iStop - iStart) >= dwMilliseconds;
end;

procedure AlinhaMenuItemDireita(MMenu: TMainMenu; MenuItem: TMenuItem);
var
  mii: TMenuItemInfo;
  MainMenu: hMenu;
  Buffer: array[0..79] of Char;
begin
  MainMenu := MMenu.Handle;
  //GET Help Menu Item Info
  mii.cbSize := SizeOf(mii);
  mii.fMask := MIIM_TYPE;
  mii.dwTypeData := Buffer;
  mii.cch := SizeOf(Buffer);
  GetMenuItemInfo(MainMenu, MenuItem.Command, False, mii);
  //SET Help Menu Item Info
  mii.fType := mii.fType or MFT_RIGHTJUSTIFY;
  SetMenuItemInfo(MainMenu, MenuItem.Command, False, mii);
end;

function PegaCfgPortaSerial(Porta_Serial: string): string;
var
  Equipamento, PortaSerial: TStrings;
  i: Integer;
  NomeMicro: string;
begin
  Result := '';
  PortaSerial := nil;
  Equipamento := nil;
  try
    PortaSerial := TStringList.Create;
    Equipamento := TStringList.Create;
    NomeMicro := GetComputerName;
    // Le primeiro os equipamentos
    Equipamento := Split(PORTA_SERIAL, '/');
    for i := 0 to Equipamento.Count - 1 do
    begin
      PortaSerial := Split(Equipamento.Strings[i], ';');
      if UpperCase(PortaSerial.Strings[0]) = UpperCase(NomeMicro) then
        Result := PortaSerial.Strings[1] + ';' + // Porta
        PortaSerial.Strings[2] + ';' + // Bits por segundo
        PortaSerial.Strings[3] + ';' + // Bits de Dados
        PortaSerial.Strings[4] + ';' + // Bits de parada
        PortaSerial.Strings[5] + ';' + // Paridade
        PortaSerial.Strings[6]; // Ctrl de fluxo
    end;
  finally
    PortaSerial.Free;
    Equipamento.Free;
  end;
end;

function RemoveTitleBar(hWindow: THANDLE; Hide: boolean = True): DWORD;
var
  R: TRect;
begin
  Result := GetWindowLong(hWindow, GWL_STYLE);
  if (Hide) then
    Result := Result and not WS_CAPTION
  else
    Result := Result or WS_CAPTION;
  GetClientRect(hWindow, R);
  SetWindowLong(hWindow, GWL_STYLE, Result);
  AdjustWindowRect(R, Result, boolean(GetMenu(hWindow)));
  SetWindowPos(hWindow, 0, 0, 0, (R.Right - R.Left), (R.Bottom - R.Top),
    SWP_NOMOVE or SWP_NOZORDER or SWP_FRAMECHANGED or SWP_NOSENDCHANGING);
end;

function SetGlobalEnvironment(const Name, Value: string;
  const User: Boolean = True): Boolean;
resourcestring
  REG_MACHINE_LOCATION = 'System\CurrentControlSet\Control\Session Manager\Environment';
  REG_USER_LOCATION = 'Environment';
begin
  with TRegistry.Create do
    try
      if User then { User Environment Variable }
        Result := OpenKey(REG_USER_LOCATION, True)
      else { System Environment Variable }
      begin
        RootKey := HKEY_LOCAL_MACHINE;
        Result  := OpenKey(REG_MACHINE_LOCATION, True);
      end;
      if Result then
      begin
        WriteString(Name, Value); { Write Registry for Global Environment }
        { Update Current Process Environment Variable }
        SetEnvironmentVariable(PChar(Name), PChar(Value));
        { Send Message To All Top Window for Refresh }
        SendMessage(HWND_BROADCAST, WM_SETTINGCHANGE, 0, Integer(PChar('Environment')));
      end;
    finally
      Free;
    end;
end; { SetGlobalEnvironment }

{ This code is very useful if you need to "translate" various
environmental variables. I use this a lot to get paths to TEMP
or windows folders on different systems.}

function GetEnvVarValue(const VarName: string): string;
var
  BufSize: Integer;  // buffer size required for value
begin
  // Get required buffer size (inc. terminal #0)
  BufSize := GetEnvironmentVariable(PChar(VarName), nil, 0);
  if BufSize > 0 then
  begin
    // Read env var value into result string
    SetLength(Result, BufSize - 1);
    GetEnvironmentVariable(PChar(VarName),
      PChar(Result), BufSize);
  end
  else
    // No such environment variable
    Result := '';
end;

function RetornaDiaSemana(Data: TDateTime): String;
//Retorna o dia da semana em Extenso de uma determinada data
const
  Dias : Array[1..7] of String[07] = ('DOMINGO', 'SEGUNDA', 'TERCA','QUARTA','QUINTA', 'SEXTA','SABADO');
begin
  Result := Dias[DayOfWeek(Data)];
end;

function RetornaDiaSemanaExt(Data: TDateTime): String;
//Retorna o dia da semana em Extenso de uma determinada data
const
  Dias : Array[1..7] of String[13] = ('DOMINGO', 'SEGUNDA-FEIRA', 'TERÇA-FEIRA','QUARTA-FEIRA',
    'QUINTA-FEIRA', 'SEXTA-FEIRA','SÁBADO');
begin
  Result := Dias[DayOfWeek(Data)];
end;

function ToUpper(Text: String): String;
//Mantém os caracteres maiúsculos quando estão acentuados
var
  Ind: Integer;
const
  LW = 'áâãàéêíóôõúüûçñ';
  UP = 'ÁÂÃÀÉÊÍÓÔÕÚÜÛÇÑ';
begin
  Result := '';
  for Ind := 1 to Length(Text) do
  if Pos(Copy(Text, Ind, 1), LW) > 0 then
    Result := Result + Copy(UP, Pos(Copy(Text, Ind, 1), LW), 1)
  else
    Result := Result + UpperCase(Copy(Text, Ind, 1));
end;


function RetornaDV_NFE_Modulo11(Numero: String): String;
var
  i,k : Integer;
  Soma : Integer;
  Digito : Integer;
begin
  Result := '';
  Try
    Soma := 0; k:= 2;
    for i := Length(Numero) downto 1 do
    begin
      Soma := Soma + (StrToInt(Numero[i])*k);
      inc(k);
      if k > 9 then
        k := 2;
    end;
    Digito := 11 - Soma mod 11;
    if Digito >= 10 then
      Digito := 0;
    Result := Result + Chr(Digito + Ord('0'));
  except
    Result := 'X';
  end;
end;


function procuraProcesso(val : String) : Boolean;
var
  ProcEntry: TProcessEntry32;
  Hnd: THandle;
  Fnd: Boolean;
  s: String;
begin
  Hnd := CreateToolhelp32Snapshot(TH32CS_SNAPALL,0);
  ProcEntry.dwSize := SizeOf(TProcessEntry32);

  //recebe o primeiro processo
  Fnd := Process32First(Hnd,ProcEntry);

  //procurando processos a partir do primeiro
  while Fnd do
  begin
    //pega o nome do executavel q esta na memoria
    s := ProcEntry.szExeFile;

    if Pos(LowerCase(val), LowerCase(s)) > 0 then
    begin
      Result := true;
      Exit;
    end;

    //proximo processo
    Fnd := Process32Next(Hnd,ProcEntry);
  end;

  //fecha o manipulador
  CloseHandle(Hnd);

  Result := false;

end; //end of procuraProcesso

function FormataHistorico(DesHistorico, NumDocto, DtaLancto, DesConta, TipoLanc, Parcela,
 QtdParcela, DtaVencto : string) : string;
begin
  DesHistorico := AnsiReplaceText(DesHistorico, '<NUM_DOCTO>', NumDocto);
  DesHistorico := AnsiReplaceText(DesHistorico, '<DTA_LANCAMENTO>', DtaLancto);
  DesHistorico := AnsiReplaceText(DesHistorico, '<DES_CONTA_CONTABIL>', DesConta);
  DesHistorico := AnsiReplaceText(DesHistorico, '<NUM_PARCELA>', Parcela);
  DesHistorico := AnsiReplaceText(DesHistorico, '<QTD_PARCELA>', QtdParcela);
  DesHistorico := AnsiReplaceText(DesHistorico, '<DTA_VENCIMENTO>', DtaVencto);
  DesHistorico := AnsiReplaceText(DesHistorico, '<NUM_DOCTO_PGTO>', NumDocto);
  Result := DesHistorico;
end;

function FormataTipoOpEvFin(aTipoOp : Integer) : string;
begin
  case aTipoOp of
    0 : Result := '(+)';
    1 : Result := '(-)';
  else
    Result := EmptyStr;
  end;
end;

function GetQtdEmail(vEmail : string) : Integer;
var vDadosEmail : TStrings;
begin
  vDadosEmail := Split(vEmail, ';');
  Result      := vDadosEmail.Count;
end;

function GetDadosEmails(vEmail : string) : TResultArrayStr;
var vDadosEmail : TStrings;
    vLength, i : Integer;
begin
  vDadosEmail := Split(vEmail, ';');
  vLength     := vDadosEmail.Count;

  SetLength(Result, vLength);

  for i := 0 to Pred(vLength) do
    Result[i] := vDadosEmail.Strings[i];
end;

function GetBordValid(aBord : string) : Boolean;
var vNumBord : Integer;
begin
  if Trim(aBord) = EmptyStr then
  begin
    Result := False;
  end
  else
  Try
    vNumBord := StrToInt(aBord);
    if vNumBord <> 0 then
      Result := True;
  Except
    Result := False;
  End;
end;

function GetValorValid(aValBol, aValReceb, aValTarifa : Currency; aCodOcorrencia, aCodBco : integer) : Boolean;
begin
  Result := True;
  if (aValReceb + aValTarifa) < aValBol then {Recebeu parcial}
  begin
    case aCodBco of
      {Ocorrências de Liquidação}
      1, 104 : Result := not (aCodOcorrencia = 6);
      237 : Result := not aCodOcorrencia in [6,15,17];
      341 : Result := not aCodOcorrencia in [6,8];
      756 : Result := not aCodOcorrencia in [5,6,15,20];
    end;
  end;
end;

function GetTamNossoNumBB(aConv, aCart: string) : Integer;
var vTamConvenio : Integer;
begin
  vTamConvenio:= Length(Trim(aConv));
  if (vTamConvenio = 6) and
     ((aCart = '16') or (aCart = '18')) then
     Result := 17
  else if (vTamConvenio <= 4) then
     Result := 7
  else if (vTamConvenio > 4) and (vTamConvenio <= 6) then
     Result := 5
  else if (vTamConvenio = 7) then
     Result := 10;
end;

procedure GravaArqTxt(aDir, aNomeArq, aConteudo : string);
var vTxtFile : TextFile;
    vArq : string;
begin
  vArq := aDir+aNomeArq;
  Try
    DeleteFile(vArq);
  Except
    (*Deleta o arquivo caso exista*)
  End;

  Try
    (*Cria o Arquivo*)
    AssignFile(vTxtFile, vArq);
    Rewrite(vTxtFile);
    Write(vTxtFile, aConteudo);
  Finally
    (*Finalizado*)
    CloseFile(vTxtFile);
    ShellExecute(Application.Handle, 'print', PChar(vArq), nil, nil, SW_HIDE) ;
  End;
end;


function FormataTipoOferta(aTipoOf: Integer): String;
begin
  Case aTipoOf of
    0: Result := 'Normal';
    1: Result := 'Leve X / Pague Y';
    2: Result := 'Por Quantidade';
    3: Result := 'Desconto sobre o valor do cupom';
  end;
end;

function RetornaTipoPessoaFisica(const aNumCGC: string): Boolean;
begin
  Result := False;
  if Length(aNumCGC) <= 11 then
    Result := True;
end;

function CenterStr(vStr : String; vTam: Integer): String;
var i: Integer;
     wSpac: String;
begin

  wSpac := '';
  For i:=1 to vTam do wSpac := wSpac + ' ';

  vStr := Trim(vStr);

 Result := Copy(wSpac,1,(vTam div 2)-(Length(vStr) div 2))+
               vStr                                       +
               Copy(wSpac,1,(vTam div 2)-(Length(vStr) div 2));
end;

function RemoveEnter(aStr : String) : String;
begin
  Result := stringReplace(Trim(aStr), #13, ' ', [rfReplaceAll]);
  Result := stringReplace(Trim(Result), #10, ' ', [rfReplaceAll]);
  Result := stringReplace(Trim(Result), #$D, ' ', [rfReplaceAll]);
end;

function TrocaVirgPPonto(Valor : String): String;
var i : Integer;
begin
  if Valor <> ' ' then
  begin
    for i := 0 to Length(Valor) do
    begin
      if Valor[i]=',' then
      begin
        Valor[i]:='.';
      end;
    end;
  end;
  Result := valor;
end;

procedure TrimAppMemorySize;
var
  MainHandle : THandle;
begin
  try
    MainHandle := OpenProcess(PROCESS_ALL_ACCESS, false, GetCurrentProcessID) ;
    SetProcessWorkingSetSize(MainHandle, $FFFFFFFF, $FFFFFFFF) ;
    CloseHandle(MainHandle) ;
  except
  end;
  Application.ProcessMessages;
end;

function RemovePontosValor(vValor : String) : String;
var
  StrValue : String;
begin
  // remove todos os pontos inseridos na formatação
  StrValue := StringReplace(vValor, '.', '', [rfReplaceAll]);
  // segue com a conversão do valor textual para float.
  Result := StrValue;
end;

function SecondsIdle: DWord;
var
  liInfo: TLastInputInfo;
begin
  {saber qto tempo o mouse nao foi movido ou clicado e nem o teclado foi usado.}
  liInfo.cbSize := SizeOf(TLastInputInfo) ;
  GetLastInputInfo(liInfo) ;
  Result := (GetTickCount - liInfo.dwTime) div 1000;
end;

function GetLocalIP : string;
type
  TaPInAddr = array [0..10] of PInAddr;
  PaPInAddr = ^TaPInAddr;
var
  phe : PHostEnt;
  pptr : PaPInAddr;
  {$IFDEF VER150}
  Buffer : array [0..63] of char;
  {$ELSE}
  Buffer : array [0..63] of AnsiChar;
  {$ENDIF}

  i : Integer;
  GInitData : TWSADATA;
begin
  Result := EmptyStr;
  Try
    WSAStartup($101, GInitData);
    Result := '';
    GetHostName(Buffer, SizeOf(Buffer));
    phe := GetHostByName(buffer);
    if phe = nil then Exit;
    pptr := PaPInAddr(Phe^.h_addr_list);
    i := 0;
    while pptr^[i] <> nil do
    begin
      result:=StrPas(inet_ntoa(pptr^[i]^));
      Inc(i);
    end;
    WSACleanup;
  Except
    //
  End;
end;

function GetIP : string;
var 
  r : TIdIPWatch;
begin
  Result := EmptyStr;
  Try
   r := TIdIPWatch.Create(nil);
   Result := r.LocalIP;
   r.free;
  Except
    Result := GetLocalIP;
  End;
end;

function GetColorRandom: TColor;
begin
  Result := RGB(Random(255),Random(255),Random(255));
end;

function GetColorIndex(aIdx : Integer): TColor; overload;
const
  Cores: array[1..12] of TColor = ($00B0CDF9, $00AFFAC6, $00FCEAAD, $00FAC7CC,
    $00C7FACC, $00D6D3D1, $00C4C2FC, $00CBFED2, $00FDD2CC,
    $00B5DAFB, $00F2E3F2, $00FCE0D1);
begin
  Result := Cores[aIdx];
end;

function ClearAllDirectory(FullPath: string): Boolean;
var
  sr: TSearchRec;
  FullName: string;
begin
  Result := True;
  if (FindFirst(FullPath + '\*.*', faAnyFile, sr) = 0) then
  try
    repeat
      FullName := IncludeTrailingPathDelimiter(FullPath) + sr.Name;
      if (sr.Name <> '.') and (sr.Name <> '..') then
      begin
        if ((sr.Attr and faDirectory) = 0) then Result := DeleteFile(FullName)
        else Result := ClearAllDirectory(FullName);
      end;
    until (FindNext(sr) <> 0) or not Result;
  finally
    FindClose(sr);
  end;
  Result := Result and DirectoryExists(FullPath) and RemoveDir(FullPath);
end;

function StrLBDelete(Text: String): String;
var
  Position: Integer;
begin
  Position := 1;
  Result := Text;
  while Position <= Length(Result) do
  begin
    if StringInSet(Result[Position], [#10, #13]) then
      Delete(Result, Position, 1) //remove quebra
    else
      Inc(Position); //vai para proximo caracter
  end;
end;

function StringInSet(const S: String;
  const StringSet: array of String): Boolean;
var
  I: Integer;
begin
  Result := False;
  for I := Low(StringSet) to High(StringSet) do
    if S = StringSet[I] then
    begin
      Result := True;
      Break;
    end;
end;

procedure SaveStrFile(aContent, aFileName : string);
var
  F : TextFile;
begin
  Try
    DeleteFile(aFileName);
  Except
    (*Deleta o arquivo caso exista*)
  End;
  AssignFile(F,aFileName);
  Rewrite(F); //abre o arquivo para escrita
  Write(F,aContent); //escreve no arquivo sem descer a linha
  Closefile(F); //fecha o handle de arquivo
end;

function GetTxtAlfa(aTam: integer): string;
var
I: Integer;
begin
  if aTam = -1 then
    aTam := Random(255);
  Setlength(Result, aTam);
  for I := 1 to aTam do
    if Random(2) = 0 then
      Result[I] := Chr(Ord('A') + Random(Ord('Z') - Ord('A') + 1))
    else
      Result[I] := Chr(Ord('0') + Random(Ord('9') - Ord('0') + 1));
end;

procedure CriaCampoFloat(aFieldName, aDisplay : string; aDataSet: TDataSet);
begin
  Try
    {if aDataSet.FindField(aFieldName) <> nil then
      aDataSet.Fields.Remove(TField(aDataSet.FieldByName(aFieldName)));}

    with TFloatField.Create(aDataSet) do
    begin
      FieldName      := aFieldName;
      //Name           := aDataSet.Name+aFieldName;
      //Name           := aDataSet.Name + UpperCase(FieldName);
      FieldKind      := fkData;
      Size           := 0;
      DisplayLabel   := iif(aDisplay = EmptyStr,aFieldName,aDisplay);
      DataSet        := aDataSet;
      DisplayFormat  := '#,###,##0.00';
    end;
  Except
    {on e : Exception do
      ShowMessage(e.Message);}
  end;
end;

procedure CriaCampoInt(aFieldName: string; aDataSet: TDataSet);
begin
  with TIntegerField.Create(aDataSet) do
  begin
    FieldName      := aFieldName;
    Name           := aDataSet.Name + UpperCase(FieldName);
    FieldKind      := fkData;
    DataSet        := aDataSet;
  end;
end;

procedure CriaCampoDate(aFieldName: string; aDataSet: TDataSet);
begin
  with TDateField.Create(aDataSet) do
  begin
    FieldName      := aFieldName;
    Name           := aDataSet.Name + UpperCase(FieldName);
    FieldKind      := fkData;
    Size           := 0;
    DataSet        := aDataSet;
  end;
end;

procedure CriaCampoStr(aFieldName: string; aSize: Integer;
  aDataSet: TDataSet);
begin
  with TStringField.Create(aDataSet) do
  begin
    FieldName      := aFieldName;
    Name           := aDataSet.Name + UpperCase(FieldName);
    FieldKind      := fkData;
    Size           := aSize;
    DataSet        := aDataSet;
  end;
end;

procedure DestroyCampo(aDataSet: TDataSet; aFieldName : string);
//var vIdx : integer;
begin
  Try
    //vIdx := aDataSet.Fields.IndexOf(aDataSet.FieldByName(aFieldName));
    //aDataSet.FieldDefs.Delete(vIdx);
    aDataSet.Fields.Remove(aDataSet.FieldByName(aFieldName));
    aDataSet.Refresh;
  except
    //
  end;
end;

procedure CriaCampoString(aFieldName, aDisplay : string; aSize: Integer;
  aDataSet: TDataSet);
begin
  with TStringField.Create(aDataSet) do
  begin
    FieldName      := aFieldName;
    Name           := aDataSet.Name + UpperCase(FieldName);
    FieldKind      := fkData;
    Size           := aSize;
    DisplayLabel   := iif(aDisplay = EmptyStr,aFieldName,aDisplay);
    DataSet        := aDataSet;
  end;
end;

procedure AlimentaFDClient(var aClient:TClientDataSet; var aFDQry:TFDQuery);
var
  i:Integer;
begin
  try
    aClient.DisableControls;
    aFDQry.DisableControls;
    aFDQry.First;
    while not aFDQry.Eof do
    begin
      aClient.Append;

      for i := 0 to Pred(aFDQry.Fields.Count) do
        if aClient.FieldDefs[i].DataType = DB.ftInteger  then
          aClient.FieldByName(aClient.FieldDefs[i].Name).AsInteger :=
            aFDQry.FieldByName(aClient.FieldDefs[i].Name).AsInteger
        else if aClient.FieldDefs[i].DataType = DB.ftString then
          aClient.FieldByName(aClient.FieldDefs[i].Name).AsString :=
            aFDQry.FieldByName(aClient.FieldDefs[i].Name).AsString
        else if aClient.FieldDefs[i].DataType = DB.ftFloat then
          aClient.FieldByName(aClient.FieldDefs[i].Name).AsFloat :=
            aFDQry.FieldByName(aClient.FieldDefs[i].Name).AsFloat
        else
          aClient.FieldByName(aClient.FieldDefs[i].Name).Value :=
            aFDQry.FieldByName(aClient.FieldDefs[i].Name).Value;

      aClient.Post;
      aFDQry.Next;
    end;
  finally
    aClient.EnableControls;
    aFDQry.EnableControls;
  end;
end;

procedure InicializaObjeto(var AObj);
begin
  TObject(AObj) := Nil;
end;

function ConsisteAliquota(aAliq: Double): Boolean;
begin
  Result := False;
  if (aAliq >= 10.95) and (aAliq <= 11.05) then
    Result := True;
end;

function StrReplaceCaracterEspecial(aStr: string): string;
const
  Caracteres = '"!@#$%¨&*()_-;|\/{[ª}]º<>?°*-+,.~^`´';
var
  x: Integer;
begin

  Result := UpperCase(Trim(aStr));

  //Remove todos os caracteres especiais da constante: Caracteres
  for x := 1 to Length(Result) do
    if Pos(Result[x], Caracteres) <> 0 then
      Result[x] := ' ';

  Result := Trim(Result);

  //Substituir letras com acentuação o UpperCase não funcionou com minusculas e acentuação, exemplo: Result := UpperCase('ã');
  if Pos('Á', Result) > 0 then
    Result := strReplace(Result, 'Á', 'A');

  if Pos('á', Result) > 0 then
    Result := strReplace(Result, 'á', 'A');

  if Pos('É', Result) > 0 then
    Result := strReplace(Result, 'É', 'E');

  if Pos('é', Result) > 0 then
    Result := strReplace(Result, 'é', 'E');

  if Pos('Í', Result) > 0 then
    Result := strReplace(Result, 'Í', 'I');

  if Pos('í', Result) > 0 then
    Result := strReplace(Result, 'í', 'I');

  if Pos('Ó', Result) > 0 then
    Result := strReplace(Result, 'Ó', 'O');

  if Pos('ó', Result) > 0 then
    Result := strReplace(Result, 'ó', 'O');

  if Pos('Ú', Result) > 0 then
    Result := strReplace(Result, 'Ú', 'U');

  if Pos('ú', Result) > 0 then
    Result := strReplace(Result, 'ú', 'U');

  if Pos('À', Result) > 0 then
    Result := strReplace(Result, 'À', 'A');

  if Pos('à', Result) > 0 then
    Result := strReplace(Result, 'à', 'A');

  if Pos('È', Result) > 0 then
    Result := strReplace(Result, 'È', 'E');

  if Pos('è', Result) > 0 then
    Result := strReplace(Result, 'è', 'E');

  if Pos('Ì', Result) > 0 then
    Result := strReplace(Result, 'Ì', 'I');

  if Pos('ì', Result) > 0 then
    Result := strReplace(Result, 'ì', 'I');

  if Pos('Ò', Result) > 0 then
    Result := strReplace(Result, 'Ò', 'O');

  if Pos('ò', Result) > 0 then
    Result := strReplace(Result, 'ò', 'O');

  if Pos('Ù', Result) > 0 then
    Result := strReplace(Result, 'Ù', 'U');

  if Pos('ù', Result) > 0 then
    Result := strReplace(Result, 'ù', 'U');

  if Pos('Â', Result) > 0 then
    Result := strReplace(Result, 'Â', 'A');

  if Pos('â', Result) > 0 then
    Result := strReplace(Result, 'â', 'A');

  if Pos('Ê', Result) > 0 then
    Result := strReplace(Result, 'Ê', 'E');

  if Pos('ê', Result) > 0 then
    Result := strReplace(Result, 'ê', 'E');

  if Pos('Î', Result) > 0 then
    Result := strReplace(Result, 'Î', 'I');

  if Pos('î', Result) > 0 then
    Result := strReplace(Result, 'î', 'I');

  if Pos('Ô', Result) > 0 then
    Result := strReplace(Result, 'Ô', 'O');

  if Pos('ô', Result) > 0 then
    Result := strReplace(Result, 'ô', 'O');

  if Pos('Û', Result) > 0 then
    Result := strReplace(Result, 'Û', 'U');

  if Pos('û', Result) > 0 then
    Result := strReplace(Result, 'û', 'U');

  if Pos('Ã', Result) > 0 then
    Result := strReplace(Result, 'Ã', 'A');

  if Pos('ã', Result) > 0 then
    Result := strReplace(Result, 'ã', 'A');

  if Pos('Õ', Result) > 0 then
    Result := strReplace(Result, 'Õ', 'O');

  if Pos('õ', Result) > 0 then
    Result := strReplace(Result, 'õ', 'O');

  if Pos('Ç', Result) > 0 then
    Result := strReplace(Result, 'Ç', 'C');

  if Pos('ç', Result) > 0 then
    Result := strReplace(Result, 'ç', 'C');

  if Pos('Ü', Result) > 0 then
    Result := strReplace(Result, 'Ü', 'U');

  if Pos('ü', Result) > 0 then
    Result := strReplace(Result, 'ü', 'U');

end;

function RetEstagioLote(aTipo: Integer): string;
begin
  case aTipo of
    0: Result := 'SEPARAÇÃO';
    1: Result := 'CONFERÊNCIA';
    2: Result := 'CONCLUÍDO';
    3: Result := 'CONCLUÍDO NO ERP'
  else
    Result    := 'NÃO DEFINIDO';
  end;
end;


procedure CompactarArquivo(APathOrig, APathDest : String);
var
  Zipper: TZipFile;
begin
  InicializaObjeto(Zipper);
  try
    Zipper := TZipFile.Create();
    Zipper.Open(APathDest, zmWrite);
    if FileExists(APathOrig) then
      Zipper.Add(APathOrig);
    Zipper.Close;
  finally
    FreeAndNil(Zipper);
  end;
end;

procedure DescompactarArquivo(AZipName, ADest: string);
var
  UnZipper: TZipFile;
begin
  InicializaObjeto(UnZipper);
  try
    UnZipper := TZipFile.Create();
    UnZipper.Open(AZipName, zmRead);
    UnZipper.ExtractAll(ADest);
    UnZipper.Close;
  finally
    FreeAndNil(UnZipper);
  end;
end;

function DifSaldoCtbComparativo(AValorAnt, AValorAtual : Float; ANatCta : String) : Float;
begin
  Result := 0.00;

  if ANatCta = 'D' then
  begin
    if (fltRound(AValorAnt,2) = 0.00) and (fltRound(AValorAtual,2) > 0.00) then
      Result := fltRound(AValorAtual,2) - fltRound(AValorAnt,2);

    if (fltRound(AValorAnt,2) = 0.00) and (fltRound(AValorAtual,2) < 0.00) then
      Result := fltRound(AValorAtual,2) - fltRound(AValorAnt,2);

    if (fltRound(AValorAnt,2) > 0.00) and (fltRound(AValorAtual,2) = 0.00) then
      Result := fltRound(AValorAtual,2) - fltRound(AValorAnt,2);

    if (fltRound(AValorAnt,2) < 0.00) and (fltRound(AValorAtual,2) = 0.00) then
      Result := fltRound(AValorAtual,2) - fltRound(AValorAnt,2);
  end;

  if ANatCta = 'C' then
  begin
    if (fltRound(AValorAnt,2) = 0.00) and (fltRound(AValorAtual,2) < 0.00) then
      Result := (fltRound(AValorAtual,2) - fltRound(AValorAnt,2)) * -1;

    if (fltRound(AValorAnt,2) = 0.00) and (fltRound(AValorAtual,2) > 0.00) then
      Result := (fltRound(AValorAtual,2) - fltRound(AValorAnt,2)) * -1;

    if (fltRound(AValorAnt,2) < 0.00) and (fltRound(AValorAtual,2) = 0.00) then
      Result := (fltRound(AValorAtual,2) - fltRound(AValorAnt,2)) * -1;

    if (fltRound(AValorAnt,2) > 0.00) and (fltRound(AValorAtual,2) = 0.00) then
      Result := (fltRound(AValorAtual,2) - fltRound(AValorAnt,2)) * -1;
  end;

  if (fltRound(AValorAnt,2) > 0.00) and (fltRound(AValorAtual,2) > 0.00) then
  begin
    Result := fltRound(AValorAtual,2) - fltRound(AValorAnt,2);

    if ANatCta = 'C' then
      Result := Result * -1;
  end;

  if (fltRound(AValorAnt,2) < 0.00) and (fltRound(AValorAtual,2) < 0.00) then
  begin
    Result := fltRound(Abs(AValorAtual),2) - fltRound(Abs(AValorAnt),2);

    if ANatCta = 'D' then
    begin
      //Crédito aumentou: diminui conta devedora
      if Result > 0.00 then
        Result := Result * -1
      else
      //Crédito diminuiu: aumenta conta devedora
      if Result < 0.00 then
        Result := Result * -1;
    end;
  end;

  if (fltRound(AValorAnt,2) > 0.00) and (fltRound(AValorAtual,2) < 0.00) then
  begin
    //Saldo era devedor e ficou credor
    Result := (fltRound(Abs(AValorAtual),2) + fltRound(Abs(AValorAnt),2)) * -1;

    if ANatCta = 'C' then
    begin
      Result := Abs(Result);
    end;

    if ANatCta = 'D' then
    begin
      Result := Abs(Result) * -1;
    end;
  end;

  if (fltRound(AValorAnt,2) < 0.00) and (fltRound(AValorAtual,2) > 0.00) then
  begin
    //Saldo era credor e ficou devedor
    Result := fltRound(Abs(AValorAtual),2) + fltRound(Abs(AValorAnt),2);

    if ANatCta = 'C' then
    begin
      Result := Abs(Result) * -1;
    end;

    if ANatCta = 'D' then
    begin
      Result := Abs(Result);
    end;
  end;
end;

function TrocaCaracterEspecial(const aTexto: string;
  const aLimCaracterExt: boolean): string;
const
  //Lista de caracteres especiais
  vListaCarEsp: array[1..40] of String = ('á', 'à', 'ã', 'â', 'ä','Á', 'À', 'Ã', 'Â', 'Ä',
                                          'é', 'è','É', 'È','ê','Ê','í', 'ì','Í', 'Ì',
                                          'ó', 'ò', 'ö','õ', 'ô','Ó', 'Ò', 'Ö', 'Õ', 'Ô',
                                          'ú', 'ù', 'ü','Ú','Ù', 'Ü','ç','Ç','ñ','Ñ');
  //Lista de caracteres para troca
  vListaCarTroca: array[1..40] of String = ('A', 'A', 'A', 'A', 'A','A', 'A', 'A', 'A', 'A',
                                            'E', 'E','E', 'E','E','E','I', 'I','I', 'I',
                                            'O', 'O', 'O','O', 'O','O', 'O', 'O', 'O', 'O',
                                            'U', 'U', 'U','U','U', 'U','C','C','N', 'N');

  //Lista de Caracteres Extras
  vListaCarExtra: array[1..52] of String = ('<','>','!','@','#','$','%','¨','&','*',
                                            '(',')','_','+','=','{','}','[',']','?',
                                            ';',':','|','*','"','~','^','´','`',
                                            '¨','æ','Æ','ø','£','Ø','','ª','º','¿',
                                            '®','½','¼','ß','µ','þ','ý','Ý','-','.',',','/','\');

var
  vTexto: String;
  i: Integer;
begin
  vTexto := aTexto;

  //Troca caracteres especiais
  for i := 1 to 40 do
    vTexto := StringReplace(vTexto, vListaCarEsp[i], vListaCarTroca[i], [rfreplaceall]);

  //De acordo com o parâmetro aLimCaracterExt, elimina caracteres extras.
  if (aLimCaracterExt) then
    for i := 1 to 52 do
     vTexto := StringReplace(vTexto, vListaCarExtra[i], '', [rfreplaceall]);

  Result := vTexto;
end;

function RetornaSugestaoMultiplaEmbCpra(const aQtdSugestao,
  aEmbCpra: Double): Double;
var
  vResultadoDiv: Double;
begin
  Result        := 0.00;
  vResultadoDiv := 0.00;

  if (aEmbCpra <= 1) then
  begin
    Result := aQtdSugestao;
    Exit;
  end;

  if (aQtdSugestao <= aEmbCpra) then
  begin
    Result := aEmbCpra;
    Exit;
  end;

  vResultadoDiv := FltRound((aQtdSugestao / aEmbCpra),0);
  Result := aEmbCpra * vResultadoDiv ;
end;

function RetornaSugestaoCaixa(const aQtdSugestaoUN, aEmbCpra: Double): Double;
var
  vResultadoDiv: Double;
begin
  Result        := 0.00;
  vResultadoDiv := 0.00;

  if (aEmbCpra <= 1) then
  begin
    Result := aQtdSugestaoUN;
    Exit;
  end;

  if (aQtdSugestaoUN <= aEmbCpra) then
  begin
    Result := aEmbCpra;
    Exit;
  end;

  vResultadoDiv := FltRound((aQtdSugestaoUN / aEmbCpra),0);
  if (vResultadoDiv <= aEmbCpra) then
    Result := 1
  else
    Result := vResultadoDiv;
end;

function RetornaTipoVendaImpressaoEtiqueta(const aOpcao: string): Integer;
begin
  Result := 0;
  if (aOpcao = 'P') then
    Result := 0
  else
    Result := 1;
end;

function RetornaTipoOpcaoCSSomenteImpressaoEtiqueta(const aOpcao: string): Integer;
begin
  Result := 0;
  if (aOpcao = 'C') then
    Result := 0
  else if (aOpcao = 'S') then
    Result := 1
  else
    Result := 2;
end;

function RetornaTipoOpcaoEtiquetasImpressas(const aOpcao: string): Integer;
begin
  Result := 0;
  if (aOpcao = 'N') then
    Result := 0
  else if (aOpcao = 'S') then
    Result := 1
  else
    Result := 2;
end;

function RetornaEmbCpraXPrecoPDV(const aEmbCpra, aEmbVda, aQtdAtacado,
  aValVenda, aValVendaAtacado: Currency): string;
var
  vEmbXVenda: Currency;
begin
  Result     := '';
  if (aEmbCpra = aEmbVda) then
    Exit;
  vEmbXVenda := 0.00;
  if ((aQtdAtacado > 0) and (aValVendaAtacado > 0.00) and (aEmbCpra >= aQtdAtacado)) then
    vEmbXVenda := FltRound(aEmbCpra * aValVendaAtacado, 2)
  else
    vEmbXVenda := FltRound(aEmbCpra * aValVenda, 2);
  Result := FloatToStr(vEmbXVenda);
end;

function TrocarCaracterEspecialReduzida(const aTexto: string;
  const aLimCaracterExt: boolean): string;
const
  //Lista de caracteres especiais
  vListaCarEsp: array[1..40] of String = ('á','à','ã','â','ä','Á','À','Ã','Â','Ä',
                                          'é','è','É','È','ê','Ê',
                                          'í', 'ì','Í', 'Ì',
                                          'ó','ò','ö','õ','ô','Ó','Ò','Ö','Õ','Ô',
                                          'ú','ù','ü','Ú','Ù','Ü',
                                          'ç','Ç',
                                          'ñ','Ñ');
  //Lista de caracteres para troca
  vListaCarTroca: array[1..40] of String = ('a','a','a','a','a','A','A','A','A','A',
                                            'e','e','E','E','e','E',
                                            'i','i','I','I',
                                            'o','o','o','o','o','O','O','O','O','O',
                                            'u','u','u','U','U','U',
                                            'c','C',
                                            'n','N');

  //Lista de Caracteres Extras
  vListaCarExtra: array[1..47] of String = ('<', '>', '!', '@', '#', '$', '%', '¨',
                                            '&', '*', '(', ')', '_', '+', '=', '{',
                                            '}', '[', ']', '?', ';', ':', '|', '"',
                                            '~', '^', '´', '`', '¨', 'æ', 'Æ', 'ø',
                                            '£', 'Ø', '', 'ª', 'º', '¿', '®', '½',
                                            '¼', 'ß', 'µ', 'þ', 'ý', 'Ý', '-');
var
  vTexto: String;
  i: Integer;
begin
  vTexto := aTexto;

  //Troca caracteres especiais
  for i := 1 to 40 do
    vTexto := StringReplace(vTexto, vListaCarEsp[i], vListaCarTroca[i], [rfreplaceall]);

  //De acordo com o parâmetro aLimCaracterExt, elimina caracteres extras.
  if (aLimCaracterExt) then
    for i := 1 to 47 do
     vTexto := StringReplace(vTexto, vListaCarExtra[i], '', [rfreplaceall]);

  Result := vTexto;
end;

function RetornaEntidadeInstabuy(const aFormaPagamento: string): string;
begin
  Result := 'DINHEIRO';

  Case AnsiIndexStr(aFormaPagamento,
    ['credit',{0}
     'debit',{1}
     'vale',{2}
     'check',{3}
     'cash',{4}
     'deposit',{5}
     '_billet',{6}
     '_pix',{7}
     '_credit'{8}]) of
       0: Result := 'CREDITO';
       1: Result := 'DEBITO';
       2: Result := 'VALE';
       3: Result := 'CHEQUE';
       4: Result := 'DINHEIRO';
       5: Result := 'DEPOSITO BANCARIO';
       6: Result := 'BOLETO BANCARIO';
       7: Result := 'PIX';
       8: Result := 'CREDITO ONLINE';
    else
      Result := 'DINHEIRO';
  End;
end;

function CalcCustoCImposto(const aFlgNaoPISCofins: string; const aValCustoRep,
  aValVenda, aValOferta, aPerICMSSaida, aPerICMSEntrada, aPerPis, aPerCofins: Currency): Currency;
var
  vVenda: Currency;
begin
  Result := 0.00;
  vVenda := 0.00;
  vVenda := iif(aValOferta > 0.00, aValOferta, aValVenda);
  if (aFlgNaoPISCofins = 'S') then
    Result := FltRound(aValCustoRep + (vVenda * ((aPerICMSSaida + 0.00 + 0.00) / 100)) -
      (aValCustoRep * ((aPerICMSEntrada + 0.00 + 0.00) / 100)), 2)
  else
    Result := FltRound(aValCustoRep + (vVenda * ((aPerICMSSaida + aPerPis + aPerCofins) / 100)) -
      (aValCustoRep * ((aPerICMSEntrada + aPerPis + aPerCofins) / 100)), 2);
end;

function RetornaTipoNaoIncidente(const aTipo: integer): string;
begin
  Result := '';
  Case aTipo of
    0: Result := 'Alíquota Zero';
    1: Result := 'Monofásico';
    2: Result := 'Substituição';
    3: Result := 'Imune';
    4: Result := 'Suspensão';
  End;
end;

function ValidarQtdMaximaColetadaInventario(const aQtdMaxima,
  aQtdColetada: Double): Boolean;
var
  vQtdColetada: Double;
begin
  Result       := False;
  vQtdColetada := 0.00;
  vQtdColetada := iif(aQtdColetada < 0.00, (aQtdColetada * -1), aQtdColetada);
  //
  if (vQtdColetada > aQtdMaxima) then
    Result := True;
end;

{
procedure TForm1.Button1(Sender: TObject);
begin
  ShowMessage(GetEnvVarValue('SystemRoot'));
end;

{--- Here is the list of different variables you could use -----------
ALLUSERSPROFILE
APPDATA
CLIENTNAME
CommonProgramFiles
COMPUTERNAME
ComSpec
HOMEDRIVE
HOMEPATH
LOGONSERVER
NUMBER_OF_PROCESSORS
OS
Path
PATHEXT
PCToolsDir
PROCESSOR_ARCHITECTURE
PROCESSOR_IDENTIFIER
PROCESSOR_LEVEL
PROCESSOR_REVISION
ProgramFiles
SESSIONNAME
SystemDrive
SystemRoot
TEMP
TMP
USERDOMAIN
USERNAME
USERPROFILE
windir  }


initialization
  Randomize;

  SysMetric := TSystemMetric.Create;
  IsWin95 := (GetVersion and $FF00) >= $5F00;
{$IFDEF Win32}
  IsWinNT := CheckNT;
{$ELSE}
  IsWinNT := False;
{$ENDIF}

  IsFabula := nil;

{$IFDEF Win32}
  xLanguage := (LoWord(GetUserDefaultLangID) and $3FF);
  case xLanguage of
    LANG_GERMAN: xLangOfs := 70000;
    LANG_ENGLISH: xLangOfs := 71000;
    LANG_SPANISH: xLangOfs := 72000;
    LANG_RUSSIAN: xLangOfs := 73000;
    LANG_ITALIAN: xLangOfs := 74000;
    LANG_FRENCH: xLangOfs := 75000;
    LANG_PORTUGUESE: xLangOfs := 76000;
  else
    xLangOfs := 71000;
  end;
{$ENDIF}

{$IFDEF Win32}
finalization
  SysMetric.Free;
{$ELSE}
  AddExitProc(DoneXProcs);
{$ENDIF}

end.

